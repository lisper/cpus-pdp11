.REM	@







		IDENTIFICATION
		--------------

	PRODUCT CODE:	AC-8054B-MC

	PRODUCT NAME:	CFKTHB0 PDP 11/34 MEM MGMT

	DATE:		JUNE 22,1978

	MAINTAINER:	DIAGNOSTIC PROGRAMMIMG

	AUTHOR:		DIAGNOSTIC ENGINEERING





THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
EQUIPMENT CORPORATION. DIGITAL EQUIPMENT CORPORATION ASSUMES
NO RESPONSIBILITY FOR ANY ERRORS THAT MAY APPEAR IN THIS
DOCUMENT.

THE SOFTWARE DESCRIBED IN THIS DOCUMENT IS FURNISHED TO THE
PURCHASER UNDER A LICENSE FOR USE ON A SINGLE COMPUTER SYSTEM
AND CAN BE COPIED (WITH INCLUSION OF DIGITAL'S COPYRIGHT NOTICE)
ONLY FOR USE IN SUCH SYSTEM, EXCEPT AS MAY OTHERWISE BE PROVIDED
IN WRITING BY DIGITAL.

DIGITAL EQUIPMENT CORPORATION ASSUMES NO RESPONSIBILITY
FOR THE USE OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
THAT IS NOT SUPPLIED BY DIGITAL.

COPYRIGHT (C) 1977, 1978 BY DIGITAL EQUIPMENT CORPORATION










		
		
		
		
		
	PROGRAM HISTORY	
		
		
DATE		REVISION	REASON FOR REVISION
----		--------	-------------------
		
31-JAN-77	A		FIRST RELEASE
28-JUN-78	B		HARDWARE FAULT NOT DETECTED
		
		



TABLE OF CONTENTS


1.0	PROGRAM INFORMATION
1.1	ABSTRACT
1.2	REQUIREMENTS
1.3	RELATED DOCUMENTS AND STANDARDS
1.4	PRELIMINARY PROGRAMS

2.0	OPERATING INSTRUCTIONS
2.1	LOADING PROCEDURES
2.2	STARTING PROCEDURES
2.3	OPERATIONAL SWITCH SETTINGS
2.4	LOADING THE SWITCH REGISTER
2.5	EXECUTION TIMES

3.0	ERROR INFORMATION
3.1	ERROR REPORTING PROCEDURES
3.2	INTERPRETING ERROR REPORTS
3.3	SAMPLE ERROR REPORT

4.0	MISCELLANEOUS INFORMATION
4.1	ACT/APT/XXDP COMPATABILITY
4.2	END-OF-PASS MESSAGE
4.3	T-BIT TRAPPING
4.4	POWER FAILURE HANDLING
4.5	PHYSICAL BUS ADDRESS CONSTRUCTION

5.0	PROGRAM DESCRIPTION
5.1	SUBROUTINES USED BY THIS PROGRAM
5.2	PROGRAM LISTING
5.3	USING THE PROGRAM TO DIAGNOSE A FAULT

1.0	PROGRAM INFORMATION


1.1	ABSTRACT


THIS PROGRAM WAS DESIGNED USING A "BOTTOM UP" APPROACH
STARTING WITH THE SMALLEST SEGMENT OF MEMORY MANAGMENT
LOGIC POSSIBLE AND BUILDING TO COVER ALL OF THE LOGIC.
THE DIAGNOSTIC WILL PROVIDE ENOUGH INFORMATION SUCH THAT
BY DEDUCTION, THE FAILURE CAN BE ISOLATED TO A SMALL
SEGMENT OF THE MEMORY MANAGEMENT LOGIC.

THE PROGRAM BEGINS BY TESTING SOME OF THE INTERNAL CPU
DATA AND ADDRESS PATHS AND ADDRESS DETECTION LOGIC, THEN
WORKS OUTWARD THROUGH THE MEMORY MANAGEMENT REGISTERS.
AFTER THE REGISTERS ARE FOUND TO BE USEABLE, RELOCATION
(CONSTRUCTION OF PHYSICAL ADDRESSES FROM A VIRTUAL ADDRESS
AND THE ASSOCIATED PAR/PDR INFORMATION) IS TESTED FOLLOWED
BY TESTING OF THE ABORT AND STATUS SEGMENTS OF LOGIC.
FINALLY, CHECKS OF SPECIAL ABORT SEQUENCES AND TESTING OF
THE MFPI/MTPI INSTRUCTIONS ARE DONE.

1.2	REQUIREMENTS


A PDP 11/34 PROCESSOR WITH A MINIMUM OF 16K OF MEMORY
AND A CONSOLE TERMINAL ARE REQUIRED TO RUN THE PROGRAM
UNLESS THE PROGRAM IS RUNNING UNDER APT OR ACT IN WHICH
CASE THE CONSOLE TERMINAL IS NOT NECESSARY.

1.3	RELATED DOCUMENTS AND STANDARDS


1.	ACT11/XXDP PROGRAMMING SPECIFICATION
2.	STANDARD APT SYSTEM TO A PDP11 DIAGNOSTIC INTERFACE
3.	DIAGNOSITC ENGINEERING STANDARDS AND CONVENTIONS
4.	PDP11 MAINDEC SYSMAC PACKAGE
5.	XXDP USER'S MANUAL

1.4	PRELIMINARY PROGRAMS


BEFORE THIS MEMORY MANAGEMENT DIAGNOSITC IS RUN, THE
FOLLOWING CPU DIAGNOSTICS SHOULD BE RUN:

MD-11-DFKAA	PDP 11/34 BASIC CPU TESTS
MD-11-DFKAB	PDP 11/34 TRAPS TESTS

ALSO, ONE OF THE MAIN MEMORY DIAGNOSTICS SHOULD BE RUN
TO SCAN AT LEAST THE FIRST 15K TO SEE THAT A PROGRAM
CAN BE EXECUTED.

2.0	OPERATING INSTRUCTIONS


2.1	LOADING PROCEDURES


THE PROGRAM IS SUPPLIED ON THE DIAGNOSTIC LOAD MEDIA.
REFER TO THE XXDP USER'S MANUAL FOR FURTHER INFORMATION.
FOR USE WITH ACT OR APT, REFER TO THEIR RESPECTIVE
DOCUMENTS. THE PROGRAM CAN ALSO BE DIRECTLY LOADED
USING THE ABSOLUTE LOADER AND THE BINARY PAPER TAPE.

2.2	STARTING PROCEDURES


THE PROGRAM IS STARTED BY LOADING ADDRESS 200 AND
STARTING. IF THE PROCESSOR HAS THE OPTIONAL PROGRAMMER'S
CONSOLE, THE SWITCH REGISTER SHOULD BE SET ACCORDING TO
SECTION 2.3 BEFORE THE PROGRAM IS STARTED. IF THERE
IS NO HARDWARE SWITCH REGISTER, THE PROGRAM WILL USE THE
SOFTWARE SWITCH REGISTER AT LOCATION 176 (LOCATION 174
WILL BE USED AS THE SOFTWARE DISPLAY REGISTER). IN THAT CASE
THE PROGRAM WILL ASK FOR THE INITIAL SWITCH REGISTER
VALUE BY TYPING "SWR= XXXXXX	MEW= " AFTER TYPING
THE NAME OF THE PROGRAM (XXXXXX = THE OCTAL CONTENTS OF
LOCATION 176). (SEE SECTION 2.4)

ALSO THE PROGRAM CAN BE MADE TO USE THE SOFTWARE SWITCH
REG. EVEN IF THE HARDWARE SWITCH REG. IS PRESENT BY LOADING
"177777" INTO THE HARDWARE SWITCH REG. BEFORE STARTING
THE PROGRAM.

2.3	CONTROL SWITCH SETTINGS


	SWITCH	OCTAL VALUE	USE
	------	-----------	------------
	SW15	100000		HALT ON ERROR
					THIS SWITCH WHEN SET WILL HALT
					THE PROCESSOR WHEN AN ERROR IS
					DETECTED AFTER THE ERROR MESSAGE
					HAS BEEN TYPED. PRESSING CONTINUE
					WILL RESUME TESTING (SEE SECTION
					3.1 ABOUT LOADING THE SWITCH REG
					BEFORE CONTINUING).

	SW14	040000		LOOP ON TEST
					THIS SWITCH WHEN SET WILL
					CAUSE THE PROGRAM TO LOOP ON
					THE CURRENT SUBTEST.

	SW13	020000		INHIBIT ERROR TYPEOUTS
					THIS SWITCH WHEN SET WILL.
					INHIBIT THE TYPING OF ERROR
					MESSAGES.

	SW12	010000		INHIBIT TRACE TRAP
					THIS SWITCH WHEN SET WILL
					INHIBIT T-BIT TRAPPING WHICH

					NORMALLY TAKES PLACE DURING
					EVERY OTHER PASS STARTING
					WITH THE THIRD PASS.

	SW11	004000		INHIBIT SUBTEST ITERATIONS
					THIS SWITCH WHEN SET INHIBITS
					ITERATIONS OF EACH SUBTEST AFTER
					THE FIRST PASS. IF THIS SWITCH
					IS NOT SET, EACH SUBTEST IS RUN
					200. TIMES.

	SW10	002000		BELL ON ERROR
					THIS SWITCH WHEN SET WILL RING
					THE CONSOLE TERMINAL BELL WHEN
					AN ERROR HAS BEEN DETECTED.

	SW9	001000		LOOP ON ERROR
					THIS SWITCH WHEN SET WILL
					CAUSE THE PROGRAM TO LOOP ON THE
					FIRST FAILURE WHICH IS ENCOUNTERED
					EVEN IF THE FAILURE IS INTERMITTANT

	SW8	000400		LOOP ON TEST IN SWR<7:0>
					THIS SWITCH WHEN SET WILL
					CAUSE THE PROGRAM TO LOOP ON THE
					TEST WHOSE TEST NUMBER IS SET
					IN BITS 7-0 OF THE SWITCH REG.

2.4	LOADING THE SWITCH REGISTER


THE HARDWARE SWITCH REGISTER PROVIDED WHEN THE OPTIONAL
PROGRAMMER'S CONSOLE IS PRESENT IS LOADED DIRECTLY FROM
THE CONSOLE KEYPAD BY DEPRESSING THE "LSR" KEY. THE
VALUE OF THE HARDWARE SWITCH REG. CAN BE CHANGED ANY
TIME WHETHER THE PROGRAM IS RUNNING OR NOT.

TO LOAD THE SOFTWARE SWITCH REG. WHILE THE PROGRAM IS
RUNNING, A CONTROL G (-G) SHOULD BE TYPED ON THE CONSOLE
TERMINAL. (THE "SCOPE" AND "ERROR" ROUTINES CHECK TO SEE
IF A -G HAS BEEN TYPED.) THE ORIGINAL VALUE OF THE SOFTWARE
SWTICH REG. WILL BE REQUESTED AS MENTIONED IN SECTION 2.2.

IN RESPONSE TO A -G OR AT THE BEGINNING OF THE PROGRAM, THE
PROGRAM WILL TYPE:

SWR = XXXXXX NEW =

WHERE "XXXXXX" IS THE CURRENT OCTAL CONTENTS OF LOC. 176.
THE OPERATOR MAY THEN TYPE ANY ONE OF THE FOLLOWING:
XXXXXX<CR> ONE TO SIX OCTAL DIGITS FOLLOWED BY A
CARRIAGE RETURN WHICH WILL BE LOADED
AS THE NEW VALUE FOR THE SWITCH REG.
<CR>	JUST A <CR>, LEAVES THE SWITCH REG.
AS IT IS.
XXX^U	A CONTROL-U (^U) WILL CAUSE ALL OF THE
DIGITS TYPED SO FAR TO BE IGNORED.
^C	WILL CAUSE THE PROGRAM TO TYPE THE PRESENT
TEST AND PASS NUMBERS, REQUEST A NEW VALUE
FOR THE SWITCH REG., AND JUMP TO THE END-
OF-PASS ROUTINE SO THE PROGRAM WILL GO DIRECTLY
TO THE NEXT PASS WITH A NEW SW. REG. VALUE
<ILL.CHAR> ANY CHARACTER TYPED WHICH IS NOT ANY OF THE
ABOVE OR AN OCTAL DIGIT WILL CAUSE THE PROGRAM
TO TYPE A "?<CRLF>" AND REACT AS THOUGH A
"U HAD BEEN TYPED.

NOTE:	RECOGNITION OF A "G MAY BE HAMPERED BY
EXECUTION OF A COUPLE "RESET" INSTRUCTIONS
WITHIN THE PROGRAM.

2.5	EXECUTION TIMES


THE RUN TIME FOR A SINGLE PASS WITH NO ITERATIONS
OR TRACE TRAPPING IS APPROXIMATELY 5 SECONDS.

THE RUN TIME FOR A SINGLE PASS WITH ITERATIONS
AND TRACE TRAPPING ENABLED IS APPROXIMATELY 3 1/4 MINUTES.

3.0	ERROR INFORMATION


3.1	ERROR REPORTING PROCEDURES


IF AN ERROR IS DETECTED, THE PROGRAM WILL TRAP TO THE
ERROR HANDLING ROUTINE ($ERROR). THE VALUE OF BITS
15,13,10, AND 9 IN THE SWITCH REGISTER ARE CONSIDERED
IN REPORTING AN ERROR (SEE SECTION 2.3). THE
ERROR INFORMATION WILL BE TYPED UNLESS SW13 = 1.

IF SW15 = 1, THE PROCESSOR WILL HALT AFTER THE ERROR IS
REPORTED. IF THE CONTENTS OF THE SOFTWARE SWITCH REGISTER
ARE TO BE CHANGED, A "G SHOULD BE TYPED BEFORE PRESSING
"CONTINUE" TO RESUME TESTING.

IF SW9 = 1 (LOOP ON ERROR), THE PROGRAM WILL GO TO THE
ADDRESS CONTAINED IN LOCATION "$LPERR". AFTER REPORTING
THE ERROR. "$LPERR" IS SET BY EACH "SCOPE" CALL AND IS
SET DIRECTLY DURING SOME SUBTESTS TO PROVIDE THE SMALLEST
LOOP FOR LOOPING ON ERROR. IF = 0, THE PROGRAM WILL
RETURN TO THE INSTRUCTION FOLLOWING THE ERROR CALL.
(SEE SECTION 5.3 FOR MORE ON "LOOP ON ERROR").

3.1	INTERPRETING ERROR REPORTS


EVERY ERROR REPORT TYPES THE NUMBER OF THE TEST IN WHICH
THE ERROR TOOK PLACE (TESTNO) AND THE LOCATION OF THE
ERROR CALL (ERRORPC). THESE TWO VALUES PINPOINT THE
PLACE IN THE CODE THAT THE ERROR OCCURRED. BY REFERRING
TO THE PROGRAM LISTING, THE OPERATOR CAN THEN READ THE
COMMENTS ASSOCIATED WITH THAT PARTICULAR ERROR AND SUBTEST.
A DESCRIPTION OF THE TEST FOUND IN THE PROGRAM LISTING
WILL ALSO PROVIDE THE OPERATOR WITH INFORMATION ON THE LOGIC
AND FUNCTIONS BEING TESTED.

EVERY ERROR REPORT ALSO TYPES AN ERROR MESSAGE
GIVING A VERBAL DESCRIPTION OF THE ERROR THAT HAS
BEEN DETECTED.

BY USING THE COMMENTS AND TEST DESCRIPTION FOUND IN
THE PROGRAM LISTING TO DETERMINE WHAT FUNCTION OR
LOGIC WAS BEING TESTED, THE OPERATOR CAN THEN REFER
TO THE ENGINEERING DRAWINGS TO ISOLATE THE PROBABLE
CAUSE FOR THE FAILURE.

3.3	SAMPLE ERROR REPORT


BELOW IS AN EXAMPLE OF AN ERROR WHICH COULD HAVE
OCCURRED DURING EXECUTION OF THE PROGRAM:

MEM. MGMT. REG. BITS NOT SET CORRECTLY
REGISTR WROTE	READ	READ-(BINARY)
ADDRESS (OCTAL) (OCTAL) 5432109876543210 TESTNO ERRORPC
177572 040000 060000 0110000020000000 000012 022060

WE SEE THAT THE ERROR OCCURRED IN TEST 12 AT LOACTION
022060. THE "REGISTR ADDRESS" TELLS US THAT WE WERE
TESTING MEMORY MANAGEMENT'S STATUS RGISTER 0 (SR0).
IN THE LISTING, THE TEST DESCRIPTION SAYS THAT THE
ERROR BITS (BITS <15:13>) OF SR0 WERE BEING SET AND
CLEARED INDIVIDUALLY. THE ERROR REPORT SAYS WE TRIED
TO SET BIT 14 BY WRITING "040000" TO SR0 BUT WHEN WE
READ IT BACK WE READ "060000". IT APPEARS THAT BIT 13 IS
STUCK AT "1" OR IT IS GETTING SET WHEN BIT 14 IS SET
TO "1". ERROR REPORTS BEFORE AND AFTER THIS ONE COULD
TELL US WHICH IS THE CASE.

4.0	MISCELLANEOUS INFORMATION


4.1	ACT/APT/XXDP COMPATABILITY


THE PROGRAM IS FULLY ACT AND APT COMPATABLE
AND IS SUPPORTED UNDER THE XXDP PACKAGE.

4.2	END-OF-PASS MESSAGE


AT THE END OF EACH PASS OF THE PROGRAM THE PASS NUMBER
AND TOTAL NUMBER OF ERRORS SINCE THE LAST END-OF-PASS ARE
REPORTED IN THE END-OF-PASS MESSAGE. FOR EXAMPLE:

END OF PASS #2 TOTAL ERRORS SINCE LAST REPORT 0

THAT WOULD INDICATE THAT PASS TWO WAS JUST COMPLETED
AND NO ERRORS WERE DETECTED DURING THAT PASS. BOTH
THE PASS NUMBER AND NUMBER OF ERRORS ARE DECIMAL NUMBERS.

4.3	T-BIT TRAPPING


THE "T-BIT" (BIT 4) IN THE PROCESSOR STATUS WORD IS SET
BY AN "RTI" IN THE END-OF-PASS ROUTINE FOR EVERY OTHER PASS
BEGINNING WITH THE THIRD PASS (PASSES 3,5,7,9...). T-BIT
TRAPPING CAN BE INHIBITED BY SETTING BIT 12 = 1 IN THE SWITCH
REGISTER (SEE SECTION 2.4).

4.4	POWER FAILURE HANDLING


IF A POWER FAIL OCCURS (FOLLOWED BY A POWER UP), THE
MESSAGE "POWER FAILURE-RESTARTING" IS TYPED OUT AND
THE PROGRAM WILL RESTART EXECUTION AT "START:" (THE
VERY BEGINNING OF THE PROGRAM. IF THE SOFTWARE
SWITCH REGISTER IS BEING USED, ITS CONTENTS WILL BE
RESTORED. IF THERE IS A HARDWARE SWITCH REGISTER,
THERE IS NO WAY TO RESTORE THE VALUE OF THE SWITCH
REGISTER SO THE OPERATOR MUST RELOAD IT FROM THE CONSOLE.

4.5	PHYSICAL BUS ADDRESS CONSTRUCTION


BELOW IS A SIMPLIFIED DIAGRAM OF HOW THE MEMORY
MAMAGEMENT LOGIC CONSTRUCTS A PHYSICAL BUS ADDRESS
USING THE VIRTUAL ADDRESS AND THE PAGE ADDRESS REGISTER.
THE PAGE DESCRIPTOR REGISTER SELECTED WILL CONTAIN THE
PAGE EXPANSION, LENGTH, AND ACCESS INFORMATION.

	     		12 11 10 09 08 07 06 05 04 03 02 01 00
			--------------------------------------
		       / 0  1  1  1  1  1  1/ 1  1  1  1  1  0/ VBA*
		       ---------------------------------------
                                                I
	       (ADDED TO)                       I
                                                I
	11 10 09 08 07 06 05 04 03 02 01 00     I
	-----------------------------------     I
       / 0  0  0  1  0  1  0  0  0  0  0  1/    I		PAR**
       ------------------------------------     I
                       I                        I
                       I                        I
                       V                        V
	17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	-----------------------------------------------------
       / 0  0  0  1  1  0  0  0  0  0  0  0  1  1  1  1  1  0/	PBA
       ------------------------------------------------------

	*=   VBA BITS <15:13> SELECT THE APPROPRIATE PAR AND PDR
	**=  PSW MODE BIT 01 (BIT 15) SELECTS THE USER (=1) OR
	       KERNEL (=0) SET OF PAR'S/PDR'S

5.0	PROGRAM DESCRIPTION


5.1	SUBROUTINES USED BY THIS PROGRAM


FOLLOWING IS A LIST OF THE SUBROUTINES AND HANDLERS USED
BY THIS PROGRAM THAT ARE NOT PROVIDED BY THE "SYSMAC
PACKAGE". DETAILS OF THE SUBROU1INES UNIQUE TO THIS
PROGRAM MAY BE FOUND IN THE PROGRAM LISTING. REFER TO
THE "SYSMAC" DOCUMENT AND PROGRAM LISTING FOR THE OTHER
ROUTINES.

1. TURN OFF T-BIT AND SAVE CURRENT PSW
2. TURN ON T-BIT AND RESTORE PREVIOUS PSW
3. SET ALL WRITEABLE BITS IN ALL PAR/PDR'S
4. READ AND COMPARE KERNEL AND USER PAR/PDR'S
5. CONVERT VIRTUAL ADDRESS TO PHYSICAL ADDRESS

5.2	PROGRAM LISTING


A TABLE OF CONTENTS APPEARS AT THE BEGINNING OF THE LISTING
WHICH CONTAINS THE NAMES OF EACH SECTION, SUBTEST, AND
ROUTINE AND THE LINE NUMBERS CORRESPONDING TO THE START OF
EACH.

FOLLOWING THIS SECTION OF DOCUMENTATION IS THE ACTUAL
PROGRAM LISTING COMPLETE WITH SUBTEST DESCRIPTIONS AND
"CODING COMMENTS".

5.3	USING THE PROGRAM TO DIAGNOSE A FAULT


WHEN AN ERROR OCCURS, ONE OF THE THINGS THAT'S IMPORTANT
TO NOTE IS WHAT PASS THE ERROR OCCURRED ON. IF THE PASS
NUMBER IS ODD AND IS THREE OR GREATER, THE ERROR MIGHT BE
T-BIT SENSITIVE. TRY RUNNING THE PROGRAM AGAIN WITH BIT
12 OF THE SWITCH REG. EQUAL TO "1" TO INHIBIT T-BIT
TRAPPING. IF THE PASS NUMBER IS GREATER THAN ONE, THE
ERROR MAY BE ITERATION SENSITIVE. TRY RUNNING THE PROGRAM
AGAIN WITH BIT 11 OF THE SWITCH REG. EQUAL TO "1" TO INHIBIT
ITERATIONS. THESE HINTS SHOULD HELP YOU DETERMINE WHAT MAKES
THE MACHINE FAIL AND WHEN.

IF YOU HAVE BEEN RUNNING WITH BIT 15 OF THE SWITCH
REG. EQUAL TO "0", THEN YOU ARE ABLE TO LOOK AT ALL
THE ERRORS THAT MAY BE RELATED TO THE FAULT YOU ARE
DIAGNOSING. A FAULT IN AN EARLIER TEST MAY RESULT IN
ERRORS DURING LATER TESTS WHICH MAY GIVE YOU MORE
CLUES ABOUT THE NATURE OF THE FAULT. NOW USE THE METHOD
OUTLINED IN SECTION 3.2 FOR EACH ERROR TO GATHER AS
MUCH INFORMATION AS POSSIBLE.

NOW TO TEST YOUR IDEAS ON THE CAUSE OF THE FAILURE,
YOU MAY WANT TO SCOPE THIS ERROR CONDITION. SET BIT 09
OF THE SWITCH REG. EQUAL TO "1" TO LOOP ON THE ERROR.
FOR AN EVEN TIGHTER SCOPE LOOP THE ERROR CALL CAN BE
REPLACED WITH A BRANCH (REFER TO COMMENTS BY ERROR CALLS
IN THE PROGRAM LISTING).

OR YOU COULD LOOP ON THE TEST BY EITHER SETTING BIT 14
OF THE SWITCH REG. EQUAL TO "1" OF BY SETTING BIT 08 OF THE
SWITCH REG. EQUAL TO "1" AND THEN SETTING THE TEST NUMBER
IN BITS 07-00 OF THE SWITCH REG. YOU WILL PROBABLY WANT TO
INHIBIT ERROR TYPEOUTS BY SETTING BIT 13 OF THE SWITCH REG.
EQUAL TO "1".




@
.TITLE CFKTHB0 PDP 11/34 MEM MGNT DIAG
       .ASECT
;*
;*THIS PROGRAM WAS ASSEMBLED USING THE PDP-11 MAINDEC SYSMAC
;*PACKAGE (MAINDEC-11-DZQAC-C3), JAN 19, 1977.
;*
.SBTTL OPERATIONAL SWITCH SETTINGS
;*
;*	SWITCH	USE
;*
;*	15	HALT ON ERROR
;*	94	LOOP ON TEST
;*	13	INHIBIT ERROR TYPEOUTS
;*	12	INHIBIT TRACE TRAP
;*	11	INHIBIT ITERATIONS
;*	10	BELL ON ERROR
;* 	9	LOOP ON ERROR
;*	8	LOOP ON TEST IN SWR<7:0>
.SBTTL BASIC DEFINITIONS

;*INITIAL ADDRESS OF THE STACK POINTER *** 1100 ***
STACK= 1100
.EQUIV EMT,ERROR	;;BASIC DEFINITION OF ERROR CALL
.EQUIV IOT,SCOPE	;;BASIC DEFINITION OF SCOPE CALL

;*MISCELLANEOUS DEFINITIONS
HT=	11	;;CODE FOR HORIZONTAL TAB
LF=	12	;;CODE FOR LINE FEED
CR=	15	;;CODE FOR CARRIAGE RETURN
CRLF=	200	;;CODE FOR CARRIAGE RETURN-LINE FEED
PS=	177776	;;PROCESSOR STATUS WORD
.EQUIV PS,PSW
STKLMT= 177774	;;STACK LIMIT REGISTER
PIRQ=	177772	;;PROGRAM INTERRUPT REQUEST REGISTER
DSWR=	177570	;:HARDWARE SWITCH REGISTER
DDISP= 177570	;;HARDWARE DISPLAY REGISTER

;*GENERAL PURPOSE REGISTER DEFINITIONS
R0=	%0	;:GENERAL REGISTER
R1=	%1	;;GENERAL REGISTER
R2=	%2	;;GENERAL REGISTER
R3=	%3	;;GENERAL REGISTER
R4=	%4	;;GENERAL REGISTER
R5=	%5	;;GENERAL REGISTER
R6=	%6	;;GENERAL REGISTER
R7=	%7	;;GENERAL REGISTER
SP=	%6	;;STACK POINTER
PC=	%7	;;PROGRAM COUNTER

;*PRIORITY LEVEL DEFINITIONS
PRO=	0	;;PRIORITY LEVEL 0
PRI=	40	;;PRIORITY LEVEL 1
PR2=	100	;;PRIORITY LEVEL 2
PR3=	140	;;PRIORITY LEVEL 3
PR4=	200	;;PRIORITY LEVEL 4
PR5=	240	;;PRIORITY LEVEL 5
PR6=	300	;;PRIORITY LEVEL 6
PR7=	340	;;PRIORITY LEVEL 7

;*"SWITCH REGISTER' SWITCH DEFINITIONS
SW15=	100000
SW14=	40000
SW13=	20000
SW12=	10000
SW11=	4000
SW10=	2000
SW09=	1000
SW08=	400
SW07=	200
SW06=	100
SW05=	40
SW04=	20
SW03=	10
SW02=	4
SW01=	2
SW00=	1
.EQUIV SW09,SW9
.EQUIV SW08,SW8
.EQUIV SW07,SW7
.EQUIV SW06,SW6
.EQUIV SW05,SW5
.EQUIV SW04,SW4
.EQUIV SW03,SW3
.EQUIV SW02,SW2
.EQUIV SW01,SW1
.EQUIV SW00,SWO

;*DATA BIT DEFINITIONS (BIT00 TO BIT15)
BIT15= 100000
BIT14= 40000
BITI3= 20000
BIT12= 10000
BIT11= 4000
BIT10= 2000
BIT09= 1000
BIT08= 400
BIT07= 200
BIT06= 100
BIT05= 40
BIT04= 20
BIT03= 10
BIT02= 4
BIT01= 2
BIT00= 1
.EQUIV BIT09,BIT9
.EQUIV BIT08,BIT8
.EQUIV BIT07,BIT7
.EQUIV BIT06,BIT6
.EQUIV BIT05,BIT5
.EQUIV BIT04,BIT4
.EQUIV BIT03,BIT3
.EQUIV BIT02,BIT2
.EQUIV BIT01,BIT1
.EQUIV BIT00,BIT0

;*BASIC *CPU* TRAP VECTOR ADDRESSES
ERRVEC= 4	;;TIME OUT AND OTHER ERRORS
RESVEC= 10	;;RESERVED AND ILLEGAL INSTRUCTIONS
TBITVEC=14	;;"T" BIT
TRTVEC= 14	;;TRACE TRAP
BPTVEC= 14	;;BREAKPOINT TRAP (BPT)
IOTVEC= 20	;;INPUT/OUTPUT TRAP (IOT) **SCOPE*4,
PWRVEC= 24	;;POWER FAIL
EMTVEC= 30	;;EMULATOR TRAP (EMT) **ERROR,*
TRAPVEC=34	;;"TRAP" TRAP
TKVEC= 60	;; TTY KEYBOARD VECTOR
TPVEC= 64	;; TTY PRINTER VECTOR
PIROVEC=240	;; PROGRAM INTERRUPT REQUEST VECTOR
.SBTTL MEMORY MANAGEMENT DEFINITIONS

;*KTII VECTOR ADDRESS

MMVEC= 250

;*KT1I STATUS REGISTER ADDRESSES

SR0=	177572
SR1=	177574
SR2=	177576
SR3=	172516

;*USER	"I" PAGE DESCRIPTOR REGISTERS

UIPDR0= 177600
U1PDR1= 177602
U1PDR2= 177604
UIPDR3= 177606
UIPDR4= 177610
UIPOR5= 177612
UIPOR6= 177614
UIPDR7= 177616

;*USER "I" PAGE ADDRESS REGISTERS

UIPARO= 177640
UIPAR1= 177642
UIPAR2= 177644
UIPAR3= 177646
UIPAR4= 177650
UIPARS= 177652
UIPAR6= 177654
UIPAR7= 177656

;*KERNEL "I" PAGE DESCRIPTOR REGISTERS

KIPDRO= 172300
KIPDR1= 172302
KIPDR2= 172304
KIPDR3= 172306
KIPDR4= 172310
KIPDR5= 172312
KIPDR6= 172314
KIPDR7= 172316

;*KERNEL "I" PAGE ADDRESS REGISTERS

KIPAR0=172340
KIPAR1=172342
KIPAR2=172344
KIPAR3=172346
KIPAR4=172350
KIPAR5=172352
KIPAR6=172354
KIPAR7=172356

KSP=%7
USP=%7
	.EQUIV SP,KSP
	.EQUIV SP,USP
	.EQUIV BIT4,TBIT
	.EQUIV BIT6,WBIT
	KERSTK= STACK
	USESTK= STACK-200

;*ADDITIONAL DEFINITIONS
;*

.SBTTL TRAP CATCHER
       .=0
;*ALL UNUSED LOCATIONS FROM 4 - 776 CONTAIN A ".+2,HALT" 
;*SEQUENCE TO CATCH ILLEGAL TRAPS AND INTERRUPTS
;*LOCATION 0 CONTAINS 0 TO CATCH IMPROPERLY LOADED VECTORS
	.=174
DISPREG: .WORD 0	;:SOFTWARE DISPLAY REGISTER
SWREG:	 .WORD 0	;;SOFTWARE SWITCH REGISTER
.SBTTL STARTING ADDRESS(ES)
	JMP	@#START ;;JUMP TO STARTING ADDRESS OF PROGRAM
.SBTTL ACT11 HOOKS

;;*****************************************************************
;HOOKS REQUIRED BY ACT11
	$SVPC=.	;SAVE PC
	.=46
	$ENDAD	;;1)SET LOC.46 TO ADDRESS OF SENDAD IN .SEOP
	.=52
	.WORD	0	;;2)SET LOC.52 TO ZERO
	.=$SVPC	;; RESTORE PC
.SBTTL APT PARAMETER BLOCK
;;**************************************************************** 
;SET LOCATIONS 24 AND 44 AS REQUIRED FOR APT
;;**************************************************************** 
	.$X=.	;;SAVE CURRENT LOCATION
	.=24	;;SET POWER FAIL TO POINT TO START OF PROGRAM

	200	;;FOR APT START UP	
	.=44	;;POINT TO APT INDIRECT ADDRESS PNTR.	
	$APTHDR ;;POINT TO APT HEADER BLOCK	
	.=.$X	;;RESET LOCATION COUNTER	
;;*****************************************************************	
;SETUP APT PARAMETER BLOCK AS DEFINED IN THE APT
;INTERFACE SPEC.	

$APTHD:	
$HIBTS:	.WORD	0	;;TWO HIGH BITS OF 18 BIT MAILBOX ADDR.
$MBADR:	.WORD	$MAIL	;;ADDRESS OF APT MAILBOX (BITS 0-15)
$TSTM:	.WORD	10	;;RUN TIM OF LONGEST TEST
$PASTM:	.WORD	20	;;RUN TIME IN SECS. OF 1ST PASS ON 1 UNIT (QUICK VERIFY)
$UNITM:	.WORD	5	;:ADDITIONAL RUN TIME (SECS) OF A PASS FOR EACH ADDITIONAL UNIT
	.WORD	$ETEND-$MAIL/2 ;;LENGTH MAILBOXETABLE(WORDS)

.SBTTL	COMMON TAGS	

;;*****************************************************************	
;*THIS TABLE CONTAINS VARIOUS COMMON STORAGE LOCATIONS
;*USED IN THE PROGRAM.
	
	.=1100
$CMTAG:				;;START OF COMMON TAGS
	.WORD	0			
$TSTNM:	.BYTE	0		;;CONTAINS THE TEST NUMBER
$ERFLG:	.BYTE	0		;;CONTAINS ERROR FLAG
$ICNT:	.WORD	0		;;CONTAINS SUBTEST ITERATION COUNT 
$LPADR:	.WORD	0		;;CONTAINS SCOPE LOOP ADDRESS
$LPERR:	.WORD	0		;;CONTAINS SCOPE RETURN FOR ERRORS 
$ERTTL:	.WORD	0		;;CONTAINS TOTAL ERRORS DETECTED 	

$ITEMB:	.BYTE	0		;;CONTAINS ITEM CONTROL BYTE
$ERMAX:	.BYTE	0		;;CONTAINS MAX. ERRORS PER TEST
$ERRPC:	.WORD	0		;;CONTAINS PC OF LAST ERROR INSTRUCTION
$GDADR:	.WORD	0		;;CONTAINS ADDRESS OF 'GOOD' DATA
$BDADR:	.WORD	0		;;CONTAINS ADDRESS OF 'BAD' DATA
$GDDAT:	.WORD	0		;;CONTAINS 'GOOD' DATA
$BDDAT:	.WORD	0		;;CONTAINS 'BAD' DATA
	.WORD	0		;;RESERVED--NOT TO BE USED
	.WORD	0
$AUTOB:	.BYTE	0		;;AUTOMATIC MODE INDICATOR
$INTAG:	.BYTE	0		;;INTERUPT MODE INDICATOR
	.WORD	0
SWR:	.WORD	DSWR		;;ADDRESS OF SWITCH REGISTER
DISPLAY: .WORD	DDISP		;;ADDRESS OF DISPLAY REGISTER
$TKS:	177560			;;TTY KBD STATUS
$TKB:	177562			;;TTY KBD BUFFER
$TPS:	177564			;;TTY PRINTER STATUS REG. ADDRESS
$TPB:	177566			;;TTY PRINTER BUFFER REG. ADDRESS
$NULL:	.BYTE	0		;;CONTAINS NULL CHARACTER FOR FILLS
$FILLS:	.BYTE	2		;;CONTAINS # OF FILLER CHARACTERS REQUIRED
$FILLC:	.BYTE	12		;;INSERT FILL CHARS. AFTER A .LINE FEED"
$TPFLG:	.BYTE	0		;"TERMINAL AVAILABLE" FLAG (BIT<07>=0=YES)
$REGAD:	.WORD	0		;;CONTAINS THE ADDRESS FROM
				;;WHICH  ($REGO) WAS OBTAINED
$REGO:	.WORD	0		;;CONTAINS (($REGAD)+0)
$REG1:	.WORD	0		;;CONTAINS (($REGAD)+2)
$REG2:	.WORD	0		;;CONTAINS (($REGAD)+4)
$REG3:	.WORD	0		;;CONTAINS (($REGAD)+6)
$REG4:	.WORD	0		;;CONTAINS (($REGAD)+10)	
$REG5:	.WORD	0		;;CONTAINS (($REGAD)+12)	
$TMP0:	.WORD	0		;;USER DEFINED 
$TMP1:	.WORD	0		;;USER DEFINED 
$TMP2:	.WORD	0		;;USER DEFINED 
$TMP3:	.WORD	0		;;USER DEFINED 
$TMP4:	.WORD	0		;;USER DEFINED 
$TMP5:	.WORD	0		;;USER DEFINED 
$TIMES:	0			;;MAX. NUMBER OF ITERATIONS
$ESCAPE:0			;;ESCAPE ON ERROR ADDRESS
$BELL:	.ASCIZ	<207><377><377>	;;CODE FOR BELL 
$QUES:	.ASCII	/?/		;;QUESTION MARK
$CRLF:	.ASCII	<15>		;;CARRIAGE RETURN
$LF:	.ASCIZ	<12>		;;LINE	FEED	

;;***************************************************************	
.SBTTL	APT MAILBOX-ETABLE	
	
;;***************************************************************	
.EVEN	
$MAIL:			;;APT MAILBOX	
$MSGTY:	.WORD	AMSGTY	;;MESSAGE TYPE CODE	
$FATAL:	.WORD	AFATAL	;;FATAL ERROR NUMBER	
$TESTN:	.WORD	ATESTN	;;TEST NUMBER	
$PASS:	.WORD	APASS	;;PASS COUNT	
$DEVCT:	.WORD	ADEVCT	;;DEVICE COUNT	
$UNIT:	.WORD	AUNIT	;;I/O UNIT NUMBER	
$MSGAD:	.WORD	AMSGAD	;;MESSAGE ADDRESS	
$MSGLG:	.WORD	AMSGLG	;;MESSAGE LENGTH	
$ETABLE:		;;APT ENVIRONMENT TABLE	
$ENV:	.BYTE	AENV	;;ENVIRONMENT BYTE	
$ENVM:	.BYTE	AENVM	;;ENVIRONMENT MODE BITS	
$SWREG:	.WORD	ASWREG	;;APT SWITCH REGISTER	
$USWR:	.WORD	AUSWR	;;USER SWITCHES	
$CPUOP:	.WORD	ACPUOP	;;CPU TYPE,OPTIONS	
;*			BITS 15-11=CPU TYPE	
;*				11/04=01,11/05=02,11/20=03,11/40=04,11/45=05	
;*				11/70=06,PDQ=07,Q=10	
;*			BIT	10=REAL TIME CLOCK	
;*			BIT	 9=FLOATING POINT PROCESSOR	
;*			BIT	 8=MEMORY MANAGEMENT	
$MAMS1:	.BYTE	AMAMS1	;;HIGH ADDRESS,M.S. BYTE	
$MTYP1:	.BYTE	AMTYP1	;;MEM. TYPE,BLK#1	
;*			MEM.TYPE BYTE  --  (HIGH BYTE)	
;*				900 NSEC CORE=001	
;*				300 NSEC BIPOLAR=002	
;*				500 NSEC MOS=003	
$MADR1:	.WORD	AMADR1	;;HIGH ADDRESS,BLK#1	
;*			MEM.LAST ADDR.=3 BYTES,THIS WORD AND LOW OF "TYPE" ABOVE
$MAMS2:	.BYTE	AMAMS2	;;HIGH ADDRESS,M.S. BYTE	
$MTIP2:	.BYTE	AMTYP2	;;MEM.TYPE,BLK#2	
$MADR2:	.WORD	AMADR2	;;MEM.LAST ADDRESS.BLK#2	
$MAMS3:	.BYTE	AMAMS3	;;HIGH ADDRESS,M.S.BYTE	
$MTYP3:	.BYTE	AMTYP3	;;MEM.TYPE.BLK#3	
$MADR3:	.WORD	AMADR3	;;MEM.LAST ADDRESS,BLK#3	
$MAMS4:	.BYTE	AMAM54	;;HIGH ADDRESS,M.S.BYTE	
$MTYP4:	.BYTE	AMTYP4	;;MEM.TYPE,BLKM4	
$MADR4:	.WORD	AMADR4	;;MEM.LAST ADDRESS,BLK#4	
$VECT1:	.WORD	AVECTI	;;INTERRUPT VECTOR#1,BUS PRIORITY#1	
$VECT2:	.WORD	AVECT2	;;INTERRUPT VECTOR#2BUS PRIORITY#2	
$BASE:	.WORD	ABASE	;;BASE ADDRESS OF EQUIPMENT UNDER TEST	
$DEVM:	.WORD	ADEVM	;;DEVICE MAP	
$CDW1:	.WORD	ACDW1	;;CONTROLLER DESCRIPTION WORD#1	
$CDW2:	.WORD	ACDW2	;;CONTROLLER DESCRIPTION WORD#2	
$DDW0:	.WORD	ADDWO	;;DEVICE DESCRIPTOR WORD#0	
$DDW1:	.WORD	ADDW1	;;DEVICE DESCRIPTOR WORD#1	
$DDW2:	.WORD	ADDW2	;;DEVICE DESCRIPTOR WORD#2	
$DDW3:	.WORD	ADDW3	;;DEVICE DESCRIPTOR WORD#3	
$DDW4:	.WORD	ADDW4	;;DEVICE DESCRIPTOR WORD#4	
$DDW5:	.WORD	ADDW5	;;DEVICE DESCRIPTOR WORD#5	
$DDW6:	.WORD	ADDW6	;;DEVICE DESCRIPTOR WORD#6	
$DDW7:	.WORD	ADOW7	;;DEVICE DESCRIPTOR WORD#7	
$DDW8:	.WORD	ADDW8	;;DEVICE DESCRIPTOR WORD#8	
$DDW9:	.WORD	ADDW9	;;DEVICE DESCRIPTOR WORD#9	
$DDW10:	.WORD	ADDWI0	;;DEVICE DESCRIPTOR WORD#10	
$DDWII:	.WORD	ADDWI1	;;DEVICE DESCRIPTOR WORD#11	
$DDW12:	.WORD	ADDW12	;;DEVICE DESCRIPTOR WORD#12	
$DDW13:	.WORD	ADDW13	;;DEVICE DESCRIPTOR WORD#13	
$DDW14:	.WORD	ADDW14	;;DEVICE DESCRIPTOR WORD#14	
$DDW15:	.WORD	ADDW15	;;DEVICE DESCRIPTOR WORD#15	
		
		
$ETEND:		
		
		
TESTNO:	.WORD	0		;HOLDS TEST NUMBER FOR TYPEOUTS
WASR6:	.WORD	0		;USED TO STORE THE STACK POINTER AFTER A TRAP
TRAPPC:	.WORD	0		;USED TO STORE THE PC OF A TRAP OR ABORT
TRAPPS:	.WORD	0		;USED TO STORE THE PS OF A TRAP OR ABORT
CORSR0:	.WORD	0	;+USED TO STORE THE CORRECT SR0
CORSR2:	.WORD	0		;+USED TO STORE THE CORRECT SR2
WASSR0:	.WORD	0		;USED TO STORE CONTENTS OF SR0
WASSR2:	.WORD	0		;USED TO STORE CONTENTS OR SR2
TBITPS:	.WORD	0		;SAVES THE PSW THAT MAY HAVE ITS T-BIT ON
ANDADR:	.WORD	0		;HOLDS RESULT OF ADDRESSES BEING AND-ED
ORADR:	.WORD	0		;HOLDS RESULT OF ADDRESSES BEING OR-ED
TONUM:	.WORD	0		;HOLDS NUMBER OF TIME-OUTS
VIRT1:	.WORD	0		;HOLDS VIRTUAL ADDRESS TO BE CONVERTED
VIRT2:	.WORD	0		;  "         "       "
PBALO:	.WORD	0		;HOLDS BITS <15:00> OF PHYSICAL ADDRESS
PBAHI:	.WORD	0		;HOLDS BITS <17:16> OF PHYSICAL ADDRESS

.SBTTL	ERROR POINTER TABLE		
;*THIS TABLE CONTAINS THE INFORMATION FOR EACH ERROR THAT CAN OCCUR.
;*THE INFORMATION IS OBTAINED BY USING THE INDEX NUMBER FOUND IN		
;*LOCATION SITEMB. THIS NUMBER INDICATES WHICH ITEM IN THE TABLE IS PERTINENT.
;*NOTE1:	IF SITEMB IS 0 THE ONLY PERTINENT DATA IS (SERPPC).		
;*NOTE2:	EACH ITEM IN THE TABLE CONTAINS 4 POINTERS EXPLAINED AS FOLLOWS;
		
;*	EM	;;POINTS TO THE ERROR MESSAGE
;*	DH	;;POINTS TO THE DATA HEADER
;*	DT	;;POINTS TO THE DATA
;*	DF	;;POINTS TO THE DATA FORMAT

$ERRTB:

;*ITEM 1
	EMI		;UNEXPECTED CPU TRAP TO LOC. 004
	DH1		;OLD PC	OLD PSW R6 WAS	TESTNO	ERRORPC
	DTI		;TRAPPC,TRAPPS,WASR6,TESTNO,SERPPC,0
	DF1		;0,0,0.0,0
		
;*ITEM 2		
	EM2		;UNEXPECTED MEM. MGMT. TRAP TO LOC. 250
	DH2		;OLD PC	OLD PSW R6 WAS	SR0	5R2	TESTNO	ERRORPC
	DT2		;TRAPPC,TRAPPS, WASR6, WASSR0, WASSR2, TESTNO. $ERRPC,
	DF2		;0,0,0,0,0,0,0
		
;*ITEM 3		
	EM3		;PRIORITY BITS SET WRONG IN PSW
	DH3		;WROTE	READ	TESTNO	ERRORPC
	DT3		;$REG0,$REG1,TESTNO,$ERRPC.0
	DF3		;0,0,0,0
		
;*ITEM 4		
	EM4		;MODE BITS SET WRONG IN PSW
	DH3		;WROTE	READ	TESTNO	ERRORPC
	DT3		;$REG0,$REG1,TESTNO,SERRPC.0
	DF3		;0,0,0,0
		
;*ITEM 5		
	EM5		;DUAL ADDRESSING BETWEEN HMO BYTES OF PSW
	DH3		;WROTE	READ	TESTNO	ERRORPC
	DT3		;$REG0,$REG1,TESTNO,SERRPC,0
	DF3		;0,0.0,0
		
;*ITEM 6		
	EM6		;KERNEL R6 CHANGED BY WRITING USER 116
	DH3		;WROTE	READ	TESTNO	ERRORPC
	DT3		;$REG0,$REG1,TESTNO,SERRPC,0
	DF3		;0,0,0,0
		
;*ITEM 7		
	EM7		;A MEMORY MGMT. REG. TIMED OUT
	DH7		;ADDRESS TESTNO	ERRORPC
	OT7		;$REG0,TESTNO,SERRPC,0
	DF7		;0,0,0

;*ITEM 10	
	EM10		;SUMMARY OF MEM. MGMT. REG. TIMEOUTS
	DH10		;REGISTER?ADDRS	NUM. OF
			;AND?ED	OR?ED	TIMOUTS TESTNO ERRORPC
	DT10		;ANDADR,ORADR,TONUM.TESTNO,SERRPC,0
	DF10		;0,0,1,0,0
	
;*IIEM	11	
	EM11 		;MEM. MGMT. REG. WOULD NOT CLEAR
	DH11		;REGISTR READ    READ?(BINARY)
			;ADDRESS (OCTAL) 5432109876543210  TESTNO  ERRORPC
	DT11		;$REG0,$REG1,$REG1,TESTNO,SERRPC,0
	DFII		;0,0,2,0,0
	
;*ITEM 12	
	EM12		;MEM. MGMT. REG. BITS NOT SET CORRECTLY
	DH12		;REGISTR WROTE	 READ	 READ
       			;ADDRESS (OCTAL) (OCTAL) (BINARY) TESTNO ERRORPC
	DT12		;$REG0,$REG1,$REG2,$REG2,TESTNO,SERRPC.0
	DF12		;0,0,0,2,0.0	
	
;*ITEM 13	
	EMI3		;SR0 EFFECTED BY WRITE TO PSW
	DH13		;READ	TESTNO	ERRORPC
	DT13 		;$REG0,TESTNO,SERRPC,0
	DFI3		;0,0,0
	
;*ITEM 14	
	EM14		;SRI DID NOT READ ALL ZEROS
	DH13		;READ	TESTNO	ERRORPC
	DT13		;$REG0,TESTNO,SERRPC,0
	OFI3		;0,0,0
	
;*ITEM 15	
	EM15		;DUAL ADDRESSING BETWEEN BYTES OF PAR OR PDR
	DH12		;REGISTER WROTE	 READ	 READ
			;ADDRESS (OCTAL) (OCTAL) (BINARY) TESTNO ERRORPC
	DT12		;$REG0,$REG1,$REG2,$REG2,TESTNO,SERRPC,0
	DF12		;0,0,0,2,0,0
	
;*ITEM 16	
	EM16		;DUAL ADDRESSING BETWEEN PAR?PDR'S
	DH16		;PAR?PDR PAR?PDR
			;CLEARED EFFECTD EXPECTD RECEIVD TESTNO ERRORPC
	DT16 		;$REG0,$REG1,$REG5,$REG2,TESTNO,SERRPC,0
	DF16		;0,0,0,0,0.0
	
;*ITEM 17	
	EM17		;PHYS. ADDR. FORMED READ WRONG IN MAINT. MODE
	DH17		;PHYSICAL VIRTUAL
			;ADDRESS ADDRESS KIPAR4 TESTNO	ERRORPC
	DT17		;PBALO,VIRTI,$REG4,TESTNO.SERRPC,0
	DF17		;3,0,0,0,0

;*ITEM 20
	EM20		;PHYS. ADDR. FORMED READ WRONG IN RELOCATE MODE
	DH20		;PHYSICL PAR 4	PAR 5
			;ADDRESS VBA	VBA	PAR 4	PAR 5	PSW	TESTNO
	DT20		;PBALO,VIRT1,VIRT2,$REG4,$REG5,STMPO,TESTNO,$ERRPC,0
	DF20		;3,0,0,0.0,0,0,0

;*ITEM 21
	EM21		;W-BIT DID NOT GET SET IN PDR
	DH21		;PDR	VIRTUAL
			;TESTED	ADDRESS TESTND	ERRORPC
	DT21		;$REG5,$REG3,TESTNO,$ERRPC,0
	DF21  	    	;0,0,0,0

;*ITEM 22
	EM22		;W-BIT SET IN MORE THAN ONE PDR
	DH22		;PDR IN	PDR	VIRTUAL
			;ERROR	TESTED	ADDRESS TESTNO	ERRORPC
	DT22		;$REG0,$REG5,$REG3,TESTNO,$ERRPC,0
	DF22		;0,0,0,0,0
		
;*ITEM 23
	EM23		;W-BIT NOT CLEARED BY WRITING TO PDR
	DH23		;PDR	TESTNO	ERRORPC
	DT23		;$REG5,TESTNO,$ERRPC,0
	DF23		;0,0,0

;*ITEM 24
	EM24		;WRITING SR0 SET W-BIT IN KIPDR7
	DH24		;PDR WAS EXPECTD TESTND  ERRORPC
	DT24		;$REG2,$REG1,TESTNO,$ERRPC,0
	DF24		;0,0,0,0

;*ITEM 25
	EM25		;W-BIT GOT SET DURING ODD ADDR. ABORT
	DH24		;PDR WAS EXPECTD TESTNO  ERRORPC
	DT24		;$REG2,$REG1,TESTNO,SERRPC,0
	DF24		;0,0,0,0

;*ITEM 26
	EM26		;MEMORY MGMT. ACCESS ABORT DID NOT OCCUR 
	DH26		;PDR 4	PSW	TESTND	ERRORPC
	DT26		;$REG2,$TMPO,TESTNO,$ERRPC,0
	DF24		;0,0,0,0

;*ITEM 27		
	EM27		;ACCESS ERROR DID NOT ABORT INSTRUCTION
	DH26		;PDR 4	PSW	TESTNO	ERRORPC
	DT26		;$REG2,$TMP0,TESTNO,$ERRPC,0
	DF24		;0,0,0,0

;*ITEM 30		
	EM30		;SR0 DID NOT REPORT ACCESS ERROR CORRECTLY
	DH30		;SR0 WAS EXPECTD PDR 4   PSW	 TESTNO
	DT30		;WASSR0,$REG3,$REG2,$TMP0,TESTNO,$ERRPC,0
	DF30		;0,0,0,0,0,0

;*ITEM 31	
	EM31		;SR2 DID NOT LOCKUP CORRECT VIRTUAL ADDR.
	DH31		;SR2 WAS EXPECTD PDR 4	PSW	TESTNO ERRORPC
	DT31		;WASSR2,$REG4,6REG2,STMPO,TESTNO,$ERRPC,0
	DF30		;0,0,0,0,0,0

;*ITEM 32	
	EM32		;PAGE LGTH. ABORT OCCURRED WHEN IT SHOULDN'T HAVE
	DH32		;V.B.A.	KIPDR4	SR0 WAS SR2 WAS TESTNO	ERRORPC
	DT32		;$REG0,$REG4,WASSR0,WASSR2,TESTNO,$ERRPC,0
	DF30		;0,0,0,0,0,0
	
;*ITEM 33	
	EM33		;PAGE LGTH. ABORT DID NOT OCCUR WHEN IT SHOULD HAVE
	DH33		;V.B.A.	KIPDR4	TESTNO	ERRORPC
	DT33		;$REG0,$REG4,TESTNO,$ERRPC,0
	0F24		;0,0,0,0
	
;*ITEM 34	
	EM34		;SR0 DID NOT REPORT PAGE LGTH. ABORT CORRECTLY
	DH34		;V.B.A.	KIPDR4	SR0 WAS EXPECTD TESTNO	ERRORPC
	DT34		;$REG0,$REG4,WASSR0,$REG2,TESTNO,SERRPC,0
	DF30		;0,0,0,0,0,0

;*ITEM 35	
	EM31		;SR2 DID NOT LOCKUP CORRECT VIRUAL ADDR.
	DH35		;V.B.A.	 KIPDR4  SR2 WAS EXPECTD TESTNO	ERRORPC
	DT35		;$REG0,$REG4,WASSR2,$REG3,TESTNO,$ERRPC,0
	DF30		;0,0,0,0,0.0
	
;*ITEM 36	
	EM31		;SR2 DID NOT LOCKUP CORRECT VIRUAL ADDR.
	DH36		;SR2 WAS EXPECTD TESTNO  ERRORPC
	DT36		;WASSR2,$REG1,TESTNO,SERRPC,0
	DF24		;0,0,0,0
	
;*ITEM 37	
	EM37		;SR0 OR SR2 CHANGED BY A SECOND ABORT
	DH37		;FIRST ABORT     SECOND ABORT
			;SR0 WAS SR2 WAS SR0 WAS SR2 WAS TESTNO  ERRORPC
	DT37		;STMP0,$TMP2,WASSR0,WASSR2,TESTNO,$ERRPC,0
	DF30		;0,0,0,0,0,0
	
;*ITEM 40	
	EM40		;SR0 OR SR2 WAS NOT "RESET" BY A RESET
	DH40		;SR0 WAS SR2 WAS TESTNO  ERRORPC
	DT40		;WASSR0,WASSR2,TESTNO,$ERRPC,0
	DF24		;0,0,0,0
	
;*ITEM 41	
	EM41		;SR2 NOT TRACKING CORRECTLY
	DH36		;SR2 WAS EXPECTD TESTNO	ERROPC
	DT36		;WASSR2,$REG1,TESTNO,$ERRPC,0
	DF24		;0,0,0,0
	
;*ITEM 42	
	EM42		;DID NOT TRAP THRU KERNEL SPACE
	DH42		;PSW WAS R6 WAS	TESTNO	ERRORPC
	DT42		;$REG1,$REG2,TESTNO,$ERRPC,0
	DF24		;0,0,0,0
	
;*ITEM 43	
	EM43		;KT ERROR SERVICED ON ODD ADDR. ERROR
	DH23		;PDR	TESTNO	ERRORPC
	DT23		;$REG5,TESTNO,$ERRPC,0
	DF23		;0,0,0
	
;*ITEM 44	
	EM44		;SR0 OR SR2 CHANGED BY ODD ADDR. ERROR
	DH44		;EXPECTED	RECEIVED
			;SR0	SR2	SR0 WAS SR2 WAS TESTNO	ERRORPC
	DT44		;$REG0,$REG1,WASSR0,WASSR2,TESTNO,$ERRPC,0
	DF30		;0,0,0,0,0,0
	
;*ITEM 45	
	EM45		;ERROR DURING "DOUBLE ERROR" (KT & ODD ADDR.)
	DH45		;EXPECTED:
			;PSW	 PC	  SR0	  SR2
			;170017  (3$+4)  020147  (3$)
			;RECEIVED
			;PSW	PC        SR0     SR2	TESTNO	ERRORPC
	DT45		;$REG1,$REG3,WASSR0,WASSR2,TESTNO,$ERRPC,0
	DF30		;0,0,0,0,0,0
	
;*ITEM 46	
	EM46		;MFPI INSTRUCTION PUSHED WRONG DATA
	DH46		;DATA    DATA
			;EXPECTD RECEIVD TESTNO  ERRORPC
	DT46		;$REG0,$REG1,TESTNO,$ERRPC,0
	DF46		;0,0,0,0
	
;*ITEM 47	
	EM47		;MTPI INSTRUCTION LOADED WRONG DATA
	DH46		;DATA    DATA
			;EXPECTD RECEIVD TESTNO  ERRORPC
	DT46		;$REG0,$REG1,TESTNO,$ERRPC,0
	DF46		;0,0,0,0
	
;*ITEM 50	
	EM50		;STACK NOT PUSHED BY MFPI-MTPI
	DHSO		;TESTNO	ERRORPC
	DT50		;TESTNO,SERRPC,0
	DF50		;0,0
	
;*ITEM 51	
	EM51		;KERNEL PAGE ACCESSED INSTEAD OF USER: MFPI-MTPI
	DH51		;SR0 WAS SR2 WAS TESTNO  ERRORPC
	DT51		;WASSR0,WASSR2,TESTNO,$ERRPC,0
	DT51		;0,0,0,0
	
;*ITEM 52	
	EM52		;WRONG PDR'S REFERENCED WHILE IN RELOCATE MODE
	DH52		;PHYSICL PAR 4
			;ADDRESS V.B.A.  PAR 4  SR0 WAS SR2 WAS PSW	TESTNO
	DT52		;PBALO,VIRT1,$REG4,WASSR0,WASSR2,$TMP0,TESTNO,SERRPC,0
	DF52		;3,0,0,0,0,0,0,0
;*ITEM 53	
	EM53		;MFPD INSTRUCTION PUSHED WRONG DATA
	DH46		;DATA    DATA
			;EXPECTD RECEIVD TESTNO	ERRORPC
	DT46		;$REG0,$REG1,TESTNO,$ERRPC,0
	DF46		;0,0,0,0
	
;*ITEM 54	
	EM54		;STACK NOT PUSHED BY MFPD-MTPD
	DHSO		;TESTNO  ERRORPC
	DT50		;TESTNO,$ERRPC,0
	DF50		;0,0
	
;*ITEM 55	
	EM55		;PAR OR PDR WAS CHANGED BY A RESET
	DH11		;REGISTR READ    READ-(BINARY)
			;ADDRESS (OCTAL) 5432109876543210  TESTNO  ERRORPC
	DT11		;$REG0,$REG1,5REG1,TESTNO,$ERRPC,0
	DF11		;0,0,2,0,0
	
;*ITEM 56	
	EM56		;ILLEGAL MODE 01 NOT ABORTED
	DHSO		;TESTNO  ERRORPC
	DT50		;TESTNO,$ERRPC,0
	DF50		;0,0
	
;*ITEM 57	
	EM57		;SR0 DID NOT REPORT ILLEGAL MODE 01 CORRECTLY
	DH57		;SR0 WAS EXPECTD TESTNO  ERRORPC
	DT57		;WASSR0,$REG1,TESTNO,$ERRPC,0
	DF57		;0,0,0,0
	
;*ITEM 60	
	EM60		;PSW CHANGED BY AN RTI IN USER MODE
	DH60		;PSW WAS EXPECTD TESTNO	ERRORPC
	DT60		;$REG1,$REG2,TESTNO,$ERRPC,0
	DF60		;0,0,0,0
	
;*ITEM 61	
	EM61		;MAINT MODE (SR0<8>) NOT DISABLED BY A RESET
	DH5O		;TESTNO  ERRORPC
	DT50		;TESTNO,$ERRPC,O
	DF50		;0,0
	
;*ITEM 62	
	EM62		;DATA INCORRECT AFTER A MAINT. MODE WRITE
	DH3		;WROTE   READ    TESTNO  ERRORPC
	DT3		;$REG0,$REG1,TESTNO,$ERRPC,0
	DF3		;0,0,0,0

;*ITEM 63
	EM63		;SOURCE RELOCATED IN MAINT. MODE
	DH2		;OLD PC  OLD P5W R6 WAS	SR0	SR2	TESTNO	ERRORPC
	DT2		;TRAPPC,TRAPPS,WASR6,WASSR0,WASSR2,TESTNO,$ERRPC,0
	DF2		;0,0,0,0,0,0,0
		
;*ITEM 64	
	EM31		;SR2 DIDNOT LOCKUP CORRECT VIRTUAL ADDR.
	DH36		;SR2 WAS EXPECTD TESTNO	ERRORPC
	DT64		;WASSR2,$REG4,TESTNO,$ERRPC,O
	DF24		;0,0,0,0
		
;*ITEM 65	
	EM64		;+NON RESIDENT ABORT DID NOT OCCUR
	DH61		;+SR0       SR2     TESTNO   ERRORPC
	DT65		;+WASSR0,WASSR2,TESTNO,$ERRORPC
	DF61		;+0,0,0,0
		
;*ITEM 66
	EM65		;+ERROR FLAG FOR KR ABORT DID NOT SET
	DH61		;+SR0       SR2     TESTNO  ERRORPC
	DT65		;+WASSR0,WASSR2,TESTNO,$ERRPC
	DF61		;+0,0,0,0
		
;*ITEM 67
	EM66		;+SR2 DID NOT FREEZE THE VIRTUAL ADRS OF ABORT
	DH61		;+SR0       SR2	TESTNO	ERRORPC
	0165		;+WASSR0,WASSR2,TESTNO,$ERRPC
	DF61		;+0,0,0,0
		
;*ITEM 70	
	EM67		;+2ND NON RESIDENT ABORT DID NOT OCCUR
	DH61		;+SR0      SR2  TESTNO  ERRORPC
	DT65		;+WASSR0,WASSR2,TESTNO,$ERRPC
	DF61		;+0,0,0,0
		
;*ITEM 71	
	EM70		;+2ND NR ABORT CHANGED SR2
	DH62		;+SR2 EXPT SR2 RECD TESTNO ERRORPC
	0166		;+CORSR0,WASSR2,TESTNO,$ERRPC
	DF61		;+0,0,0,0
		
;*ITEM 72	
	EM71		;+SR0 WAS NOT CLEARED BY INIT
	DH63		;+SR0 EXPT SR0 RECD TESTNO ERRORPC
	DT67		;+CORSR0,WASSR0,TESTNO,ERRORPC
	DF61		;+0,0,0,0

.SBTTL	*****	TRAP HANDLING ROUTINES	*****		

.SBTTL	CPU TRAP HANDLER ROUTINE		
;;***************************************************************		
;*		
;*	THIS SUBROUTINE WILL HANDLE ALL CPU TRAPS AND ABORTS THRU		
;*	"ERRVEC" (LOC. 004). IF THIS SUBROUTINE IS ENTERED BY A
;*	SECOND TRAP BEFORE THE FIRST HAS BEEN SERVICED. A HALT IS		
;*	EXECUTED.		
;*		
;;***************************************************************		
TIMERR:	INC	(PC)+		;MAKE FLAG ZERO IF FIRST TIME THRU		
TIMFLG:	.WORD	-1		;NEGATIVE ONE FOR "HAVE ENTERED" FLAG
	BEQ	1$		;BRANCH	IF FIRST TIME IN		
	HALT			;STOP.	- I'VE ENTERED THIS ROUTINE		
				;A SECOND TIME BEFORE I	FINISHED		
				;REPORTING THE FIRST ERROR.	THE		
				;SECOND ENTRY ADDRESS SHOULD BE ON		
				;THE KERNEL STACK.		
1$:	MOV	(KSP)+,TRAPPC	;SAVE PC+2 AT TIME OF ABORT		
	MOV	(KSP)+,TRAPPS	;SAVE PS AT TIME OF ABORT		
	MOV	KSP,WASR6	;SAVE STACK POINTER VALUE		
	ERROR	1		;UNEXPECTED TRAP OR ABORT TO LOC. 4		
	MOV	#-1,TIMFLG	;MAKE FLAG NEGATIVE ONE FOR NEXT TIME		
	MOV	TRAPPS,-(KSP)	;PUT PC & PS OF TRAP ON STACK		
	MOV	TRAPPC,-(KSP)		
	RTT			;RETURN FROM INTERRUPT OR ABORT		


.SBTTL	MEMORY MANAGEMENT TRAP HANDLER ROUTINE		
;;***************************************************************		
;*		
;*	THIS SUBROUTINE WILL HANDLE ALL UNEXPECTED MEMORY MANAGEMENT		
;*	TRAPS AND ABORTS THRU "MMVEC" (LOC. 250). IF THIS SUBROUTINE IS 
;*	ENTERED BY A SECOND TRAP BEFORE THE FIRST HAS BEEN SERVICED, A	
;*	HALT IS EXECUTED.		
;*		
;;***************************************************************		
MGMERR:	INC	(PC)+		;MAKE FLAG ZERO IF FIRST TIME THRU		
MGMFLG:	.WORD	-1		;NEGATIVE ONE FOR "HAVE ENTERED" FLAG 
	BEQ	1$		;BRANCH IF FIRST TIME IN		
	HALT			;STOP,	- I'VE ENTERED THIS ROUTINE		
				;A SECOND TIME BEFORE I	FINISHED		
				;REPORTING THE FIRST ERROR.	THE		
				;SECOND ENTRY ADDRESS SHOULD BE ON		
				;THE KERNEL STACK.		
1$:	MOV	(KSP)+,TRAPPC	;SAVE PC+2 AT TIME OF ABORT		
	MOV	(KSP)+,TRAPPS	;SAVE PS AT TIME OF ABORT		
	MOV	KSP,WASR6	;SAVE STACK POINTER VALUE		
	MOV	SR0,WASSR0	;SAVE CONTENTS OF KT STATUS REG. 0		
	MOV	SR2,WASSR2	;SAVE CONTENTS OF KT STATUS REG. 2		
	BIC	#160000,SR0	;CLEAR ERROR BITS IN STATUS REG 0		
	ERROR	2		;UNEXPECTED TRAP OR ABORT TO LOC. 250		
	MOV	#-1,MGMFLG	;MAKE FLAG NEGATIVE ONE FOR NEXT TIME		
	MOV	TRAPPS,-(KSP)	;PUT PC & PS OF TRAP ON STACK		
	MOV	TRAPPC,-(KSP)		
	RTT			;RETURN FROM INTERRUPT OR ABORT.

	.SBTTL					
	.SBTTL	*****   STARTING POINT OF TEST  ***** 
	.SBTTL	*****   STARTING ADDRESS OF 200 ***** 
	.=20000

START:
.SBTTL	INITIALIZE THE COMMON TAGS
;;CLEAR THE COMMON TAGS (SCMTAG) AREA
	MOV	#$CMTAG,R6	;;FIRST LOCATION TO BE CLEARED
	CLR	(R6)+		;;CLEAR MEMORY LOCATION
	CMP	#SWR,R6 	;;DONE?
	BNE	.-6		;;LOOP BACK IF NO
	MOV	#STACK,SP	;;SETUP THE STACK POINTER
;;INITIALIZE A FEW VECTORS
	MOV	#$SCOPE,@#IOTVEC ;;IOT VECTOR FOR SCOPE ROUTINE
	MOV	#340,@#I0TVEC+2	;;LEVEL 7
	MOV	#$ERROR,@#EMTVEC ;;EMT VECTOR FOR ERROR ROUTINE
	MOV	#340,@#EMTVEC+2 ;;LEVEL 7
	MOV	#$TRAP,@#TRAPVEC ;;TRAP VECTOR FOR TRAP CALLS
	MOV	#340,@#TRAPVEC+2;LEVEL 7
	MOV	#$PWRDN,@#PWRVEC ;;POWER FAILURE VECTOR
	MOV	#340,@#PWRVEC+2	;;LEVEL 7
	MOV	$ENDCT,SEOPCT	;;SETUP END-OF-PROGRAM COUNTER
	CLR	$TIMES		;;INITIALIZE NUMBER OF ITERATIONS
	CLR	$ESCAPE		;;CLEAR THE ESCAPE ON ERROR ADDRESS
	MOVB	#1,$ERMAX	;;ALLOW ONE ERROR PER TEST
;;INITIALIZE THE "T-BIT" TRAP VECTOR. THEN LOAD LOCATION "SRTRN". IN
;;THE "END-OF-PASS" (SEOP) ROUTINE, WITH A "RIP OR "RTT".
	MOV	#$RTRN,@#TBITVEC ;;SET "T" BIT VECTOR TO SRTRN
	MOV	#340,@#TBITVEC+2 ;;LEVEL 7
	MOV	#RTI,$RTRN	;;SET SRTRN TO A RTI
	MOV	#65$,@#RESVEC	;;TRY TO DO A RTT
	CLR	-(SP)		;;DUMMY PS
	MOV	#64$,-(SP)	;;AND PC
	RTT			;;TRY THE RTT
64$:	MOV	#RTT,$RTRN	;;RTT IS LEGAL--SET SRTRN TO A RTT
	BR	66$
65$:	ADD	#10,SP	;;RTT ILLEGAL--CLEAN OFF THE STACK
66$:	MOV	#RESVEC+2,@#RESVEC ;;RESTORE TRAP CATCHER
	CLR	$TBIT		;;CLEAR "T" BM SWITCH
	MOV	#.,$LPADR	;;INITIALIZE THE LOOP ADDRESS FOR SCOPE
	MOV	#.,$LPERR	;;SETUP THE ERROR LOOP ADDRESS
;;SIZE FOR A HARDWARE SWITCH REGISTER.	IF NOT FOUND OR IT IS
;;EQUAL TO A "-1", SETUP FOR A SOFTWARE SWITCH REGISTER.
	MOV	@#ERRVEC,-(SP)	;;SAVE ERROR VECTOR
	MOV	#67$,@#ERRVEC	;;SET UP ERROR VECTOR
	MOV	#DSWR,SWR	;;SETUP FOR A HARDWARE SWICH REGISTER
	MOV	#DDISP,DISPLAY	;;AND A HARDWARE DISPLAY REGISTER
	CMP	#-1,@SWR	;;TRY TO REFERENCE HARDWARE SWR
	BNE	69$		;;BRANCH IF ND TIMEOUT TRAP OCCURRED
				;;AND THE HARDWARE SWR IS NOT ? -1
	BR	68$		;;BRANCH IF NO TIMEOUT
67$:	MOV	#68$,(SP)	;;SET UP FOR TRAP RETURN
	RTI
68$:	MOV	#SWREG,SWR	;;POINT TO SOFTWARE SWR
	MOV	#DISRREG,DISPLAY
69$:	MOV	(SP)+,@#ERRVEC	;;RESTORE ERROR VECTOR

	CLR	$PASS		;;CLEAR PASS COUNT	
	BITB	#APTSIZE,$ENVM	;;TEST USER SIZE UNDER APT	
	BEQ	70$		;;YES,USE NON-APT SWITCH	
	MOV	#$SWREG,SWR	;;NO.USE APT SWITCH REGISTER	
70$:	
.SBTTL TYPE PROGRAM NAME	
;;TYPE THE NAME OF THE PROGRAM IF FIRST PASS	
	INC	#-1		;;FIRST TAME?	
	BNE	71$		;;BRANCH IF NO	
	CMP	#$ENDAD,@#42	;;ACT-11?	
	BEQ	71$		;;BRANCH IF YES	
	TYPE	,72$		;;"TYPE ASCIZ STRING	
.SBTTL GET VALUE FOR SOFTWARE SWITCH REGISTER	
	TST	@#42		;;ARE WE RUNNING UNDER XXDP/ACT?	
	BNE	73$		;;BRANCH IF YES	
	CMPB	$ENV,#1		;;ARE WE RUNNING UNDER APT?	
	BEG	73$		;;BRANCH IF YES	
	CMP	SWR,#SWREG	;;SOFTWARE SWITCH REG SELECTED?	
	BNE	74$		;;BRANCH IF NO	
	GTSWR			;;GET SOFT-SWR SETTINGS	
	BR	74$	
73$:	MOVB	#1,$AUTOB	;;SET AUTO-MODE INDICATOR	
74$:	
	BR	71$	;;GET OVER THE ASCIZ	
;;72$: .ASCIZ <CRLF>#CFKTHBO 11/34 MEMORY MGMT. DIAG.#<CRLF>	
71$:	

LOOP:	
	MOV	#STACK,KSP	;INITIALIZE THE STACK POINTER	
	MOV	#TIMERR,ERRVEC	;LOAD CPU SERVICE ROUTINE INTO TRAP
	MOV	#340,ERRVEC+2	;SET NEW PS TO PRIORITY LEVEL 7-KERNEL	
	MOV	#MGMERR,MMVEC	;LOAD MEMORY MANAGENT ROUTINE INTO VECTOR	
	MOV	#340,MMVEC+2	;SET NEW PS TO PRIORITY LEVEL 7-KERNEL	
	MOV	#-1,R0		;PUT -1 INTO R0 TO INITIALIZE FLAGS
	MOV	R0,TIMFLG	;INITIALIZE CPU ERROR FLAG	
	MOV	R0,MGMFLG	;INITIALIZE MEMORY MANAGEMENT ERROR FLAG	
	MOV	#34,TBITPS	;INITIALIZE LOG THAT HOLDS T-BIT PSW	
	CLR	SR0		;BE SURE MEM. MGMT IS OFF TO START WITH	

;;***************************************************************
;*TEST 1	PSW PRIORITY BIT TEST
;*
;*	THIS TEST READS AND WRITES THE PROCESSOR STATUS WORD <7:5> "PRIORITY BITS"
;*	TO SEE THAT SOME OF THE BASIC "DATA PATH" LOGIC IS WORKING.
;*
;;****************************************************************
TST1:	SCOPE
1$:	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$
	CLR	R0		;INITIALIZE R0 WITH PRIORITY=0 DATA
2$:	CLR	R1		;PREPARE RI TO ACCEPT DATA READ
	MTPS	R0		;WRITE PRIORITY BITS IN THE P5W
	MFPS	R1		;READ BACK THE LOW BYTE OF PSW
	BIC	#177437,R1	;MASK OFF EVERYTHING EXCEPT PRIORITY BITS
	CMP	R0,R1		;WAS CORRECT PRIORITY SET IN THE PSW?
	BEG	3$		;BRANCH IF YES
	ERROR	3		;PRIORITY BITS SET WRONG IN PSW
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 2$" = 000770
3$:	ADD	#40,R0		;CHANGE DATA TO NEXT PRIORITY
	CMP	#400,R0		;HAVE PRIORITIES 0-7 ALL BEEN CHECKEBEQ
	BNE	2$		;BRANCH IF NO
	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$

;;****************************************************************
;*TEST 2	PSW MODE BIT TEST
;*	THIS TEST READS AND WRITES THE PROCESSOR STATUS WORD <15:12> "MODE BITS"
;*	TO FURTHER CHECK THE BASIC CPU DATA PATHS
;*
;;******************************************************************
TST2:	SCOPE
1$:	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$
	CLR	R0		;INITIALIZE R0 WITH MODE BITS = 0000
2$:	CLR	PSW		;INITIALIZE PSW
	BIS	R0,PSW		;BIT SET THE PSW MODE BITS WITH RO
	MOV	PSW,R1		;READ BACK THE CONTENTS OF THE PSW
	BIC	#007777,R1	;MASK OFF EVERYTHING EXCEPT THE MODE BITS
	CMP	R0,R1		;WERE THE MODE BITS SET CORRECTLY?
	BEQ	2$		;BRANCH IF YES
	CLR	PSW		;CLEAR PSW FOR ERROR REPORT
	ERROR	4		;MODE BITS SET WRONG IN PSW
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 2$" = 000763
3$:	ADD	#10000,R0	;CHANGE MODE BIT DATA
	BNE	2$		;BRANCH IF STILL MORE COMBINATR0NS
	MOV     #1$,$LPERR	;RESET LOOP ON ERROR POINTER TO IS
	CLR	PSW		;RESET PSW BEFORE LEAVING

;;**************************************************************
;*TEST 3	BYTE ADDRESSING TEST FOR PSW
;*
;*	THIS TEST WRITES THE HIGH AND LOW BYTES OF THE PROCESSOR STATUS WORD
;*	AND READS THEM BACK TO BE SURE THEY CAN BE WRITTEN INDEPENDENTLY.	
;*	THIS CHECKS THE PSW PORTION OF THE ADDRESS DETECTION LOGIC.	
;*	
;***************************************************************	
TST3:	SCOPE	
1$:	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$	
2$:	CLR	PSW		;CLEAR THE PSW	
	MOV	#360,R0		;PUT THE HIGH BYTE DATA INTO R0	
	MOVB	R0,PSW+1	;WRITE THE HIGH BYTE OF THE PSW	
	MOV	PSW,R1		;READ BACK THE ENTIRE PSW	
	BIC	#007437,R1	;MASK OFF THE T & CC BITS	
	SWAB	R0		;GET DATA WRITTEN IN HIGH BYTE OF RO	
	CMP	R0,R1		;WAS THE PSW WRITTEN TO CORRECTLY	
	BEG	3$		;BRANCH IF YES	
	CLR	PSW		;CLEAR PSW FOR ERROR REPORT	
	ERROR	5		;LOW BYTE EFFECTED BY WRITE TO HIGH BY1E OF PSW	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 2$" = 000760	
3$:	MOV	#4$,$LPERR	;SET LOOP ON ERROR POINTER TO 4$	
4$:	CLR	PSW		;CLEAR THE PSW	
	MOV	#340,R0		;PUT THE LOW BYTE DATA INTO RO	
	MOVB	R0,PSW		;WRITE THE LOW BYTE OF THE PSW	
	MOV	PSW,R1		;READ BACK THE ENTIRE PSW	
	BIC	#007437,R1	;MASK OFF THE T&CC BITS	
	CMP	R0,R1		;WAS PSW WRITTEN TO CORRECTLY	
	BEQ	5$		;BRANCH IF YES	
	CLR	PSW		;CLEAR PSW FOR ERROR REPORT	
	ERROR	5		;HIGH BYTE EFFECTED BY WRITE TO LOW BYTE OF PSW	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 25" = 000736	
5$:	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$	

;;***************************************************************	
;*TEST 4	TEST AND SETUP OF STACK POINTERS	
;*	
;*	THIS TEST SETS THE USER AND KERNEL STACK POINTERS FOR THE	
;*	REST OF THE PROGRAM AND MAKES SURE THEY ARE INDEPENDENT OF	
;*	EACH OTHER.	KERNEL R8 IS SET TO 1100, USER R6 IS SET TO 700. THEN	
;*	KERNEL R6 IS READ TO BE SURE ITS STILL 1100.	
;*	
;;***************************************************************	
TST4:	SCOPE	
	CLR	PSW		;GO TO KERNEL MODE	
	MOV	#KERSTK,KSP	;SET KERNEL STACK POINTER TO 1100	
	MOV	#140000,PSW	;GO TO USER MODE	
	MOV	#USESTK,USP	;SET USER STACK POINTER TO 700	
	CLR	PSW		;BACK TO KERNEL MODE	
	CMP	#KERSTK,KSP	;IS KERNEL R6 STILL 1100?	
	BEQ	TST5		;;BRANCH IF KERNEL R6 IS OKAY	
	MOV	#KERSTK,R0	;SAVE DATA WRITTEN FOR ERROR REPORT	
	MOV	KSP,R1		;SAVE DATA READ AFTER USER R6 WAS WRITTEN	
	ERROR	6		;KERNEL R6 CHANGED BY WRITING USER R8	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	


;;***************************************************************	
;*	
;*	THE NEXT FIVE (5) TESTS WILL TRY TO ADDRESS ALL OF THE	
;*	MEMORY MANAGEMENT REGISTERS (SR0,SR1,SR2,KERNEL & USER PAR/PDR'S).	
;*	EVERY TIME A REGISTER TIMES OUT	ITS ADDRESS WILL BE REPORTED.	
;*	AT THE END OF EACH TEST A SUMMARY OF THE ADDRESSES THAT TIMED	
;*	OUT DURING THAT TEST IS GIVEN.	THE RESULTS OF "AND?ING" AND "OR-ING"	
;*	THEIR ADDRESSES IS GIVEN TO SHOW WHICH ADDRESS LINES MAY BE	
;*	STUCK AT 0 OR 1. THE PAR/PDR ADDRESS AND KT MUX'S ARE THE	
;*	THINGS BEING CHECKED.	
;*	
;;*************************************************************	
	
	
;;*************************************************************	
;*TEST 5	SR0,SR1,SR2 TIMEOUT TEST	
;*	
;*	THIS TEST ADDRESSES THE MEMORY MANAGEMENT STATUS REGISTERS	
;*	0,1, AND 2. STATUS REG.	1 IS NOT USED BUT SHOULD STILL	
;*	RESPOND TO ITS UNIBUS ADDRESS.	DATA WILL BE WRITTEN OR READ	
;*	FROM THESE REGISTERS IN LATER TESTS, THIS TEST JUST CHECK	
;*	FOR A RESPONSE.	
;*	
;;*************************************************************	
TST5:	SCOPE	
	
1$:	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$	
	MOV	#55,@#4		;SET TIMEDUT VECTOR TO 5$	
	MOV	#SR0,R0		;LOAD R0 WITH ADDRESS OF FIRST REG.	
	MOV	#3,R1		;LOAD R1 WITH THE LOOP COUNT	
	MOV	#-1,ANDADR	;INITIALIZE "AND" OF ADDRS.	LOC.	
	CLR	ORADR		;INITIALIZE "OR" OF ADDRS.	LOC.	
	CLR	TONUM		;INITIALIZE "TIMEOUTS" COUNTER	
2$:	TST	(R0)		;TRY ADDRESSING A STATUS REGISTER	
				;IF IT TIMES OUT GO TO 5$	
3$:	ADD	#2,R0		;PUT NEXT ADDRESS IN RO	
	SOB	R1,2$		;LOOP BACK TO 2$ UNTIL ALL TESTED	
	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$	
	TST	TONUM		;DID ANY OF THE STATUS REG.S TIMEOUT7	
	BEG	4$		;BRANCH IF NO	
	ERROR	10		;SUMMARY OF STATUS REG.	TIMEOUTS	
4$:	MOV	#TIMERR,@#4	;RESTORE NORMAL CPU TRAP ROUTINE ADDRESS	
	BR	TST6		;;GO TO NEXT TEST	
	
5$:	ADD	#4,KSP		;CLEAN UP THE STACK	
	ERROR	7		;ONE OF THE STATUS REGS.	TIMED OUT	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 2$" = 000756	
	MOV	R0,R2		;LOAD THE ADDRESS THAT TIMED OUT INTO R2	
	BIS	R2,ORADR	;"OR"	IT WITH OTHER ADDRS.	THAT TIMED OUT	
	COM	R2		;"AND"	IT WITH OTHER ADDRS. THAT TIMED OUT	
	BIC	R2,ANDADR	
	INC	TONUM		;INCREMENT THE TIMEOUT COUNTER	
	BR	3$		;BRANCH BACK TO TEST THE NEXT ADDR.

;;***********************************************************
;*TEST 6	KERNEL PAR'S TIMEOUT TEST
;*
;*	THIS TEST ADDRESSES THE EIGHT (B) KERNEL PAGE ADDRESS
;*	REGISTERS (KIPAR0-KIPAR7) AND CHECKS THAT SOMETHING
;*	RESPONDS TO THEIR ADDRESSES.
;*
;;*************************************************************
TST6:	SCOPE
1$:	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$
	MOV	#5$,@#4		;SET TIMEOUT VECTOR TO 5$
	MOV	#KIPAR0,R0	;LOAD RD WITH ADDRESS OF FIRST REG.
	MOV	#10,R1		;LOAD RI	WITH	LOOP COUNT	(B)
	MOV	#-1,ANDADR	;INITIALIZE "AND" OF ADDR.	LOC
	CLR	ORADR		;INITIALIZE	"OR"	OF ADDR.	LOC.
	CLR	TONUM		;INITIALIZE "TIMEOUTS" COUNTER
2$:	TST	(R0)		;TRY ADDRESSING A KIPAR
				;IF IT TIMES OUT, WILL GO TO 5$
3$:	ADD	#2,R0		;PUT NEXT KIPAR ADDRESS IN RO
	SOB	R1,2$		;LOOP BACK TO 2$ UNTIL ALL TESTED
	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$
	TST	TONUM		;DID ANY OF THE KIPARS TIME OUT?
	BE0	4$		;BRANCH IF NO
	ERROR	10		;SUMMARY OF KIPAR TIMEOUTS
4$:	MOV	#TIMERR,@#4	;RESTORE NORMAL CPU TRAP ROUTINE ADDRESS
	BR	TST7			;;GO TO NEXT TEST
	
5$:	ADD	#4,KSP		;CLEAN UP THE STACK
	ERROR	7		;ONE OF THE KIPARS TIMED OUT
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 26" = 000756
	MOV	R0,R2		;LOAD THE ADDRESS THAT TIMED OUT INTO R2
	BIS	R2,ORADR	;"OR"	IT WITH OTHER ADDRS.	THAT TIMED OUT
	COM	R2		;"AND"	IT WITH OTHER ADDRS.	THAT TIMED OUT
	BIC	R2,ANDADR
	INC	TONUM		;INCREMENT THE TIMEOUT COUNTER
	BR	3$		;BRANCH BACK TO TEST THE NEXT KIPAR
	
;;****************************************************************
;*TEST 7	KERNEL PDR'S TIMEOUT TEST
;*
;*	THIS TEST ADDRESSES THE EIGHT (8) KERNEL PAGE DESCRIPTOR
;*	REGISTERS (KIPDR0-KIPDR7) AND CHECKS THAT SOMETHING
;*	RESPONDS TO THEIR ADDRESSES.
;*
;;****************************************************************
TST7:	SCOPE

1$:	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$
	MOV	#55,@#4		;SET TIMEOUT VECTOR TO 5$
	MOV	#KIPDR0,R0	;LOAD R0 WITH ADDRESS OF FIRST REG.
	MOV	#10,R1		;LOAD R1 WITH LOOP COUNT (8)

	MOV	#-1,ANDADR	;INITIALIZE "AND" OF ADDR. LOC
	CLR	ORADR	    	;INITIALIZE "OR" OF ADDR. LOC.	
	CLR	TONUM		;INITIALIZE "TIMEOUTS" COUNTER	
		
2$:	TST	(R0)		;TRY ADDRESSING A KIPDR	
				;IF IT TIMES OUT, WILL GO TO 5$	
3$:	ADD	#2,R0		;PUT NEXT KIPDR ADDRESS IN R0	
	SOB	R1,2$		;LOOP BACK TO 26 UNTIL ALL TESTED	
	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$	
	TST	TONUM		;DID ANY OF THE KIPARS TIME OUT?	
	BE0	4$		;BRANCH IF NO	
	ERROR	10		;SUMMARY OF KIPDR TIMEOUTS	
4$:	MOV	#TIMERR,@#4	;RESTORE NORMAL CPU TRAP ROUTINE ADDRESS
	BR	TST10		;;GO TO NEXT TEST

5$:	ADD	#4,KSP		;CLEAN UP THE STACK	
	ERROR	7		;ONE OF THE KIPARS TIMED OUT	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 26" = 000756	
	MOV	R0,R2 		;LOAD THE ADDRESS THAT TIMED OUT INTO R2	
	BIS	R2,ORADR	;"OR"	IT WITH OTHER ADDRS.	THAT TIMED OUT	
	COM	R2		;"AND"	IT WITH OTHER ADDRS.	THAT TIMED OUT	
	BIC	R2,ANDADR	
	INC	TONUM		;INCREMENT THE TIMEOUT COUNTER	
	BR	3$		;BRANCH BACK TO TEST THE NEXT KIPDR	

;;***************************************************************	
;*TEST 10	USER PAR'S TIMEOUT TEST	
;*	
;*	THIS TEST ADDRESSES THE EIGHT (8) USER PAGE ADDRESS	
;*	REGISTERS (UIPAR0-UIPAR7) AND CHECKS THAT SOMETHING	
;*	RESPONDS TO THEIR ADDRESSES.	
;*	
;;***************************************************************	
TST10:	SCOPE	

1$:	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$	
	MOV	#5$,@#4		;SET TIMEOUT VECTOR TO 5$	
	MOV	#UIPAR0,R0	;LOAD R0 WITH ADDRESS OF FIRST REG.	
	MOV	#10,R1		;LOAD R1 WITH LOOP COUNT (8)	
	MOV	#-1,ANDADR	;INITIALIZE "AND" OF ADDR. LOC	
	CLR	ORADR		;INITIALIZE "OR" OF ADDR. LOC.	
	CLR	TONUM		;INITIALIZE "TIMEOUTS" COUNTER	
2$:	TST	(R0)		;TRY ADDRESSING A UIPAR	
				;IF IT TIMES OUT, WILL GO TO 5$	
3$:	ADD	#2,R0		;PUT NEXT UIPAR ADDRESS IN RO	
	SOB	R1,2$		;LOOP BACK TO 2$ UNTIL ALL TESTED	
	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 16	
	TST	TONUM		;DID ANY OF THE UIPARS TIME OUT?	
	BE0	4$		;BRANCH	IF NO	
	ERROR	10		;SUMMARY OF UIPAR TIMEOUTS	
4$:	MOV	#TIMERR,@#4	;RESTORE NORMAL CPU TRAP ROUTINE ADDRESS	
	BR	TST11		;;GO TO NEXT TEST	
				
5$:	ADD	#4,KSP		;CLEAN UP THE STACK	
	ERROR	7		;ONE OF THE UIPARS TIMED OUT	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 25" = 000756	
	MOV	R0,R2		;LOAD THE ADDRESS THAT TIMED OUT INTO R2	
	BIS	R2,ORADR	;"OR" IT WITH OTHER ADDRS. THAT TIMED OUT	
	COM	R2		;"AND" IT WITH OTHER ADDRS. THAT TIMED OUT	
	BIC	R2,ANDADR	
	INC	TONUM		;INCREMENT THE TIMEOUT COUNTER	
	BR	3$		;BRANCH BACK TO TEST THE NEXT UIPAR	

;;***************************************************************	
;*TEST	11	
;*	USER PDR'S TIMEOUT TEST	
;*	THIS TEST ADDRESSES THE EIGHT (8) USER PAGE DESCRIPTOR	
;*	REGISTERS (UIPDR0-UIPDR7) AND CHECKS THAT SOMETHING	
;*	RESPONDS TO THEIR ADDRESSES.	
;*	
;****************************************************************	
TST11:	SCOPE	

1$:	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$	
	MOV	#5$,@#4		;SET TIMEOUT VECTOR TO 5S	
	MOV	#UIPDR0,R0	;LOAD RD WITH ADDRESS OF FIRST REG.	
	MOV	#10,R1		;LOAD R1 WITH LOOP COUNT (8)	
	MOV	#-1,ANDADR	;INITIALIZE "AND" OF ADDR. LOC	
	CLR	ORADR		;INITIALIZE "OR" OF ADDR.	LOC.	
	CLR	TONUM		;INITIALIZE "TIMEOUTS" COUNTER	
2$:	TST	(R0)		;TRY ADDRESSING A UIPDR	
				;IF IT TIMES OUT, WILL GO TO 5$	
3$:	ADD	#2,R0		;PUT NEXT UIPDR ADDRESS IN RO	
	SOB	R1,2$		;LOOP BACK TO 2$ UNTIL ALL TESTED	
	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO IS	
	TST	TONUM		;DID ANY OF THE UIPDRS TIME OUT?	
	BEQ	4$		;BRANCH IF NO	
	ERROR	10		;SUMMARY OF UIPDR TIMEOUTS	
4$:	MOV	#TIMERR,@#4	;RESTORE NORMAL CPU TRAP ROUTINE ADDRESS	
	BR	TST12		;;GO TO NEXT TEST	

5$:	ADD	#4,KSP		;CLEAN UP THE STACK	
	ERROR	7		;ONE OF THE UIPDRS TIMED OUT	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 2$" = 000756	
	MOV	R0,R2		;LOAD THE ADDRESS THAT TIMED OUT INTO R2	
	BIS	R2,ORADR	;"OR"	IT WITH OTHER ADDRS.	THAT TIMED OUT	
	COM	R2		;"AND" IT WITH OTHER ADDRS. THAT TIMED OUT	
	BIC	R2,ANDADR	
	INC	TONUM		;INCREMENT THE TIMEOUT COUNTER	
	BR	3$		;BRANCH BACK TO TEST THE NEXT UIPDR	

;****************************************************************	
;*TEST 12	SR0(15:13)	BIT TEST & SR2 TEST	
;*	
;*	THIS TEST CHECKS BITS <15:13> OF STATUS REGISTER 0 TO SEE	
;*	THAT EACH CAN BE SET AND CLEARED AND THAT A "RESET" WILL	
;*	CLEAR ALL OF THEM.  A TEST OF THESE THREE ERROR BITS CHECKS	
;*	PART OF SR0, THE SR0 MUX AND THE KTMUX.	THE REST OF THE	
;*	BITS IN SR0 WILL BE CHECKED LATER.	
;*	ALSO CHECK THAT SR2 IS TRACKING WITH MEM. MGMT.	
;*	OFF BUT LOCKS UP WHEN ANY OF SR0 ERROR BITS SET.	
;*	
;;***************************************************************	
TST12:	SCOPE	
	
1$:	MOV	#SR0,R0		;LOAD ADDRESS OF SR0 INTO R0
	MOV	#160000,(R0)	;SET BITS <15:13> IN SR0 (ERROR BITS)	
	RESET			;ISSUE AND "INIT" SIGNAL	
	MOV	(R0),R1		;READ SR0 INTO R1 TO SEE IF CLEAR	
	BEQ	2$		;BRANCH IF SR0<15:13> CLEARED BY "INIT"	
	ERROR	11		;SR0<15:13> NOT CLEARED BY A "RESET"	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 18" = 000770	
	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$	
2$:	MOV	SR2,WASSR2	;READ CONTENTS OF SR2	
	MOV	#2$,R1		;LOAD EXPECTED CONTENTS INTO RI	
	CMP	R1,WASSR2	;IS SR2 TRACKING?	
	BED	3$		;BRANCH IF YES	
	ERROR	41		;SR2 NOT "TRACKING" VIRTUAL ADDRESSES	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 2$" = 000767	
3$:	MOV	#4$,$LPERR	;SET LOOP ON ERROR POINTER TO 4$	
	MOV	#BIT15,R1	;PUT DATA TO BE WRITTEN IN RI	
	MOV	#3,R3		;SETUP R3 AS A LOOP COUNTER	
4$:	CLR	(R0)		;CLEAR 500 	
5$:	BIS	R1,(R0)		;SET ONE OF THE ERROR BITS IN SR0	
	MOV	(R0),R2		;READ SR0 INTO R2	
	CMP	R1,R2		;DID RIGHT ERROR BIT GET SET?	
	BEQ	6$		;BRANCH IF YES	
	ERROR	12		;BITS WERE SET WRONG IN SR0	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 4$" = 000772	
6$:	MOV	#5$,R4		;LOAD EXPECTED CONTENTS OF SR2 IN R4	
	MOV	SR2,WASSR2	;READ SR2	
	CMP	R4,WASSR2	;DID SR2 LUCK UP WHEN ERROR	
				;BIT SET IN SRI?	
	BEQ	7$		;BRANCH IF YES	
	ERROR	34		;SR2 DID NOT LOCK UP	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE	ERROR CALL WITH	
				;"BR 4$" = 000761	
7$:	ROR	R1		;CHANGE DATA TO CHECK NEXT ERROR BIT	
	SOB	R3,4$		;LOOP BACK UNTIL <15:13> ALL TESTED	
	CLR	(R0)		;CLEAR SR0 BEFORE LEAVING	
	MOV      #1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$	

;;***************************************************************	
;;TEST 13	SR0 & PSW DUAL ADDRESSING TEST	
;*		
;*	THIS TEST CHECKS MORE OF THE ADDRESS DETECTION LOGIC BY	
;*	VERIFYING THAT STATUS REGISTER 0 IS NOT EFFECTED BY WRITING	
;*	TO THE PSW AND THAT THE LOW BYTE OF STATUS REGISTER 0	
;*	IS NOT EFFECTED BY WRITING TO ITS HIGH BYTE. THIS IS TO	
;*	SEE IF ADJACENT OUTPUTS ARE SHORTED ON THE ADDRESS DET.	LOGIC.	
;*	
;;***************************************************************	
TST13:	SCOPE	

1$:	CLR	PSW		;CLEAR THE PSW	
	CLR	SR0		;CLEAR STATUS REGISTER 0	
	MTPS	#340		;SET PRIORITY 7	IN LOW BYTE OF PSW	
	MOV	SR0,R0		;READ STATUS REGISTER 0	
	BEQ	2$		;BRANCH IF IT WAS STILL 0	
	ERROR	13		;SR0 EFFECTED BY A WRITE TO THE PSW	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 1$" = 000767	
2$:	CLR	SR0		;BE SURE SR0 IS 0 BEFORE LEAVING	
	CLR	PSW		;BE SURE PSW IS 0 BEFORE LEAVING	
				
;;**************************************************************
;*TEST 14	TEST THAT SR1 READS ALL ZEROS	
;*	
;*	THIS TESTS CHECKS THAT EVEN THOUGH STATUS REGISTER 1	
;*	IS NON-EXISTENT, ITS ADDRESS SHOULD RESPOND WITH ALL ZEROS,	
;*	THEREBY CHECK ANOTHER PORTION OF THE ADDRESS DETECTION LOGIC.	
;*
;;**************************************************************
TST14:	SCOPE	
	MOV	#-1,R0		;FILL R0 WITH ALL ONES	
	MOV	SR1,R0		;READ SR1 INTO R0	
	BEQ	TST15		;;BRANCH IF SR1	READS ALL ZEROS	

	ERROR	14		;SR1 DID NOT READ ALL ZEROS	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;000772	

;;**************************************************************
;*TEST 15	BIT TEST OF KERNEL 8 USER PAR'S	
;*	
;*	THE FOLLOWING TEST CHECKS THE. BITS <11:00> OF BOTH THE KERNEL	
;*	AND USER PAGE ADDRESS REGISTERS. A "0" IS ROTATED THRU	
;*	THE REGISTERS FROM LEFT TO RIGHT. THIS CHECKS THE OPERATION	
;*	OF THE PAR/PDR ADDRESS MUX, THE KT MUX, AND THE PAR	
;*	OUTPUT DATA LINES.	
;*	
;****************************************************************
TST15:	SCOPE	

1$:	MOV	#KIPAR0,R0	;LOAD ADDRESS OF FIRST PAR IN RO	
2$:	MOV	#10,R3		;SETUP R3 TO COUNT B PAR'S	
	MOV	#35,$LPERR	;SET LOOP ON ERROR POINTER TO 3$	
3$:	CLR	(R0)		;CLEAR THE PAR	
	MOV	(R0),R1		;READ THE PAR INTO R1	
	BEQ	4$		;BRANCH IF PAR CLEARED OK	
	ERROR	11		;PAR WOULD NOT CLEAR	
				;FOR TIGHTER SCOPE LOOP		
				;REPLACE ERROR CALL WITH		
				;"BR 3$" = 000774		
4$:	MOV	#167777,R4	;LOAD "WALKING 0" TEST PATTERN IN R4		
	MOV	#5$,$LPERR	;SET LOOP ON ERROR POINTER TO 5$		
5$:	CLR	(R0)		;CLEAR THE PAR BEFORE LOADING DATA		
	MOV	R4,R1		;LOAD DATA INTO R1		
	BIC	#170000,R1	;MASK UNUSED BITS OUT OF THE DATA		
	BIS	R1,(R0)		;BIT SET THE TEST PATTERN INTO THE PAR 
	MOV	(R0),R2		;READ THE PAR INTO R2
	CMP	R1,R2		;DOES DATA WRITTEN=DATA READ?		
	BEQ	6$		;BRANCH IF YES		
	ERROR	12		;PAR BITS DID NOT SET CORRECTLY		
				;FOR TIGHTER SCOPE LOOP		
				;REPLACE ERROR CALL WITH		
				;"BR 5$" = 000767		
6$:	SEC			;SET THE C-BIT	FOR THE ROTATE INST.		
	ROR	R4		;ROTATE THE TEST PATTERN IN R4 
	BCS	5$		;BRANCH BACK IF MORE BITS TO TEST 
	ADD	#2,R0		;GET NEXT PAR ADDRESS IN R0
	SOB	R3,3$		;BRANCH BACK UNTIL ALL PAR'S TESTED		
	CMP	#UIPAR7+2,R0	;HAVE USER PAR'S BEEN TESTED		
	BHIS	7$		;BRANCH IF YES		
	MOV	#UIPAR0,R0	;LOAD FIRST USER PAR ADDR.	IN RO		
	BR	2$		;BRANCH BACK TO TEST USER PAR'S		
7$:	MOV	#1$,$LPERR	;RESET LOOP OR ERROR POINTER TO 1$
				;LEAVE TEST WITH BITS <11:1>=1 IN ALL PAR'S	


;;***************************************************************
;*TEST16	BIT TEST OF KERNEL & USER PDR'S
;*
;*	THE FOLLOWING TEST CHECKS THE BITS <14:8> AND <3:1> OF BOTH THE
;*	KERNEL AND USER PAGE DESCRIPTOR REGISTERS. A "0" IS ROTATED
;*	THRU THE REGISTERS FROM LEFT TO RIGHT.	SOME TEST PATTERNS WILL
;*	BE LOADED MORE THAN ONCE DUE THE UNUSED BITS IN THE PDR'S.
;*	THE PAR/PDR ADDRESS MUX, KTMUX, AND PDR OUTPUT DATA LINES
;*	ARE BEING CHECKED.
;*
;;***************************************************************
TST16:	SCOPE
	
1$:	MOV	#KIPDR0,R0	;LOAD ADD;*SS OF FIRST POP IN R0
2$:	MOV	#10,63		;SETUP R3 TO COUNT 8 POP'S
	MOV	#3$,$LPERR	;SET LOOP ON ERROR POINTER TO 3$
3$:	CLR	(R0)		;CLEAR THE PDR
	MOV	(R0),R1		;READ THE PDR INTO R1
	BEQ	4$		;BRANCH IF POR CLEARED OK
	ERROR	11		;PDR WOULD NOT rLEAR
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 3$" = 000774
4$:	MOV	#077777,64	;LOAD "WALKING "0" TEST PATTERN IN 114
	MOV	#5$,11LPERR	;SET LOOP ON ERROR POINTER TO 5$
5$:	CLR	(R0)		;CLEAR THE PDR BEFORE LOADING DATA
	MOV	R4,R1		;LOAD DATA INTO RI
	BIC	#100361,111	;MASK UNUSED BITS OUT OF THE DATA
	BIS	R1,(R0)		;BIT SET THE TEST PATTERN INTO THE PDR
	MOV	(R0),R2		;READ THE PDR INTO R2
	CMP	R1,R2		;DOES DATA WRITTEN=DATA READ?
	BEQ	6$		;BRANCH IF YES
	ERROR	12		;PDR BITS DID NOT SET CORRECTLY
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 5$" = 000767
6$:	SEC			;SET THE C-BIT FOR THE ROTATE INST.
	ROR	R4		;ROTATE THE TEST PATTERN IN R4
	BCS	5$		;BRANCH BACK IF MORE BITS TO TEST
	ADD	#2,R0		;GET NEXT PDR ADDRESS IN R0
	SOB	R3,3$		;BRANCH BACK UNTIL ALL PDR'S TESTED
	CMP	#UIPDR7+2,R0	;HAVE USER PDR'S BEEN TESTED?
	BHIS	7$		;BRANCH IF YES
	MOV	#UIPDR0,R0	;LOAD FIRST USER PDR ADDR. IN R0
	BR	2$		;BRANCH BACK TO TEST USER PDR'S
7$:	MOV	#15,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$
				;LEAVE TEST WITH ALL WRITEABLE BITS IN
				;ALL PDR'S = 1

;;***************************************************************
;*TEST 17	TEST FOR DUAL BYTE ADDRESSING OF KERNEL 8 USER PAR'S
;*
;*	THE FOLLOWING TEST WRITES TO BOTH BYTES OF THE KERNEL & USER
;*	PAR'S SEPERATELY TO SEE THAT WRITING TO ONE DOES NOT EFFECT
;*	THE OTHER. THIS FURTHER VERIFIES THE OPERATION OF THE PAR/PDR
;*	ADDR. MUX AND THE ADDR. DETECTION LOGIC.
;*
;;***************************************************************

TEST17: SCOPE

1$:	MOV	#KIPAR0,R0	;LOAD ADDRESS OF FIRST PAR INTO R0
2$:	MOV	#3$,$LPERR	;SET LOOP ON ERROR POINTER TO 3$
	MOV	#10,R3		;LOAD LOOP COUNTER TO DO 8 PAR'S
3$:	MOV	#-1,R1		;LOAD TEST PATTERN INTO R1
	CLR	(R0)		;CLEAR THE PAR
	MOVB	R1,(R0)		;WRITE	I'S TO THE LOW BYTE OF THE PAR	
	MOV	(R0),R2		;READ THE ENTIRE PAR INTO R2	
	BIC	#177400,61	;MASK HIGH BYTE 8 UNUSED BITS OUT OF THE DATA	
	CMP	R1,R2		;WAS ONLY THE LOW BYTE WRITTEN TO	
	BEQ	4$		;BRANCH IF YES	
	ERROR	15		;HIGH BYTE EFFECTED BY WRITING LOW BYTE IN PAR	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 3$" = 000766
4$:	MOV	#5$,$LPERR	;SET LOOP ON ERROR POINTER TO 5$	
5$:	CLR	(R0)		;CLEAR THE PAR	
	MOV	#-1,R1		;LOAD TEST,	PATTERN	INTO R1	
	MOVB	R1,1(R0)	;WRITE	IS TO THE HIGH BYTE OF THE PAR	
	MOV	(R0),R2		;READ THE ENTIRE PAR INTO R2	
	BIC	#170377,61	;MASK LOW BYTE 8 UNUSED BITS OUT OF DATA	
	CMP	R1,R2		;WAS ONLY THE HIGH BYTE WRITTEN 707	
	BEQ	6$		;BRANCH	IF YES	
	ERROR	15		;LOW BYTE EFFECTED BY WRITING HIGH BYTE IN PAR	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE FRROR CALL WITH	
				;"BR 5"	= 000765	
6$:	ADD	#2,R0		;PUT ADDRESS OF NEXT PAR IN RD	
	SOB	R3,3$		;BRANCH BACK UNTIL 8 PAR'S TESTED	
	CMP	#UIPAR7+2,R0	HAVE USER PAR'S BEEN TESTED	
	BHIS	7$		;BRANCH IF YES	
	MOV	#UIPAR0,R0	;LOAD ADDRESS OF FIRST USER PAR IN RO	
	BR	2$		;BRANCH BACK TO TEST USER PAR'S	
7$:	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$	
 

;;*****************************************************************
;*TEST 20	TEST FOP DUAL BYTE ADDRESSING OF KERNEL & USER PDR'S
;*
;*	THE FOLLOWING TEST WRITES TO BOTH BYTES OF THE KERNEL & USER
;*	PDR'S SEPERATELY TO SEE THAT WRITING TO ONE DOES NOT EFFECT
;*	THE OTHER. THIS FURTHER VERIFIES THE OPERATION OF THE PAR/PDR
;*	ADDR. MUX AND THE ADDR. DETECTION LOGIC.
;*
;;*****************************************************************
TST20:	SCOPE

1$:	MOV	#KIPDR0,R0	;LOAD ADDRESS OF FIRST POR INTO RO
2$:	MOV	#3$,$LPERR	;SET LOOP ON ERROR POINTER TO 3$
	MOV	#10,R3		;LOAD LOOP COUNTER TO DO 8 POR'S
3$:	MOV	#-1,R1		;LOAD TEST PATTERN INTO RI
	CLR	(R0)		;CLEAR THE POR
	MOVB	R1,(R0)		;WRITE I'S TO THE LOW BYTE OF THE FOR
	MOV	(R0),R2		;READ THE ENTIRE PDR INTO R2
	BIC	#177761,R1	;MASK HIGH BYTE & UNUSED BITS OUT OF DATA
	CMP	R1,R2		;WAS ONLY THE LOW BYTE WRITTEN TO?
	BEQ	4$		;BRANCH IF YES
	ERROR	15		;HIGH BYTE EFFECTED BY WRITING LOW BYTE IN PDR
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 3$" = 000766
4$:	MOV	#5$,$LPERR	;SET LOOP ON ERROR POINTER TO 5$
5$:	CLR	(R0)		;CLEAR THE PDR
	MOV	#-1,R1		;LOAD TEST PATTERN INTO RI
	MOVB	R1,1(R0)	;WRITE 1'S TO THE HIGH BYTE OF THE PDR
	MOV	(R0),R2 	;READ THE ENTIRE POR INTO R2
	BIC	#100377,R1	;MASK LOW BYTE & UNUSED BITS OUT OF DATA
	CMP	R1,R2		;WAS ONLY THE HIGH BYTE WRITTEN TO?
	BEG	6$		;BRANCH IF YES
	ERROR	15		;LOW BYTE EFFECTED BY WRITING HIGH BYTE IN PDR
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 5$" = 000765
6$:	ADD	#2,R0		;PUT ADDRESS OF NEXT PDR IN R0
	SOB	R3,3$		;BRANCH BACK UNTIL 8 PDR'S TESTED
	CMP	#UIPDR7+2,R0	;HAVE USER POR'S BEEN TESTED?
	BHIS	7$		;BRANCH IF YES
	MOV	#UIPDR0,R0	;LOAD ADDRESS OF FIRST USER PDR IN RO
	BR	2$		;BRANCH BACK TO TEST USER PDR'S
7$:	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$

;;***********************r******,*********************************** 
;*TEST 21	PAR-FOR DUAL ADDRESSING TEST
;*
;?	THE FOLLOWING TEST SETS ALL OF THE WRITEABLE BITS TO 1
;*	IN THE SIXTEEN (16) PAR'S AND PDR'S USING THE "SETREG"
;*	SUBROUTINE AND THEN CLEARS JUST	ONE OF THEM.  THE "CMPREG"
;*	SUBROUTINE IS USED TO READ ALL OF THE PAR'S AND PDR'S TO SEE
;*	THAT ONLY ONE REGISTER WAS CLEARED IN RESPONSE TO THAT ONE
;*	PAR OR PDR ADDRESS.  THE "CMPREG" SUBROUTINE REPORTS THE
;*	ADDRESS OF ANY REGISTER WHOSE BITS DID NOT REMAIN SET WHEN
;*	ANOTHER REGISTER WAS CLEARED.

;*
;*	THE PAR AND PDR CHIPS, PAR/PDR ADDR. MUX, AND ADDR. DETECTION
;*	LOGIC ARE CHECKED.
;*
;;****************************************************************
TST21:	SCOPE

1$:	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER 2$
	MOV	#10,R3		;LOAD LOOP COUNTER WITH AN 8
	MOV	#KIPDR0,R0	;LOAD ADDRESS OF FIRST KERNEL PDR AND RO
2$:	MOV	#KERSTK,KSP	;SETUP STACK POINTER
	JSR	PC,SETREG	;SET ALL BITS	IN ALL PAR'S IN PDR'S
	CLR	(R0)		;CLEAR ONE OF THE KERNEL POR'S
	JSR	PC,CMPREG	;SEE IF OTHER PAR/POR'S WERE EFFECTED
	ADD	#2,R0		;FORM ADDRESS OF NEXT KERNEL PDR TO CLEAR
	SOB	R3,2$		;LOOP TO 2$ UNTIL ALL KERNEL POR'S CHECKED
	MOV	#3$,$LPERR	;SET LOOP ON ERROR POINTER TO 3$
	MOV	#10,R3		;LOAD LOOP COUNTER WITH AN 8
	MOV	#KIPAR0,R0	;LOAD ADDRESS OF FIRST KERNEL PAR IN RO
3$:	MOV	#KERSTK,KSP	;SETUP STACK POINTER
	JSR	PC,SETREG	;SET ALL BITS	IN ALL PAR'S AND PDR'S
	CLR	(R0)		;CLEAR ONE OF THE KERNEL PAR'S
	JSR	PC,CMPREG	;SEE IF OTHER PAR/PDR'S WERE EFFECTED
	ADD	#2,R0		;FORM ADDRESS OF NEXT KERNEL PAR TO CLEAR
	SOB	R3,3$		;LOOP TO 3$ UNTIL ALL KERNEL PAR'S CHECKED
	MOV	#4$,$LPERR	;SET LOOP ON ERROR POINTER TO 4$
	MOV	#10,R3		;LOAD LOOP COUNTER WITH AN B
	MOV	#UIPDR0,R0	;LOAD ADDRESS OF FIRST USER PDR IN RO
4$:	MOV	#KERSTK,KSP	;SETUP STACK POINTER
	JSR	PC,SETREG	;SET ALL BITS	IN ALL PAR'S AND PDR'S
	CLR	(R0)		;CLEAR ONE OF THE USER PDR'S
	JSR	PC,CMPREG	;SEE IF OTHER PAR/POR'S WERE EFFECTED
	ADD	#2,R0		;FORM ADDRESS OF NEXT USER PDR TO CLEAR
	SOB	R3,4$		;LOOP TO 4$ UNTIL ALL USER POR'S CHECKED
	MOV	#5$,$LPERR	;SET LOOP ON ERROR POINTER TO 5$
	MOV	#10,R3		;LOAD LOOP COUNTER WITH AN B
	MOV	#UIPAR0,R0	;LOAD ADDRESS OF FIRST USER PAR IN RO
5$:	MOV	#KERSTK,KSP	;SETUP STACK POINTER
	JSR	PC,SETREG	;SET ALL BITS IN ALL PAR'S AND PDR'S
	CLR	(R0)		;CLEAR ONE OF THE USER PAR'S
	JSR	PC,CMPREG	;SEE IF OTHER PAR/PDR'S WERE EFFECTED
	ADD	#2,R0		;FORM ADDRESS OF NEXT USER PAR TO CLEAR	
	SOB	R3,5$		;LOOP TO 5$ UNTIL ALL USER PAR'S CHECKED	
	MOV	#1$,$LPERR	;SET LOOP ON ERROR POINTER TO 1$

;;******************************************************************
;*TEST 22	TEST THAT PAR-PDR'S NOT AFFECTED BY RESET	
;*	
;*	THIS TEST CHECKS TO SEE THAT THE KERNEL OR USER PAR/PDR'S ARE	
;*	NOT AFFECTED BY THE EXECUTION OF A "RESET" INSTRUCTION.	THE	
;*	"SETREG" SUBROUTINE IS USED TO SET ALL WRITEABLE BITS TO A "1" IN 
;*	THE PAR/PDR'S.	THEN THEY ARE READ TO SEE THAT THEY REMAINED 
;*	UNCHANGED 
;*	
;;******************************************************************	
TST22:	SCOPE	


1$:	JSR	PC,SETREG	;SET ALL BITS IN ALL PAR'S AND PDR'S	
	RESET			;ISSUE AN "INIT" BY EXECUTING A RESET	
	MOV	#KIPDR0,R0	;LOAD ADDRESS OF FIRST KERNEL PDR IN RO	
	MOV	#10,R4		;LOAD LOOP COUNTER WITH AN 8	
2$:	MOV	(R0),R1		;READ A KERNEL PDR INTO RI	
	CMP	#77416,R1	;ARE ALL THE BITS STILL SET?	
	BEQ	3$		;BRANCH IF YES	
	ERROR	55		;KERNEL PDR AFFECTED BY A RESET	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 2$" = 000773	
3$:	ADD	#2,R0		;FORM ADDRESS OF NEXT KERNEL PDR	
	SOB	R4,2$		;LOOP TO 2$ UNTIL ALL KERNEL PDR'S CHECKED	
	MOV	#KIPAR0,R0	;LOAD ADDRESS OF FIRST KERNEL PAR IN RO	
	MOV	#10,R4		;LOAD LOOP COUNTER WITH AN 8	
4$:	MOV	(R0),R1		;READ A KERNEL PAR INTO R1
	CMP	#7777,R1	;ARE ALL THE BITS STILL SET?	
	BEQ	5$		;BRANCH IF YES	
	ERROR	55		;KERNEL PAR AFFECTED BY A RESET	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 4$" = 000773	
5$:	ADD	#2,R0		;FORM ADDRESS OF NEXT KERNEL PAR	
	SOB	R4,4$		;LOOP TO 4$ UNTIL ALL KERNEL PAR'S CHECKED	
	MOV	#UIPDR0,R0	;LOAD ADDRESS OF FIRST USER PDR IN RO	
	MOV	#10,R4		;LOAD LOOP COUNTER WITH AN B	
6$:	MOV	(R0),R1		;READ A USER PDR INTO R1
	CMP	#77416,R1	;ARE ALL THE BITS STILL SET?	
	BE0	7S		;BRANCH	F YES	
	ERROR	55		;USER PDR AFFECTED BY A RESET	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 6$" = 000773	
7$:	ADD	#2,R0		;FORM ADDRESS OF NEXT USER PDR	
	SOB	R4,6$		;LOOP TO 6$ UNTIL ALL USER PDR'S CHECKED	

	MOV	#UIPAR0,R0	;LOAD ADDRESS OF FIRST USER PAR IN RO	
	MOV	#10,R4		;LOAD LOOP COUNTER WITH AN 8	
8$:	MOV	(R0),R1		;READ A USER PAR INTO R1	

	CMP	#7777,R1	;ARE ALL THE BITS STILL SET?	
	BEQ	9$		;BRANCH IF YES	
	ERROR	55		;USER PAR AFFECTED BY A RESET	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 8$" = 000773	
9$:	ADD	#2,R0		;FORM ADDRESS OF NEXT USER PAR	
	SOB	R4,8$		;LOOP TO 8$ UNTIL ALL USER PAR'S CHECKED	












;;***************************************************************	
;*TEST 23	INSTRUCTION FETCH NOT RELOCATED IN MAINT. MODE	
;*	
;*	THIS TEST CHECKS TO SEE THAT WHEN MEMORY MANAGEMENT IS IN	
;*	MAINTENANCE MODE (DESTINATION-ONLY-RELOCATION),	AN INSTRUCTION	
;*	FETCH IS NOT RELOCATED AND A REST CLEARS THE MAINTENANCE BIT	
;*	(BIT 08) IN SR0. IF THE	"FETCH"	IS RELOCATED, A PG.LENGTH ABORT	
;*	SHOULD OCCUR, CAUSING A HALT SINCE TRAP CATCHER IS PLACED IN VECTOR 250	
;*	
;*	
;*	NOTE:	A HALT MAY OCCUR IF MAINT. MODE NOT DISABLED BY RESET	
;*	
;*****************************************************************	
TST23:	SCOPE	
1$:	JSR	PC,TOFF		;TURN T-BIT TRAPPING OFF FOR THIS TEST	
	MOV	#KIPDR0,R0	;LOAD ADDRESS OF FIRST KERNEL PDR INTO RO	
	MOV	#10,R4		;LOAD LOOP COUNTER WITH AN 8	
2$:	CLR	(R0)+		;CLEAR PDR - MAPPING PAGE NON-RES,	0 BLKS.	
	SOB	R4,2$		;LOOP TO 2$ UNTIL ALL KERNEL PDR'S CLEARED	
	MOV	NMMVEC+2,MMVEC	;LOAD TRAP CATCHER INTO MEM MGM. VECTOR	
	CLR	MMVEC+2		;
				;A HALT WILL OCCUR IF RESET FAILS	
				;TO DISABLE DEST.-ONLY RELOCATION	
	MOV	#1006,KIPDR0	;MAP KERNEL PG 0 R/W, 3 BLOCKS LONG.	
	MOV	N3S,$LPERR	;SET LOOP ON ERROR POINTER TO 3$	
3$:	MOV	#BIT8,SR0	;TURN ON DEST-ONLY-RELOCATION	
	RESET			;SHOULD CLEAR MAINT. BIT - WILL ABORT IF RELOCATED	
	BIT	#BIT8,SR0	;WAS MAINT. BIT (BIT 8) OF SR0 CLEARED?	
	BEQ	4$		;BRANCH	IF YES	
	CLR	SR0		;CLEAR SR0 SO ERROR CAN BE REPORTED	
	ERROR	61		;MAINT.	MODE NOT DISABLED BY A RESET	
				;FOR A TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 3$" = 000765	
4$:	MOV	#KERSTK,KSP	;RESTORE STACK POINTER	
	CLR	SR0		;BE SURE SR0 IS CLEAR	
	MOV	#MGMERR,MMVEC	;RESTORE MEM. MGMT. TRAP VECTOR
	MOV	#340,MMVEC+2	;RESTORE MEM. MGMT VECTOR+2
	MOV	#16,61.PERR	;RESET LOOP ON ERROR POINTER TO 1$
	JSR	PC,TON		;TURN T?BIT TRAPPING BACK ON
				
				
				
				
				
				
				
				
				
				
				
				
				
;;***************************************************************
;*TEST 24	TEST THAT SOURCE NOT RELOCATED IN MAINTENANCE MODE
;*
;*	THIS TEST CHECKS TO SEE THAT WHEN MEMORY MANAGEMENT IS IN
;*	MAINTENANCE MODE, THE SOURCE IS NOT RELOCATED.	ONLY THE
;*	DESTINATION IS RELOCATED.  KERNEL PAR'S 3 8 4 ARE MAPPED TO
;*	PHYSICAL ADDRESS 60000-77776.  PDR4 IS SET TO ALLOW FULL READ/WRITE
;*	BUT PDR3 IS CLEAR ALLOWING TO ACCESS.  VIRTUAL ADDRESSES REFERENCING
;*	PAR/PDR'S 4 8 3 ARE USED IN AS DESTINATION AND SOURCE RESPECTIVELY.
;*	IF THE SOURCE IS RELOCATED IN MAINTENANCE A MEM. MGMT. TRAP WILL
;*	OCCUR AND THE ERROR WILL BE REPORTED.  KERNEL PG. 7 IS MAPPED R/W.

;;*.***************************.***********************.****.****
TST24:	SCOPE
1$:	JSR	PC,TOFF		;TURN OFF T?BIT TRAPPING FOR THIS TEST
	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$
	MOV	#600,KIPAR3	;MAP KERNAL PAGE 3 TO 12-16K
	MOV	#600,KIPAR4	;MAP KERNAL PAGE 4 TO 12-16K
	MOV	#7600,KIPAR7	;MAP KERNAL PAGE 7 TO THE I/O PAGE
	CLR	KIPDR3		;MAP KERNAL PAGE 3 "NO ACCESS"
	MOV	#77406,KIPDR4	;MAP KERNAL PAGE 4 R/W,	128 BLKS
	MOV	#77406,KIPDR7	;MAP KERNAL PAGE 7 R/W,	128 BLKS
	MOV	#4$,MMVEC	;SET M.M. VECTOR TO 4$. IN CASE OF ABORT
	MOV	#377,@#60000	;LOAD ALL 1'S	IN LOW BYTE OF TEST LOC.
	MOV	4-1,80		;LOAD EXPECTED CONTENTS OF TEST LOC.	IN RO
2$:	BIS	#BIT8,SR0	;TURN ON DEST.?ONLY?RELOCATION
	MOVB	@#60000,@#100001;LOAD HI BYTE OF TEST LOC.?ABORT IF SOURCE RELOCATED
	RESET			;TURN OFF DEST.?ONLY?RELOCATION
	MOV	@#60000,R1	;READ CONTENTS OF TEST LOC.
	CMP	R0,R1		;WAS TEST LOCATION LOADED PROPERLY?
	BEQ	3$		;BRANCH IF YES
	ERROR	62		;TEST LOC. NOT LOADED ? INST. WAS ABORTED
				;WHEN SOURCE WAS RELOCATED
				;FOR TIGHTER SCOPE LOOP REPLACE
				;ERROR CALL WITH
				;"BR 2$" = 000764
3$:	MOV	#MGMERR,MMVEC	;RESTORE MEM. MGMT. VECTOR
	MOV	#77406,KIPDR3	;MAP KERNAL PAGE 3 R/W. 128 BLKS
	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$
	JSR	PC,TON		;TURN T?BIT TRAPPING BACK ON		
	BR	TST25		;;SKIP TO NEXT TEST		
;*  IF THE PROGRAM TRIES TO RELOCATE THE SOURCE, IT SHOULD TRAP TO 4$

4$:	BIC	#BIT8,SR0	;TURN OFF DEST.?ONLY?RELOCATION THRU PAR/PDR 7
	MOV	SR0,WASSR0	;SAVE REST OF SR0 CONTENTS		
	MOV	SR2,WASSR2	;SAVE CONTENTS OF SR2		
	MOV	SP,WASR6	;SAVE VALUE OF THE STACK POINTER		
	MOV	(SP)+,TRAPPC	;SAVE PC OF TRAP		
	MOV	(SP)+,TRAPPS	;SAVE PSW OF TRAP		
	BIC	#160000,SR0	;CLEAR ERROR BITS IN SR1
	ERROR	63		;SOURCE APPARENTLY RELOCATED IN MAINT. MODE 
				;FOR TIGHTER SCOPE LOOP		
				;REPLACE ERROR CALL WITH A		
				;"NOP" = 000240		
	MOV	TRAPPS,-(SP)	;PUT PSW OF TRAP BACK ON THE STACK
	MOV	TRAPPC,-(SP)	;PUT PC OF TRAP BACK ON THE STACK 
	RTI			;RETURN TO TEST		
			
			
			
			
			
			
			
			
			
			
			
			
;;***************************************************************		
;*TEST 25	RELOCATION & ADDER TEST (NO CARRIES)		
;*		
;*	THE FOLLOWING TEST SETS UP THE KERNEL PAR'S AND PDR'S		
;*	FOR THE REST OF THE PROGRAM. IT THEN USES DIFFERENT		
;*	VIRTUAL ADDRESSES AND DIFFERENT VALUES FOR KERNEL PAR 4		
;*	TO PUT DIFFERENT PATTERNS AT THE INPUTS OF THE THREE		
;*	MEMORY MANAGEMENT ADDER CHIPS.	THE VALUES ARE SUCH		
;*	THAT NO CARRIES ARE GENERATED OUT OF ANY OF THE ADDER CHIPS.		
;*		
;*	THE METHOD USED TO SEE THAT THE RIGHT PHYSICAL BUS ADDRESS		
;*	IS FORMED BY THE ADDERS IS TO WRITE A PATTERN TO VIRTUAL		
;*	LOCATION WITH MEMORY MGMT. IN THE MAINTENANCE MODE, AND		
;*	THEN READ THAT LOCATION USING THE PHYSICAL ADDRESS THAT SHOULD		
;*	HAVE BEEN FORMED TO SEE IF THE TEST PATTERN GOT THEIR.		
;*		
;;***************************************************************		
TST25:	SCOPE		

1$:	MOV	#KIPAR0,R0	;LOAD ADDRESS OF FIRST KERNEL PAR IN RO		
	CLR	RI		;CLEAR R1		
	MOV	#7,R2		;LOAD LOOP COUNTER WITH A 7		
2$:	MOV	R1,(R0)+	;MAP KERNEL PAR'S TO PAGES 0-6 (4K EACH) 
	ADD	#200,R1		
	SOB	R2,2$		;LOOP UNTIL KIPAR0 ? KIPAR6 ARE LOADED		
	MOV	#7600,(R0)	;MAP KIPAR7 TO THE I/O PAGE
	MOV	#KIPDR0,R0	;LOAD ADDRESS OF FIRST KERNEL PDR IN RO
	MOV	#77406,R1	;LOAD PDR DATA INTO R1
	MOV	#10,R2		;LOAD LOOP COUNTER WITH AN 8
3$:	MOV	R1,(R0)+	;MAP ALL 8 PAGES 128 BLOCKS, UPWARD
	SOB	R2,3$		;       EXPANDABLE, READ/WRITE

4$:	MOV	#4$,$LPERR	;SET LOOP ON ERROR POINTER TO 4S
	MOV	#67776,R0	;LOAD PHYSICAL ADDR. PBA INTO R0
	MOV	#107776,R1	;LOAD VIRTUAL ADDR. VBA INTO R1
	MOV	#125250,R2	;LOAD TEST PATTERN INTO R2
	MOV	#600,R4 	;LOAD R4 WITH PAR VALUE
	MOV	R4,KIPAR4	;LOAD KERNEL PAR 4 BITS <11:00>
	MOV	(R0),$TMP0	;SAVE CONTENTS AT TEST LOCATION
	BIS	#BIT8,SR0	;TURN ON "DESTINATION-ONLY-RELOCATION"
	MOV	R2,(R1)		;LOAD 125250 USING ADDER CHIPS (PAR4 + VIRT ADDR.)
	MOV	(R0),R3		;READ 125250 BACK WITHOUT USING MEM. MGMT.
	RESET			;TURN OFF MEMORY MGMT. MAINT. MODE
	MOV	$TMP0,(R0)	;RESTORE ORIGINAL CONTENTS TO TEST LOC.
	CMP	R2,R3		;WAS SAME PATTERN READ BACK THAT WAS
				;WRITTEN USING "DEST-ONLY-RELOC."?
	BEQ	5$		;BRANCH IF YES
	MOV	R1,VIRT1	;SAVE VIRTUAL ADDR. TO FORM PHYS. ADOR
	JSR	PC,FORMPA	;GO FORM PHYSICAL ADDRESS FOR TYPING
	ERROR	17		;TEST LOCATION DID NOT HAVE PATTERN
				;THAT SHOULD HAVE BEEN WRITTEN TO IT.
				;APPARENTLY PHYSICAL ADDR. WAS
				;FORMED WRONG BY ADDERS USING
				;THE VIRTUAL ADDR. AND KIPAR4
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 4$" = 000742
5$:
6$:	MOV	#6$,$LPERR	;SET LOOP ON ERROR POINTER TO 6$
	MOV	#67776,RD	;LOAD PHYSICAL ADDR. PBA INTO RO
	MOV	#102576,R1	;LOAD VIRTUAL ADDR. VBA INTO RI
	MOV	#125251,R2	;LOAD TEST PATTERN INTO R2
	MOV	#652,R4	;LOAD R4 WITH PAR VALUE
	MOV	R4,KIPAR4	;LOAD KERNEL PAR 4 BITS <11:00>
	MOV	(R0),$TMP0	;SAVE CONTENTS AT TEST LOCATION
	BIS	#BIT8,SR0	;TURN ON "DESTINATION-ONLY-RELOCATION"
	MOV	R2,(R1)		;LOAD 125251 USING ADDER CHIPS (PAR4 + VIRT ADDR.)
	MOV	(R0),R3		;READ 125251 BACK WITHOUT USING MEM. MGMT.
	RESET			;TURN OFF MEMORY MGMT. MAINT. MODE
	MOV	$TMP0,(R0)	;RESTORE ORIGINAL CONTENTS TO TEST LOC.
	CMP	R2,R3		;WAS SAME PATTERN READ BACK THAT WAS
				;WRITTEN USING "DEST-ONLY-RELOC."7
	BEQ	7$		;BRANCH IF YES

	MOV	R1,VIRT1	;SAVE VIRTUAL ADDR. TO FORM PHYS. ADDR
	JSR	PC,FORMPA	;GO FORM PHYSICAL ADDRESS FOR TYPING
	ERROR	17		;TEST LOCATION DID NOT HAVE PATTERN
				;THAT SHOULD HAVE BEEN WRITTEN TO IT.
				;APPARENTLY PHYSICAL ADDR. WAS
				;FORMED WRONG BY ADDERS USING
				;THE VIRTUAL ADDR. AND KIPAR4
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 6$" = 000742
7$:
8$:	MOV	#8$,$LPERR	;SET LOOP ON ERROR POINTER TO 8$
	MOV	#67776,R0	;LOAD PHYSICAL ADDR. PBA INTO RO
	MOV	#105276,R1	;LOAD VI TUAL ADDR. VBA INTO RI
	MOV	#125252,R2	;LOAD TEST PATTERN INTO R2
	MOV	#625,R4 ;LOAD R4 WITH PAR VALUE
	MOV	R4,KIPAR4	;LOAD KERNEL PAR 4 BITS <11:00>
	MOV	(R0),$TMP0	;SAVE CONVENTS AT TEST LOCATION
	BIS	#BIT8,SR0	;TURN ON "DESTINATION-ONLY-RELOCATION"
	MOV	R2,(R1)		;LOAD 125252 USING ADDER CHIPS (PAR4 + VIRT ADDR.)
	MOV	(R0),R3		;READ 125252 BACK WITHOUT USING MEM. MGMT.
	RESET			;TURN OFF MEMORY MGMT. MAINT. MODE
	MOV	$TMP0,(R0)	;RESTORE ORIGINAL CONTENTS TO TEST LOC.
	CMP	R2,R3		;WAS SAME PATTERN READ BACK THAT WAS
				;WRITTEN USING "DEST-ONLY-RELOC."
	BEQ	9$		;BRANCH IF YES
	MOV	R1,VIRT1	;SAVE VIRTUAL ADDR. TO FORM PHYS. ADDR
	JSR	PC,FORMPA	;GO FORM PHYSICAL ADDRESS FOR TYPING
	ERROR	17		;TEST LOCATION DID NOT HAVE PATTERN
				;THAT SHOULD HAVE BEEN WRITTEN TO IT.
				;APPARENTLY PHYSICAL ADDR. WAS
				;FORMED WRONG BY ADDERS USING
				;THE VIRTUAL ADDR. AND KIPAR4
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 8$" = 000742
9$:

10$:	MOV	#10$,$LPERR	;SET LOOP ON ERROR POINTER TO 10$
	MOV	#PSW,R0		;LOAD PHYS. ADDR. OF PSW INTO RO
	MOV	#100076,R1	;LOAD VIRTUAL ADDR. FOR PSW INTO RI
	MOV	#030340,62	;LOAD DATA FOR PSW IN R2
	MOV	#7777,R4	;LOAD R4 WITH PAR VALUE
	MOV	R4,KIPAR4	;LOAD KERNEL PAR 4 BITS <11:00>
	CLR	(R0)		;CLEAR THE PAW
	BIS	#BIT8,SR0	;TURN ON "DESTINATION-ONLY-RELOCATION"
	MOV	R2,(R1)		;LOAD PSW USING ADDER CHIPS (PAR4 + VIRT ADDR.)
	MOV	(R0),R3		;READ POW BACK WITHOUT USING MEM. MGMT.
	RESET			;TURN OFF MEM. MGMT MAINT. MODE
	CLR	(R0)		;CLEAR THE PSW
	BIC	#37,R3		;MASK T-BIT & CC BITS OUT OF DATA READ
	CMP	R2,R3		;WAS PSW WRITTEN WHILE IN MAINT. MODE?
	BEQ	11$		;BRANCH IF YES
	MOV	R1,VIRT1	;SAVE VIRTUAL ADDR. TO FORM PHYS. ADDR
	JSR	PC,FORMPA	;GO FORM PHYSICAL ADDR. FOR TYPING
	ERROR	17		;PSW DID NOT HAVE DATA THAT IT SHOULD HAVE,
				;APPARENTLY PHYS. ADDR. OF PSW WAS
				;NOT FORMED BY ADDERS USING THE
				;VIRTUAL ADDR. AND KIPAR4
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 10$" = 000742
11$:	MOV	#11$,$LPERR	;SET LOOP ON ERROR POINTER TO 11$
	MOV	#PSW,R0		;LOAD PHYS. ADDR. OF PSW INTO R0

	MOV	#117776,R1	;LOAD VIRTUAL ADDR. FOR PSW INTO R1
	MOV	6030240,R2	;LOAD DATA FOR PSW IN R2	
		
	MOV	#7600,R4	;LOAD R4 WITH PAR VALUE	
	MOV	R4,KIPAR4	;LOAD KERNEL PAR 4 BITS (11:00>	
	BIS	#BIT8,SR0	;TURN ON "DESTINATION-ONLY-RELOCATION"	
	MOV	R2,(R1)		;LOAD PSW USING ADDER CHIPS (PAR4 + VIRT. ADDR.)
	MOV	(R0),R3		;READ PSW BACK WITHOUT USING MEM. MGMT.	
	RESET			;TURN OFF MEM. MGMT.	MAINT. MODE	
	CLR	(R0)		;CLEAR THE PSW	
	BIC	#37,R3		;MASK T-BIT & CC BITS OUT OF DATA READ	
	CMP	R2,R3		;WAS PSW WRITTEN WHILE IN MAINT. MODE?	
	BEQ	12$		;BRANCH 1F YES	
	MOV	R1,VIRT1	;SAVE VIRTUAL ADDR. TO FORM PHYSICAL ADDR.	
	JSR	PC,FORMPA	;GO FORM PHYSICAL ADDR.	FOR TYPING	
	ERROR	17		;PSW DID NOT HAVE DATA THAT IT SHOULD	
				;HAVE,	APPARENTLY PHYS. ADDR. OF PSW WAS	
				;NOT FORMED BY ADDERS USING THE	
				;VIRTUAL ADDR.	AND KIPAR4	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 11$" = 000743	
12$:	MOV	#1$,$LPERR		;RESET	LOOP ON ERROR POINTER TO 1$	

;;***************************************************************	
;*TEST 26	RELOCATION & ADDER TEST	(WITH CARRIES)
;*	
;*	THE FOLLOWING TEST USES THE SAME METHOD AS THE PREVIOUS	
;*	TEST TO VERIFY MEMORY MANAGEMENTS ABILITY TO CONSTRUCT	
;*	PHYSICAL BUS ADDRESSES USING A VIRTUAL BUS ADDRESS AND THE	
;*	CONTENTS OF A PAGE ADDRESS REGISTER.	HOWEVER, THE VALUES	
;*	AND PATTERNS USED IN THIS TEST WILL GENERATE CARRIES FROM	
;*	CHIP TO CHIP AND CHECK "WRAPAROUND" TO ADDRESS 000000 BY	
;*	USING VIRTUAL ADDR. 100100 AND KIPAR4 = 7777.	
;*
;;***************************************************************	
TST26:	SCOPE	
	
1$:				;KERNEL	PAR'S AND ',DR'S HAVE BEEN	
				;SETUP BY THE PREVIOUS TEST	
2$:	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$	
	MOV	#64276,R0	;LOAD PHYSICAL ADDR.	PBA INTO R0
	MOV	#102176,R1	;LOAD VIRTUAL ADDR.	VBA	INTO R1	
	MOV	#125253,R2	;LOAD TEST PATTERN INTO R2	
	MOV	#1621,R4	;LOAD R4 WITH PAR VALUE	
	MOV	R4,KIPAR4	;LOAD KERNEL PAR 4 BITS <11:00>	
	MOV	(R0),$TMP0	;SAVE CC .TENTS AT TEST LOCATION	
	BIS	#BIT8,SR0	;TURN ON	"DESTINATION-ONLY-RELOCATION"	
	MOV	R2,(R1)		;LOAD 125253 USING ADDER CHIPS (PAR4 + VIRT ADDR.)
	MOV	(R0),R3		;READ 125253 BACK WITHOUT USING MEM. MGMT.	
	RESET			;TURN OFF MEMORY MGMT. MAINT. MODE 
	MOV	$TMP0,(R0)	;RESTORE ORIGINAL CONTENTS TO TEST LOC.	
	CMP	R2,R3		;WAS SAME PATTERN READ BACK THAT WAS	
				;WRITTEN USING "DEST-ONLY-RELOC."
	BEQ	3$		;BRANCH IF YES	
	MOV	R1,VIRT1	;SAVE VIRTUAL ADDR. TO FORM PHYS. ADDR	
	JSR	PC,FORMPA	;GO FORM PHYSICAL ADDRESS FOR TYPING	
	ERROR	17		;TEST LOCATION DID NOT HAVE PATTERN	
				;THAT SHOULD HAVE BEEN WRITTEN TO IT.	
				;APPARENTLY PHYSICAL ADDR. WAS	
				;FORMED WRONG BY ADDERS USING	
				;THE VIRTUAL ADDR. AND KIPAR4	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 2$" = 000742	
3$: 
4$:	MOV	#44,$LPERR	;SET LOOP ON ERROR POINTER TO 4$	
	MOV	#64476,R0	;LOAD PHYSICAL ADDR. PBA INTO R0
	MOV	#112376,R1	;LOAD VIRTUAL ADDR. VBA INTO R1	
	MOV	#125254,R2	;LOAD TEST PATTERN INTO R2	
	MOV	#521,R4	;LOAD R4 WITH PAR VALUE	
	MOV	R4,KIPAR4	;LOAD KERNEL PAR 4 BITS <11:00>	
	MOV	(R0),$TMP0	;SAVE CONTENTS AT TEST LOCATION	
	BIS	#BIT8,SR0	;TURN ON "DESTINATION-ONLY-RELOCATION"	
	MOV	R2,(R1)		;LOAD 125254 USING ADDER CHIPS (PAR4 + VIRT ADDR.)
	MOV	(R0),R3		;READ 125254 BACK WITHOUT USING MEM. MGMT.	
	RESET			;TURN OFF MEMORY MGMT. WAIST. MODE 
	MOV	$TMP0,(R0)	;RESTORE ORIGINAL CONTENTS TO TEST LOC.
	CMP	R2,R3		;WAS SAME PATTERN READ BACK THAT WAS	
				;WRITTEN USING "DEST-ONLY-RELOC."?	
	BEQ	5$		;BRANCH	IF YES	
	MOV	R1,VIRT1	;SAVE VIRTUAL ADDR. TO FORM PHYS. ADDR	
	JSR	PC,FORMPA	;GO FORM PHYSICAL ADDRESS FOR TYPING	
	ERROR	17		;TEST LOCATION DID NOT HAVE PATTERN	
				;THAT SHOULD HAVE BEEN WRITTEN TO IT.	
				;APPARENTLY PHYSICAL ADDR. WAS	
				;FORMED WRONG BY ADDERS USING	
				;THE VIRTUAL ADDR. AND KIPAR4	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 4$" = 000742	
5$:				
6$:	MOV	#6$,$LPERR	;SET LOOP ON ERROR POINTER TO 6$	
	MOV	#61076,R0	;LOAD PHYSICAL ADDR. PBA INTO RD	
	MOV	#106776,R1	;LOAD VIRTUAL ADDR. VBA INTO R1	
	MOV	#125255,R2	;LOAD TEST PATTERN INTO R2	
	MOV	#521,R4	;LOAD R4 WITH PAR VALUE	
	MOV	R4,KIPAR4	;LOAD KERNEL PAR 4 6115 <11:00>	
	MOV	(R0),$TMP0	;SAVE CONTENTS AT TEST LOCATION	
	BIS	#BIT8,SR0	;TURN ON "DESTINATION-ONLY-RELOCATION"	
	MOV	R2,(R1)		;LOAD 125255 USING ADDER CHIPS (PAR4 + VIRT ADDR.)
	MOV	(R0),R3		;READ 125255 BACK WITHOUT USING MEM. MGMT.	
	RESET			;TURN OFF MEMORY MGMT. MAINT. MODE	
	MOV	$TMP0,(R0)	;RESTORE ORIGINAL CONTENTS TO TEST LOC.	
	CMP	R2,R3		;WAS SAME PATTERN READ BACK THAT WAS	
				;WRITTEN USING "DEST-ONLY-RELOC."?	
	BEQ	7$		;BRANCH	IF YES	
	MOV	R1,VIRT1	;SAVE VIRTUAL ADDR. TO FORM PHYS. ADDR 
	JSR	PC,FORMPA	;GO FORM PHYSICAL ADDRESS FOR TYPING	
	ERROR	17		;TEST LOCATION DID NOT HAVE PATTERN	
				;THAT SHOULD HAVE BEEN WRITTEN TO IT.	
				;APPARENTLY PHYSICAL ADDR. WAS	
				;FORMED WRONG BY ADDERS USING	
				;THE VIRTUAL ADDR. AND KIPAR4	
				;FOR TIGHTER SCOPE LOOCFKTHB.P11	
				;REPLACE ERROR CALL WITH	
				;"BR 6$" = 000742	
7$:	
8$:	MOV	#8$,$LPERR	;SET LOO  ON ERROR POINTER TO 8$	
	MOV	#60076,R0	;LOAD PHYSICAL ADDR. PBA INTO R0
	MOV	#107776,R1	;LOAD VIRTUAL ADDR. VBA INTO RI	
	MOV	#125256,R2	;LOAD TEST PATTERN INTO R2	
	MOV	#501,R4	;LOAD R4 WITH PAR VALUE	
	MOV	R4,KIPAR4		
	MOV	(R0),$TMP0	;SAVE CONTENTS AT TEST LOCATION	
	BIS	#BIT8,SR0	;TURN ON "DESTINATION-ONLY-RELOCATION"	
	MOV	R2,(R1)		;LOAD 125256 USING ADDER CHIPS (PAR4 + VIRT ADDR.)
	MOV	(R0),R3		;READ 125256 BACK WITHOUT USING MEM. MGMT.	
	RESET			;TURN OFF MEMORY MGMT. MAINT. MODE	
	MOV	$TMP0,(R0)	;RESTORE ORIGINAL CONTENTS TO TEST LOC.	
	CMP	R2,R3		;WAS SAME PATTERN READ BACK THAT WAS	
				;WRITTEN USING "DEST-ON-RELOC."?
	BEQ	9$		;BRANCH IF YES	
	MOV	R1,VIRT1	;SAVE VIRTUAL ADDR.	TO FORM PHYS.	ADDR	
	JSR	PC,FORMPA	;GO FORM PHYSICAL ADDRESS FOR TYPING	
	ERROR	17		;TEST LOCATION DID NOT HAVE PATTERN	
				;THAT SHOULD HAVE BEEN WRITTEN TO IT.	
				;APPARENTLY PHYSICAL ADDR. WAS	
				;FORMED WRONG BY ADDERS USING	
				;THE VIRTUAL ADDR.	AND KIPAR4	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 8$" = 000742	
9$:	
10$:	MOV	#10$,$LPERR	;SET LOOP ON ERROR POINTER TO 10$	
	MOV	#000000,R0	;LOAD PHYSICAL ADDR. PBA INTO R0
	MOV	#100100,R1	;LOAD VIRTUAL ADDR. VBA INTO RI	
	MOV	#125257,R2	;LOAD TEST PATTERN INTO R2	
	MOV	#7777,R4	;LOAD R4 WITH PAR VALUE	
	MOV	R4,KIPAR4	;LOAD KERNEL PAR 4 BITS <11:00>	
	MOV	(R0),$TMP0	;SAVE CONTENTS AT TEST LOCATION	
	BIS	#BIT8,SR0	;TURN ON "DESTINATION-ONLY-RELOCATION"	
	MOV	R2,(R1)		;LOAD 125267 USING ADDER CHIPS (PAR4 + VIRT ADDR.)
	MOV	(R0),R3		;READ 125257 BACK WITHOUT USING MEM. MGMT.	
	RESET			;TURN OFF MEMORY MGMT. MAINT. MODE	
	MOV	$TMP0,(R0)	;RESTORE ORIGINAL CONTENTS TO TEST LOC.	
	CMP	R2,R3		;WAS SAME PATTERN READ BACK THAT WAS	
				;WRITTEN USING "DEST-ONLY-RELOC."?	
	BEQ	11$		;BRANCH	IF YES	
	MOV	R1,VIRT1	;SAVE VIRTUAL ADDR. TO FORM PHYS. ADDR	
	JSR	PC,FORMPA	;GO FORM PHYSICAL ADDRESS FOR TYPING	
	ERROR	17		;TEST LOCATION DID NOT HAVE PATTERN	
				;THAT SHOULD HAVE BEEN WRITTEN TO IT.	
				;APPARENTLY PHYSICAL ADDR. WAS	
				;FORMED WRONG BY ADDERS USING	
				;THE VIRTUAL ADDR.	AND KIPAR4	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 10$" = 000742	

11$:	
	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$	

;;********************************************************************
;*TEST	27	READ AND WRITE WHILE IN RELOCATE MODE
;*	
;*	THE FOLLOWING TEST TURNS ON MEMORY MANAGEMENT AND THEN
;*	READS AND WRITES LOCATIONS BETWEEN PHYSICAL ADDRESSES
;*	060000-067600.	ONE LOCATION IN EVERY BLOCK (32. WORDS)
;*	IS WRITTEN USING PAR4 AND READ USING PARS.  THIS IS
;*	DONE IN BOTH USER AND KERNEL MODES.  THE USER PAR/PDR'S
;*	ARE SETUP AT THE BEGINNING OF THE TEST AND ONCE MEMORY
;*	MANAGEMENT IS TURNED ON IT IS LEFT ON FOR THE REST OF THE
;*	OF THE PROGRAM.	THE "MODE" INPUT TO THE PAR/PDR ADDRESS MUX
;*	IS CHECKED BY READING AND WRITING IN USER MODE.	REMEMBER
;*	ALSO, THAT SINCE MEMORY MANAGEMENT IS ON (IN RELOCATE
;*	MODE) THE PROGRAM ITSELF IS USING ITS VIRTUAL ADDRESSES AND
;*	THE PAR/PDR'S TO EXECUTE..
;*	
;*	WHILE TESTING IN KERNEL MODE. USER PAGES 4 & 5 ARE MAPPED
;*	NON-RESIDENT WITH DIFFERENT PAR VALUES THAN THE KERNEL
;*	PAR'S TO BE SURE THAT THE KERNEL PAR'S AND PDR'S ARE BEING
;*	USED WHEN IN KERNEL MODE (AND VICE VERSA WHILE TESTING IN
;*	USER MODE).  IF A MEM. MGMT. TRAP OCCURS. THE PROGRAM GOES
;*	TO 8$ WHERE THE TRAP IS REPORTED.
;*	
;;******************************************************************
TST27:	SCOPE

161	CLR	PSW		;START IN KERNEL MODE
	MOV	#577,R4		;LOAD R4 WITH VALUE FOR PAR4
	MOV	#600,R5		;LOAD R5 WITH VALUE FOR PARS
	MOV	R4,KIPAR4	;LOAD KERNEL. PAR4
	MOV	R5,KIPAR5	;LOAD KERNEL PARS
	MOV	#UIPAR0,R0	;LOAD ADDRESS OF FIRST USER PAR IN RO
	CLR	R1		;CLEAR R1
	MOV	#7,R2		;LOAD LOOP COUNTER WITH A 7
2$:	MOV	R1,(R0)+	;MAP USER PAR'S TO PAGES 0-6 (4K EACH)
	ADD	#200,R1
	SOB	R2,2$		;LOOP UNTIL UIPARO-UIUIPAR0-UIPAR6ED
	MOV	#7600,(R0)	;MAP uStR PAR7	TO THE I/O PAGE
	MOV	#UIPDR0,R0	;LOAD ADDRESS OF FIRST USER PDR IN RO
	MOV	#77406,R1	;LOAD POP DATA INTO RI
	MOV	#10,R2		;LOAD LOOP COUNTER WITH AN 8
3$:	MOV	R1,(R0)+	;MAP ALL 8 PAGES 128 BLOCKS, UPWARD
	SOB	R2,3$		;       EXPANDABLE, READ/WRITE
	CLRB	UIPDR4		;MAP USER SPACE NON-RESIDENT WHILE
	CLRB	UIPDR5		;	TESTING KERNEL SPACE
	MOV	R5,UIPAR4	;MAP USER PAR'S OPPOSITE OF KIPAR'S
	MOV	R4,UIPARS
	MOV	#1,SR0		;TURN ON MEMORY MANAGEMENT (RELOCATE MODE)
	MOV	#5$,$LPERR	;SET LOOP ON ERROR POINTER TO 5$
	MOV	#8$,MMVEC	;SET M. M. TRAP VECTOR TO 13$
4$:	MOV	PSW,$TMP0	;SAVE PSW IN CASE OF ERROR
	MOV	#100100,R0	;PUT VIRTUAL ADDR. THAT USER PAR4 IN RO
	MOV	#120000,R1	;PUT VIRTUAL ADDR. THAT USES PAR5 IN RI
5$:	MOV	R0,(R0)		;WRITE TO TEST LOC. USING PAR4	
	MOV	(R1),R2		;READ THE SAME LOC., BUT USING PARS	
	CMP	R0,R2		;DID WE READ WHAT WE WROTE?	
	BEQ	6$		;BRANCH	IF YES	
	MOV	R1,VIRT2	;SAVE VIRTUAL ADDR. THAT SELECTED PARS	
	MOV	R0,VIRT1	;SAVE VIRTUAL ADDR. THAT SELECTED PAR4	
	JSR	PC,FORMPA	;GO FORM PHYSICAL ADDRESS BEING USED 
	ERROR	20		;READING LOC. USING PARS AND A VIRT.	
				;ADDR. DID NOT FIND DATA WRITTEN WHEN USING	
				;PAR4 AND VIRT.	ADDRESS.	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 5$" = 000765	
	MOV	VIRTI,R0	;RESTORE VBA IN R0
6$:	ADD	#100,R0		;CHANGE VIRTUAL ADDRS. TO POINT TO NEXT BLOCK	
	ADD	#100,R1	
	CMP	RI,#127700	;WERE BLOCKS FROM 80000-878000 ALL TRIED?	
	BNE	5$		;BRANCH IF ND	
	BIT	#140000,PSW	;HAVE WE DONE TEST IN USER MODE YET?	
	BNE	7$		;BRANCH IF YES	
	MOV	R4,UIPAR4	;LOAD USER PAR4	
	MOV	R5,UIPAR5	;LOAD USER PARS	
	MOVB	#6,UIPDR4	;MAP USER SPACE R/W TO TEST IT	
	MOVB	#6,UIPDR5	
	CLRB	KIPDR4		;MAP KERNEL SPACE NON-RESIDENT WHILE	
	CLRB	KIPDR5		;	TESTING USER SPACE	
	MOV	R5,KIPAR4	;MAP KERNEL PAR'S OPPOSITE UIPAR'S	
	MOV	R4,KIPARS	
	MOV	#140000,PSW	;GO TO USER MODE	
	BR	4$		;GO BACK AND READ/WRITE IN USER MODE	
7$:	CLR	PSW		;GO BACK TO KERNEL MODE BEFORE LEAVING	
	MOV	#77406,KIPDR4	;REMAP KERNEL PAGES READ/WRITE	
	MOV	#77406,KIPDRS	
	MOV	R5,KIPAR4	;MAP KERNEL AND USER PAR'S 4 & 5	
	MOV	R5,KIPAR5	;  BACK TO 12-16K	
	MOV	R5,UIPAR4	
	MOV	R5,UIPAR5	
	MOV	#MGMERR,MMVEC	;RESTORE ADDR. OF NORMAL M.M. TRAP ROUTINE	
	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$	
	BR	TST30		;;G0 TO NEXT TEST	

8$:	MOV	(KSP)+,TRAPPC	;SAVE PC & PS OF TRAP	
	MOV	(KSP)+,TRAPPS	
				;PROGRAM WILL TRAP TO HERE IF TRY	
				;TO USE USER PDR'S WHEN IN KERNEL MODE	
				;OR KERNEL PDR'S WHEN IN USER MODE	
	MOV	R0,VIRT1	;SAVE VIRTUAL ADDRESS FOR ERROR REPORT	
	JSR	PC,FORMPA	;GO FORM THE PHYSICAL ADDRESS	BEING USED	
	MOV	SR0,WASSR0	;SAVE SR0 & SR2	FOR ERROR REPORT	
	MOV	SR2,WASSR2	
	BIC	#160000,SR0	;CLEAR ERROR BITS IN SR0	
	ERROR	52		;M.M. TRAP WHILE IN RELOCATE MODE -	
				;REFERENCED WRONG SET OF PDR'S	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;A "NOP" = 000240	

	MOV	TRAPPS,-(KSP)	;PUT PC & PS OF TRAP ON STACK
	MOV	TRAPPC,-(KSP)
	RTI			;RETURN TO TEST


;;*************************************************************** 
;*TEST 30	W-BIT LOGIC TEST, KERNEL PDR'S
;*
;*	THIS TEST WRITES TO EIGHT (8) DIFFERENT VIRTUAL ADDRESSES
;*	(VBA'S = 17776,37776,57776,77776,117776,137776,157776, & 177776
;*	& PBA'S CONSTRUCTED = 17776,37776,57776,77776,77776,
;*	77776,77776, & 777776 RESPECTIVELY).
;*	WHICH SHOULD CAUSE THE "W-BIT" TD SET IN EACH OF THE
;*	EIGHT (8) KERNEL PAGE DESCRIPTOR REGISTERS.  THE PDR'S
;*	ARE CHECKED TO SEE THAT IT'S W-BIT DOES SET WHEN THE
;*	PAGE IT	IS MAPPED TO IS WRITTEN TO AND THAT THE W-BIT
;*	DOES NOT SET IN ANY OF THE OTHER PDR'S.	KERNEL PDR'S 3,4,5,6
;*	ARE MAPPED TO 12-16K FOR THIS TEST.  ALSO THE W-BIT
;*	SHOULD BE CLEARED WHEN THE PDR IS WRITTEN TO.  THE
;*	W-BIT PORTION OF THE PDR'S AND THE PAR/PDR ADRS MUX
;*	ARE BEING CHECKED.
;;***************************************************************
TST30:	SCOPE
1$:
	JSR	PC,TOFF		;TURN T-BIT TRAPPING OFF FOR THIS TEST
	MOV	#4,R2		;SET LOOP COUNTER TO 4
	MOV	#KIPAR3,R0	;LOAD ADDRESS OF PAR3 INTO RO
	MOV	#600,R1		;LOAD "12-16K"	PAR VALUE INTO R1
2$:	MOV	RI,(R0)+	;MAP PARS 3-6 TO 12-16K
	SOB	R2,2$		;LOOP TIL ALL 4 OF THEM LOADED
	MOV	#KIPDR0,R5	;LOAD ADDRESS OF FIRST PDR TO BE TESTED IN R5
	MOV	#10,R4		;SET LOOP COUNTER TO 8
	MOV	#17776,R3	;INITIALIZE VIRTUAL ADDRESS TO BE IN R3
	MOV	#3$,$LPERR	;SET LOOP ON ERROR POINTER TO 3$
3$:	MOV	#KIPDR0,R0	;LOAD ADDR. OF FIRST PDR TO BE SETUP IN R0
	MOV	#10,R2		;SET LOOP COUNTER TO 8
	MOV	#77406,R1	;PUT "W-BIT OFF DATA" INTO R1
4$:	MOV	R1,(R0)+	;CLEAR ALL W-BITS BY WRITING TO ALL POPS
	SOB	R2,4$		;LOOP UNTIL ALL OF THEM SETUP
	MOV	(R3),(R3) 	;DO "DATO" TO VIRTUAL ADDR.-SETTING A W-BIT
	BIT	(R5),#WBIT	;DID THAT CAUSE W-BIT TO BE SET?
	BNE	5$		;BRANCH IF YES
	ERROR	21		;W-BIT DID NOT GET SET IN PDR
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 3$" = 000763
	BR	8$		;SKIP CHECKING OTHER PDR'S-ERROR WILL SET W-B/TS
5$:	MOV	#10,R2		;SET LOOP COUNTER TO 8
	MOV	#KIPDR0,R0	;LOAD ADDR. OF FIRST PDR TO BE CHECKED IN R0
6$:	BIT	(R0),#WBIT	;DID W-BIT IN OTHER FORS REMAIN CLEAR?
	BEQ	7$		;BRANCH IF YES
	CMP	R5,R0		;IF W-BIT SET, THEN WAS IT PDR UNDER TEST?
	BEQ	7$		;BRANCH IF YES
	ERROR	22		;W-BIT GOT SET IN MORE THAN ONE PDR
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 3$" = 000750		
7$:	ADD	#2,R0		;POINT R0 TO NEXT FOR TO BE CHECKED		
	SOB	R2,6$		;LOOP UNTIL ALL 8 CHECKED FOR CLEAR W-BIT 
	MOV	R1,(R5)		;WRITE TO THE PDR TESTED TO CLEAR W-BIT		
	BIT	(R5),#WBIT	;DID WRITING PDR CLEAR	THE W-BIT? 
	BEQ	8$		;BRANCH IF YES 
	ERROR	23		;W-BIT DID NOT CLEAR BY WRITING THE PDR 
				;FOR TIGHTER SCOPE LOOP		
				;REPLACE ERROR CALL WITH		
				;"BR 3$" = 000740		
8$:	ADD	#2,R5		;POINT 115 TO THE NEXT PDR TO BE TESTED		
	ADD	#20000,R3	;CHANGE VIRT. ADDR TO REF. NEXT PDR 
	SOB	R4,3$		;LOOP BACK TO 3$ UNTIL ALL 8 PDR'S TESTED 
	MOV	#15,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$		
	JSR	PC,TON		;TURN T-BIT BACK ON FOR NEXT TEST		

;;**************************************************************** 
;*TEST 31	W-BIT LOGIC TEST, USER PDR'S 
;*		
;*	THIS TEST WRITES TO EIGHT (8) DIFFERENT VIRTUAL ADDRESSES		
;*	(VBA'S = 17776,37776,57776,77776,117776,137776,157776 & 177776		
;*	& PBA'S CONSTRUCTED = 17776,37776,57776,77776,77776,
;*	77776,77776, & 777776 RESPECTIVELY).		
;*	WHICH SHOULD CAUSE THE "W-BIT"	TO SET	IN EACH OF THE		
;*	EIGHT (8) USER PAGE DESCRIPTOR REGISTERS.  THE PDR'S 
;*	ARE CHECKED TO SEE THAT	IT'S W-BIT DOES SET WHEN THE		
;*	PAGE IT IS MAPPED TO IS WRITTEN TO AND THAT THE W-BIT		
;*	DOES NOT SET IN ANY OF THE OTHER PIA'S.	USER PDR'S 3,4,5,6 
;*	ARE MAPPED TO 12-16K FOR THIS TEST.  ALSO THE W-BIT		
;*	SHOULD BE CLEARED WHEN THE PDR IS WRITTEN TO.	THE		
;*	W-BIT PORTION OF THE PDR'S AND THE PAR/PDR ADRS MUX		
;*	ARE BEING CHECKED.		
;;***************************************************************		
TST31:	SCOPE		
1$:	MOV	N140000,PSW	;GO TO USER MODE FOR THIS TEST		
	JSR	PC,TOFF		;TURN T-BIT TRAPPING OFF FOR THIS TEST 
	MOV	#4,R2		;SET LOOP COUNTER TO 4		
	MOV	#UIPAR3,R0	;LOAD ADDRESS OF PAR3 INTO R0		
	MOV	#600,R1		;LOAD "12-16K" PAR VALUE INTO R1
2$:	MOV	R1,(R0)+	;MAP PARS 3-6 TO 12-16K		
	SOB	R2,2$		;LOOP TIL ALL 4 OF THEM LOADED		
	MOV	NUIPDR0,R5	;LOAD ADDRESS OF FIRST PDR TO BE TESTED IN R5 
	MOV	#10,R4		;SET LOOP COUNTER TO 8 
	MOV	#17776,93	;INITIALIZE VIRTUAL ADDRESS TO BE IN R3 
	MOV	#3$,$LPERR	;SET LOOP ON ERROR POINTER TO 3$		
3$:	MOV	#UIPDR0,R0	;LOAD ALJR.	OF FIRST PDR TO BE SETUP IN R0
	MOV	#10,R2		;SET LOOP COUNTER TO 8		
	MOV	#77406,R1	;PUT "W-BIT OFF DATA" INTO R1		
4$:	MOV	R1,(R0)+	;CLEAR ALL W-BITS BY WRITING TO ALL PDR5 
	SOB	R2,4$		;LOOP UNTIL ALL OF THEM SETUP		
	MOV	(R3),(R3)	;DO "DATO" TO VIRTUAL ADDR.-SETTING A W-BIT 
	BIT	(R5),#WBIT	;DID THAT CAUSE W-BIT TO BE SET?		
	BNE	5$		;BRANCH IF YES		
	ERROR	21		;W-BIT DID NOT GET SET IN PDR		
				;FOR TIGHTER SCOPE LOOP		
				;REPLACE ERROR CALL WITH		
				;"BR 3$" = 000763	
	BR	8$		;SKIP CHECKING OTHER PDR'S-ERROR WILL SET W-BITS
5$:	MOV	#10,R2		;SET LOOP COUNTER TO 8	
	MOV	#UIPDR0,R0	;LOAD ADDR. OF FIRST PDR TO BE CHECKED IN 80	
6$:	BIT	(R0),#WBIT	;DID W-BIT	IN OTHER FORS REMAIN CLEAR?	
	BEQ	7$		;BRANCH	IF YES	
	CMP	R5,R0		;IF W-BIT SET,	THEN WAS IT PDR UNDER TEST?	
	BEQ	7$		;BRANCH	IF YES	
	ERROR	22		;W-BIT GOT SET	IN MORE THAN ONE FOR	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 3$" = 000750	
7$:	ADD	#2,R0		;POINT RD TO NEXT PDR TO BE CHECKED	
	SOB	R2,6$		;LOOP UNTIL ALL 8 CHECKED FOR CLEAR W-BIT	
	MOV	R1,(R5)		;WRITE TO THE PDR TESTED TO CLEAR W-BIT	
	BIT	(R5),#WBIT	;DID WRITING PDR CLEAR THE W-BIT?	
	BEQ	8$		;BRANCH	IF YES	
	ERROR	23		;W-BIT DID NOT CLEAR BY WRITING THE PDR	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 3$" = 000740	
8$:	ADD	#2,R5		;POINT RS TO THE NEXT PDR TO BE TESTED	
	ADD	#20000,R3	;CHANGE VIRT.	ADOR TO REF.	NEXT PDR 
	SOB	R4,3$		;LOOP BACK TO 3$ UNTIL ALL 8 PDR'S TESTED	
	MOV	#15,$LPERR 	;RESET LOOP ON ERROR POINTER TO 1$	
	JSR	PC,TON		;TURN T-BIT BACK ON FOR NEXT TEST	
	CLR	PSW		;BACK TO KERNEL MODE BEFORE LEAVING	

;;***************************************************************	
;*TEST 32	TEST "W-BIT NOT SET" CASES	
;*
;*	THIS TEST CHECKS TWO SPECIAL CASES WHERE THE W-BIT DOES	
;*	NOT GET SET ON A WRITE.	FIRST CASE IS THAT THE W-BIT	
;*	SHOULD NOT SET	IN PAGE DESCRIPTOR REG.	7 WHEN WRITING TO	
;*	STATUS REG SR0 (KERNEL PDR 7 IS USED). SECOND CASE IS THAT	
;`,	THE W-BIT IS NOT SET IF THE "DATO"	IS ABORTED DUE TO AN	
;*	ODD ADDRESS ERROR (KERNEL PDR3 & VIRTUAL ADOR 60001 ARE USED).	
;*	
;;***************************************************************	
TST32:	SCOPE	

1$:	JSR	PC,TOFF		;TURN OFF T-BIT	TRAPPING FOR THIS TEST	
	MOV	#77406,R1	;PUT "W-BIT OFF" VALUE FOR PDR IN R1
	MOV	#25,$LPERR	;SET LOOP ON ERROR POINTER TO 26 
2$:	MOV	R1,KIPDR7	;LOAD KERNEL PDR 7 TO CLEAR W-BIT	
	MOV	SR0,R0		;READ PRESENT CONTENTS OF STATUS REG.	0	
	MOV	R0,SR0		;WRITE PRESENT CONTENTS OF SR0 BACK TO ITSELF	
	MOV	KIPDR7,R2	;READ CONTENTS OF KIPDR7 INTO R2	
	CMP	R1,R2		;WAS W-BIT LEFT CLEARED?	
	BEQ	3$		;BRANCH	IF YES	
	ERROR	24		;W-BIT	IN KIPDR7 SET WHEN SR0 WAS WRITTEN TO	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 2$" = 000765	
3$:	MOV	#3$,$LPERR	;SET LOOP ON ERROR POINTER TO 3$	
	MOV	R1,KIPDR3	;LOAD KERNEL PDR3 WITH 77406 TO CLEAR W-BIT 
	MOV	#4$,ERRVEC	;SET UP	LOC. 4 TO 4$ FOR ODD ADDR. ABORT 
	INC	60001		;CAUSE ODD ADDRESS ABORT THRU LOC. 4 
4$:	MOV	#KERSTK,KSP	;RESTORE THE STACK POINTER		
	MOV	KIPDR3,R2	;READ KIPDR3	INTO 62		
	CMP	R1,R2		;WAS W-BIT	LEFT	CLEARED?		
	BEQ	5$		;BRANCH	IF YES		
	ERROR	25		;W-BIT GOT SET DURING AN ODD ADDR. ABORT 
				;FOR TIGHTER SCOPE LOOP		
				;REPLACE ERROR CALL WITH		
				;"BR 3$" = 000757		
5$:	MOV	#TIMERR,ERRVEC	;RESTORE NORMAL CPU TRAP ROUTINE TO LOC.4 
	MOV	#1$,$LPERR	;RESET	LOOP ON	ERROR POINTER TO 1$ 
	JSR	PC,TON		;TURN T-BIT TRAPPING BACK ON		

;;********************************************************************
;*		
;*	THE NEXT THREE (3) TESTS CAUSE MEMORY MANAGEMENT ERRORS		
;*	TO CHECK THE ABILITY OF STATUS REGISTER 0 TO RECORD KT		
;*	ERRORS AND THE ABILITY OF STATUS REGISTER 2 TO LOCK UP THE		
;*	VIRTUAL ADDR. OF THE INSTRUCTION THAT CAUSED THE ERROR. 
;*	THE BITS OF SR2 ARE CHECKED AND BITS (15:13>, <6:5>, AND <3:0> 
;*	ARE CHECKED IN SR0. SO THE SR0 AND SR2 LOGIC AND THE		
;*	KT ERROR LOGIC ARE CHECKED.		
;*		
;;******************************************************************** 

;;********************************************************************
;*TEST 33	NON-RESIDENT ABORT TEST	(ACF=0&4) 
;*		
;*	THIS TEST CHECKS THE ACCESS CONTROL FIELD (ACF)	COMPARATOR		
;*	LOGIC BY CAUSING NON-RESIDENT ABORTS IN BOTH KERNEL AND		
;*	USER MODES. PDR 4 IS LOADED WITH ACF'S = 0&4 AND		
;*	THEN PHYSICAL ADDR. 60000 IS ACCESSED TO CAUSE THE ABORT.		
;*		
;;********************************************************************
TST33:	SCOPE		

1$:	MOV	#600,R0		;LOAD DATA FOR	PAR'S	INTO R0		
	MOV	R0,KIPAR3	;MAP KERNEL PAR'S 384 TO 12-16K 
	MOV	R0,KIPAR4		
	MOV	R0,U1PAR3	;MAP USER PAR'S 364 TO 12-16K		
	MOV	R0,UIPAR4		
	MOV	#77406,KIPDR3	;MAP KERNEL PDR 3 128 BLKS, READ-WRITE 
	MOV	#77406,UIPDR3	;MAP USER PDR 3	128 BLKS, READ-WRITE		
	MOV	#60000,R0	;LOAD VIRTUAL ADDR. TO REFERENCE PDR3 INTO R0	
	MOV	#100000,61	;LOAD VIRTUAL ADDR. TO REFERENCE PDR4 INTO R1
	MOV	#100011,R3	;LOAD R3 WITH WHAT SR0 SHOULD READ - N.R.. KERNEL, PG.4
	MOV	#77400,R2	;LOAD ACF=0 (NON-RESIDENT) PDR VALUE IN R2 
2$:	MOV	#5$,MMVEC	;POINT MEM. MGMT. TRAP VECTOR TO 5$ BELOW 
	MOV	R2,KIPDR4	;LOAD ACF TEST VALUE INTO KIPDR4 
	MOV	R2,UIPDR4	;LOAD ACF TEST VALUE INTO UIPDR4 
	MOV	#3$,$LPERR	;SET LOOP ON ERROR POINTER TO 3$ 
3$:	CLR	(R0)		;CLEAR PHYS.	LOC.	60000 USING PDR3 
	MOV	PSW,$TMP0	;SAVE PSW IN CASE OF ERROR		
4$:	INC	(R1)		;TRY TO REF. IT USING PDR4 - SHOULD TRAP TO 5$ 
	ERROR	26		;MEM. MGMT. ABORT DID NOT OCCUR		
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 3$"	=	000772	
	BR	8$		;BRANCH AROUND STATUS REG CHECKS IF ND ABORT	
5$:	ADD	#4,SP		;RESTORE STACK	POINTER	
	TST	(R0)		;DID INSTRUCTION GET ABORTED 8 NOT EXECUTE	
	BEQ	6$		;BRANCH	IF YES	
	ERROR	27		;INSTRUCTION WAS NOT ABORTED,	LOC. GOT CHANGED 
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE	ERROR CALL WITH	
				;"BR 3$"	=	000764	
6$:	MOV	SR0,WASSR0	;READ STATUS REGISTER 0	
	MOV	SR2,WASSR2	;READ STATUS REGISTER 2	
	CMP	R3,WASSR0	;DID SR0 REPORT NON-RESIDENT ERROR CORRECTLY?	
	BEQ	7$		;BRANCH	IF YES	
	ERROR	30		;SR0 DID NOT REPORT NON-RES.	ERROR CORRECTLY	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE	ERROR CALL WITH	
				;"BR 30"	=	000752	
7$:	MOV	#4$,R4		;LOAD P4 WITH WHAT SR2 SHOULD READ	
	CMP	R4,WASSR2	;DID SR2 LOCKUP RIGHT VIRTUAL ADDR.	(.46)7	
	BEQ	8$		;BRANCH IF YES	
	ERROR	31		;SR2 DID NOT LOCK VIRTUAL ADDR. OF NON-RES. ERROR 
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE	ERROR CALL WITH	
				;"BR 30"	=	000744	
8$:	BIC	#160000,SR0	;CLEAR	THE	ERROR	BITS	IN	SR0	
	BIT	#140000,$TMP0	HAS ACF=084 BEEN TESTED IN USER YET	
	BNE	9$		;BRANCH IF YES	
	MOV	#100151,R3	;LOAD R3 WITH WHAT SR0 SHOULD READ - N.R.. USER, PG.4	
	MOV	#140000, POW	;GO TO USER MODE	
	BR	2$		;REPEAT TEST	IN USER MODE	
9$:	CMP	#77404,R2	HAS ACF=4 BEEN TESTED YET?	
	BEQ	10$		;BRANCH	IF YES	
	MOV	#77404,R2	;THEN LOAD ACF=4	(NON-RES)	P09 VALUE IN R2	
	MOV	#0100011,R3	;LOAD R3 WITH WHAT SR0 SHOULD READ-N.R..KERNEL,PG.	4	
	CLR	POW		;GO BACK TO KERNEL MODE	
	BR	2$		;GO BACK & TEST ACF=4 IN SAME MODE	
10$:	CLR	POW		;GO BACK TO KERNEL MODE BEFORE	LEAVING	
	MOV	#1$,$LPERR	;RESET	LOOP ON ERROR POINTER TO 1$	
	MOV	#MGMERR,MMVEC	;RESTORE ADDRESS OF NORMAL MEMORY	
				;MANAGEMENT ERROR ROUTINE TO MMVEC	

;;***************************************************************	
;*TEST 34	READ-ONLY ABORT	TEST (ACF=2)
;*	
;*	THIS TEST CHECKS THE ACCESS CONTROL FIELD (ACF) COMPARATOR	
;*	LOGIC BY CAUSING READ-ONLY ABORTS IN BOTH KERNEL AND	
;*	USER MODES.  PDR 4 IS LOAD WITH ACF=2 AND THEN	
;*	PHYSICAL ADDR. 60000 IS WRITTEN TO CAUSE THE ABORT.	
;*				
;;***************************************************************
TST34:	SCOPE	
1$:				;KERNEL & USER PAR'S 3 & 4 AND PDR 3	
				;ARE SETUP FROM LAST TEST	
	MOV	#60000,R0	;LOAD VIRTUAL ADDR.	TO REFERENCE PDR3 INTO R0 
	MOV	#100000,R1	;LOAD VIRTUAL ADDR.	TO REFERENCE PDR4 INTO RI
	MOV	#20011,R3	;LOAD R3 WITH WHAT SR0 SHOULD READ - R/O. KERNEL, PG.4
	MOV	#77402,R2	;LOAD ACF.2 (READ-ONLY)	PDR VALUE IN R2
2$:	MOV	#55,MMVEC	;POINT MEM. MGMT. TRAP VECTOR TO 5$ BELOW
	MOV	R2,KIPDR4	;LOAD ACF.2 INTO KIPDR4
	MOV	R2,UIPDR4	;LOAD ACF=2	IN-J UIPDR4
	MOV	#3$,$LPERR	;SET LOOP ON ERROR POINTER TO 3$
3$:	CLR	(R0)		;CLEAR PHYS.	LOC. 60000 USING P0R3
	MOV	PSW,$TMP0	;SAVE PSW IN CASE OF ERROR
4$:	INC	(R1)		;TRY TO WRITE USING PDR4 - SHOULD TRAP TO 5$
	ERROR	26		;MEM. MGMT.	ABORT DID NOT OCCUR
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 3$"	= 000772
	BR	8$		;BRANCH AROUND STATUS REG. CHECKS IF NO ABORT
5$:	ADD	#4,SP		;RESTORE STACK POINTER
	TST	(R0)		;DID INSTRUCTION GET ABORTED & NOT EXECUTE
	BEQ	6$		;BRANCH IF YES
	ERROR	27		;INSTRUCTION WAS NOT ABORTED, LOC. GOT CHANGED
				FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 35"	= 000764
6$:	MOV	SR0,WASSR0	;READ STATUS REG. 0
	MOV	SR2,WASSR2	;READ STATUS REG. 2
	CMP	R3,WASSR0	;DID SR0 REPORT READ-ONLY ERROR CORRECTLY?
	BEQ	7$		;BRANCH 'F YES
	ERROR	30		;SR0 DID NOT REPORT 8/0 ERROR CORRECTLY
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;.BR 3$.	= 000752
7$:	MOV	#4$,R4		;LOAD R4 WITH WHAT SR2 SHOULD READ
	CMP	R4,WASSR2	;DID SR2 LOCKUP RIGHT VIRTUAL ADDR.	(=AS)?
	BEQ	8$		;BRANCH IF YES
	ERROR	31		;SR2 DID NOT LOCKUP VIRTUAL ADDR. OF R/0 ERROR
				FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 3$.	= 000744
8$:	BIC	#160000,SR0	;CLEAR THE ERROR BITS IN SR0
	BIT	#140000,$TMP0	;HAS ACF=2 BEEN TESTED IN USER MODE?
	BNE	9$		;BRANCH IF YES
	MOV	#20151,R3	;LOAD R3 WITH WHAT SR0 SHOULD READ-R/O, USER. PG.4
	MOV	#140000,PSW	;GO TO USER MODE
	BR	2$		;REPEAT TEST IN USER MODE
9$:	CLR	PSW		;GO BACK TO KERNEL MODE BEFORE LEAVING
	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$
	MOV	#MGMERR,MMVEC	;RESTORE ADDRESS OF NORMAL MEMORY
				;MANAGEMENT ERROR ROUTINE TO MMVEC.
;****************************************************************
;*TEST 35	TEST ILLEGAL MODE "01"
;*	
;*	THIS TEST CHECKS TO SEE THAT A 01 IN THE CURRENT MODE BITS OF THE
;*	PSW WHILE MEMORY MANAGEMENT IS ON IS ILLEGAL.	A
;*	MEMORY MANAGEMENT ABORT SHOULD OCCUR AND STATUS REGISTER 0
;*	SHOULD REPORT NON-RESIDENT ABORT, MODE = 01, PAGE = 1 (100043).	STATUS
;*	REGISTER 2 SHOULD LOCKUP THE ADDRESS OF THE INSTRUCTION
;*	THAT LOADED THE PSW.
;*	
;;***************************************************************
TST35:	SCOPE	
1$:	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$	
	MOV	#3$,MMVEC	;LOAD MEM. MGMT. TRAP VECTOR WITH 3$	
2$:	MOV	#40000,PSW	;SET 01	IN PSW CURRENT MODE BITS	
	NOP			;FETCH OF THIS INSTRUCTION SHOULD CAUSE ABORT	
	ERROR	56		;ILLEGAL MODE 01 NOT ABORTED	
				;FOR A TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 2$" = 000773	
	BR	5$		;BRANCH AROUND SR0 & SR2 CHECKS	
3$:	MOV	#KERSTK,SP	;RESTORE STACK POINTER	
	MOV	#100043,R1	;LOAD EXPECTED CONTENTS OR SR0 INTO R1	
	MOV	SR0,WASSR0	;READ CONTENTS OF SR0	
				
	CMP	R1,WASSR0	;DID SR0 REPORT ILLEGAL MODE CORRECTLY?	
	BEQ	4$		;BRANCH IF YES	
	ERROR	57		;SR0 DID NOT REPORT NR ABORT,	PG=1, MODE=01	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 2$" = 000757	
4$:	MOV	#2$,R1		;LOAD EXPECTED CONTENTS OF SR2 INTO R1	
	MOV	SR2,WASSR2	;READ CONTENTS OF SR2	
	CMP	R1,WASSR2	;DID SR2 LOCKUP VIRT.	ADDR OF ABORTED INST.	
	BEQ	5$		;BRANCH IF YES	
	ERROR	36		;SR2 DID NOT LOCKUP VIRT. ADDR. OF ILL. MODE INST.
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 2$"	= 000746	
5$:	BIC 	#160000,SR0	;CLEAR POSSIBLE ERROR BITS IN SR0	
	MOV	#MGMERR,MMVEC	;RESTORE MEM. MGMT. ABORT VECTOR	
	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$	
				
				
				
				
				
				
				
				
				
				
				
				
;;***************************************************************	
;*	
;*	THE NEXT TWO (2) TESTS WILL BE CHECKING THE PAGE LENGTH 
;*	COMPARATORS AND SOME MORE OF THE KT ERROR DETECTION 
;*	AND STATUS LOGIC.  THE PAGE LENGTH FIELD (PLF)	IN KERNEL	
;*	PDR 4 IS VARIED AND FOR EVERY PLF, THREE (3) VIRTUAL	
;*	ADDRESSES ARE READ.  WHILE USING BOTH UPWARD 8 DOWNWARD PAGE	
;*	EXPANSION, ONE OF THOSE THREE VIRTUAL ADDRESSES WILL CAUSE A	
;*	'PAGE LENGTH ABORT. WHILE THE OTHER TWO WON'T.	
;*
;*	STATUS REGISTER 0 & 2 ARE CHECKED WHEN THE PAGE LENGTH	
;*	ABORT DOES OCCUR TO SEE THAT THE ABORT IS REPORTED AND THAT
;*	THE VIRTUAL ADDRESS OF THE INSTRUCTION THAT CAUSED THE ABORT
;*	IS LOCKED UP.
;*
;;***************************************************************
					1.	

;;***************************************************************
;*TEST 36	PAGE LENGTH FAULTS-UPWARD EXPANSION	
;*
;*	THIS TEST VARIES THE PAGE LENGTH FIELD (PLF) IN KERNEL PDR 4
;*	FROM 1 TO 177 AND FOR EACH PLF, THREE VIRTUAL ADDRESSES	(VBA'S)
;*	ARE ACCESSED.  WHEN VBA <12:6> IS LESS THAN OR EQUAL TO PDR <14:8>
;*	NO ABORT SHOULD OCCUR.  WHEN VBA <12:6> IS GREATER THAN PDR <14:8>,
;*	A PAGE LENGTH ABORT SHOULD OCCUR AND BE REPORTED BY SR0 & SR2.
;*	THE PAGE EXPANSION DIRECTION IN THIS TEST IS UPWARD, (THE ED BIT
;*	(BIT 3)	OF PDR 4 = 0).
;*						
;;***************************************************************
TST36:	SCOPE
1$:	MOV	#77406,KIPOR3	;MAKE SURE PDR3 IS DESCRIBED AS R/W
	MOV	#77406,KIPDR5	;MAKE SURE PDRS IS DESCRIBED AS R/W
	MOV	#100000,R0	;LOAD VIRTUAL ADDR.	TO SELECT PDR4 INTO 50
	MOV	#406, R4	;LOAD FIRST PDR VALUE IN R4 (PLF.1. ACF.61
2$:	MOV	#9$,MMVEC	;SETUP M.N. TRAP VECTOR FOR UNEXPECTED ABORTS
	MOV	R4,KIPDR4	;LOAD KIPDR4 WITH PAGE LENGTH VALUE
	MOV	#3$,$LPERR	;SET LOOP ON ERROR POINTER TO 3$
3$:	MOV	#KERSTK,KSP	;MAKE SURE STACK POINTER	IS ALL SET UP
	MOV	(R0),R1		;ACCESS VIRTUAL ADDR.	(VBA < PLF	NO ABORT)
	ADD	#100,R0		;FORM NEXT VIRTUAL ADDRESS IN RO
	MOV	#4$,$LPERR	;SET LOOP ON ERROR POINTER TO 4$
4$:	MOV	#KERSTK,KSP	;MAKE SURE STACK POINTER	IS ALL SET UP
	MOV	(R0),R1		;ACCESS VIRTUAL ADDR.	(VBA=PLF	WO ABORT)
	ADD	#100,50		;FORM NEXT VIRTUAL ADDR IN R0
	CMP	R0,#117700	;HAVE ALL PLF'S BEEN TESTED YET?
	BEQ	10$		;BRANCH IF ALL VBA'S 8 PLF'S HAVE BEEN USED
	MOV	#5$,$LPERR	;SET LOOP ON ERROR POINTER TO 5$
	MOV	#6$,MMVEC	;SETUP M.M. TRAP VECTOR FOR EXPECTED ABORT
5$:	MOV	(R0),R1		;ACCESS VIRTUAL ADDR.	(VBA > PLF - ABORT TO 6$)
	ERROR	33		;EXPECTED PAGE LENGTH ABORT DID NOT OCCUR
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"B5 5$"	= 000776
	BR	8$		;BRANCH AROUND ABORT CHECKS
6$:	MOV	#KERSTK,KSP	;RESTORE STACK POINTER FOLLOWING ABORT
	MOV	SR0,WASSR0	;READ M.M.	STATUS REG.	0
	MOV	SR2,WASSR2	;READ M.N.	STATUS REG.	2
	MOV	#40011,R2	;PUT EXPECTED SR0 CONTENTS IN R2
	CMP	R2,WASSR0	;DID SR0 REPORT PG. LENGTH ABORT, PAGE 4. KERNEL?
	BEQ	7$		;BRANCH	IF YES
	ERROR	34		;SR0 DID NOT REPORT PG.	LENGTH ABORT CORRECTLY
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;.BR 5$.	= 000757
7$:	MOV	#55,R3		;PUT EXPECTED 5R2 CONTENTS IN R3
	CMP	R3,WASSR2	;DID SR2 LOCKUP VIRT. ADDR. OF ABORTED INSTRUCTION?
	BEQ	8$		;BRANCH IF YES	
	ERROR	35		;SR2 DID NOT LOCKUP VIRT. ADDR. OF ABORT CORRECTLY
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 5$" =	000751	
8$:	BIC	#160000,SR0	;CLEAR ERROR BITS IN 5R0	
	ADD	#400,R4		;FORM NEXT PLF VALUE FOR KIPDR4	
	SUB	#100,R0		;FORM FIRST VIRT. ADDR FOR THAT PLF VALUE	
	BR	2$		;BRANCH BACK AND ACCESS 3 VBA'S FOR	
				;THE PLF VALUE JUST	FORMED	
9$:	MOV	(KSP)+,TRAPPC	;SAVE PC 8 PS OF TRAP	
	MOV	(KSP)+,TRAPPS	
	MOV	SR0,WASSR0	;SAVE CONTENTS OF SR0 FOR ERROR	
	MOV	SR2,WA5S52	;SAVE CONTENTS OF SR2 FOR ERROR	
	BIC	#160000,SR0	;CLEAR ERROR BITS IN SR0	
	ERROR	32		;GOT PG. LENGTH ABORT BEFORE IT WAS EXPECTED	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;A "NOP"	= 000240	
	MOV	TRAPPS,-(KSP)	;PUT PC 6 PS OF TRAP ON STACK	
	MOV	TRAPPC,-(KSP)	
	RTI			;RETURN FROM UNEXPECTED ABORT	
				
10$:	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$	
	MOV	#MGMERR,MMVEC	;RESTORE NORMAL M.M. TRAP HANDLER	
				;ADDRESS TO M.M.	TRAP VECTOR	
				
				
;;******************************************************************
;*TEST 37	PAGE LENGTH FAULTS-DOWNWARD EXPANSION	
;*	
;*	THIS TEST VARIES THE PAGE LENGTH FIELD (PLF) IN KERNEL PDR4	
;*	FROM 176 TO 0 AND FOR EACH PLF,	THREE VIRTUAL ADDRESSES	(VBA'S)	
;*	ARE ACCESSED.  WHEN VBA <12:6> IS GREATER THAN OR EQUAL TO PDR <14:B>	
;*	NO PAGE ABORT SHOULD OCCUR.  WHEN VBA <12:6> IS LESS THAN PDR <14:B>	
;*	A PAGE LENGTH ABORT SHOULD OCCUR AND BE REPORTED BY SR0 & SR2.	
;*	THE PAGE EXPANSION DIRECTION IN THIS TEST IS DOWNWARD, (THE ED BIT	
;*	(BIT 3)	OF PDR4=1).	
;*	
;;******************************************************************
TST37:	SCOPE	
1$:	MOV	#117700,R0	;LOAD VIRTUAL ADDS.	TO SELECT PDR4 INTO R0
	MOV	#77016,R4	;LOAD FIRST PDR VALUE IN R4	(PLF.176,ACF=6)	
2$:	MOV	#9$,MMVEC	;SETUP M.M. TRAP VECTOR FOR UNEXPECTED ABORTS	
	MOV	R4,KIPDR4	;LOAD KIPDR4 WITH PAGE LENGTH VALUE	
	MOV	#3$,$LPERR	;SET LOOP ON ERROR POINTER TO 3$	
3$:	MOV	#KERSTK,KSP	;MAKE SURE STACK POINTER	IS ALL SET UP	
	MOV	(R0),R1		;ACCESS VIRTUAL ADDR.	(VBA > PLF - NO ABORT)	
	SUB	#100,R0		;FORM NEXT VIRTUAL ADDRESS	IN R0	
	MOV	#4$,$LPERR	;SET	LOOP ON ERROR POINTER TO 4$	
4$:	MOV	#KERSTK,KSP	;MAKE SURE STACK POINTER	IS ALL SET UP	
	MOV	(R0),R1		;ACCESS VIRTUAL ADDR.	(VBA.PLF - NO ABORT)	
	SUB	#100,R0		;FORM NEXT VIRTUAL ADDR.	IN R0	
	CMP	R0,#100000	;HAVE ALL PLF'S BEEN TESTED YET?	
	BEQ	10$		;BRANCH IF ALL VBA'S & PLF'S HAVE BEEN USED	

	MOV	#5$,$LPERR	;SET LOOP ON ERROR POINTER TO 5$	
	MOV	#6$,MMVEC	;SETUP M.M.	TRAP VECTOR FOR EXPECTED ABORT	
5$:	MOV	(R0),R1		;ACCESS VIRTUAL ADDR.	(VBA < PLF - ABORT TO 6$)
	ERROR	33		;EXPECTED PAGE LENGTH ABORT DID NOT OCCUR	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 5$"	= 000776	
	BR	8$		;BRANCH AROUND ABORT CHECKS	
6$:	MOV	#KERSTK,KSP	;RESTORE STACK POINTER FOLLOWING ABORT	
	MOV	SR0,WASSR0	;READ M.M.	STATUS REG.	0	
	MOV	SR2,WASSR2	;READ N.M. STATUS REG. 2	
	MOV	#40011,R2	;PUT EXPECTED SR0 CONTENTS IN R2	
	CMP	R2,WASSR0	;DID SR0 REPORT PG.	LENGTH ABORT.	PG. 4, KERNEL?	
	BEQ	7$		;BRANCH IF YES	
	ERROR	34		;SR0 DID NOT REPORT PG.	LENGTH ABORT CORRECTLY	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 5$"	= 000757
7$:	MOV	#5$,R3		;PUT EXPECTED SR2 CONTENTS IN R3	
	CMP	R3,WASSR2	;DID SR2 LOCKUP VIRT. ADDR. OF ABORTED INSTRUCTION?
	BEQ	8$		;BRANCH IF YES	
	ERROR	35		;SR2 DID NOT LOCKUP VIRT. ADDR. OF ABORT CORRECTLY
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 5$"	= 000751	
8$:	BIC	#160000,SR0	;CLEAR ERROR BITS IN SR0	
	SUB	#400,R4		;FORM NEXT PLF VALUE FOR KIPDR4	
	ADD	#100,R0		;FORM FIRST VIRT. ADDR.	FOR THAT PLF VALUE	
	BR	2$		;BRANCH BACK AND ACCESS 3 VBA'S FOR	
				;THE PLF VALUE JUST FORMED	
9$:	MOV	(KSP)+,TRAPPC	;SAVE PC & PS OF TRAP	
	MOV	(KSP)+,TRAPPS	
	MOV	SR0,WASSR0	;SAVE CONTENTS OF SR0 FOR ERROR	
	MOV	SR2,WASSR2	;SAVE CONTENTS OF SR2 FOR ERROR	
	BIC	#160000,SR0	;CLEAR ERROR BITS IN SR0	
	ERROR	32		;GOT PG.	LENGTH ABORT BEFORE IT WAS EXPECTED	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;A "NOP"	= 000240	
	MOV	TRAPPS,-(KSP)	;PUT PC & PS OF		;RAP ON STACK	
	MOV	TRAPPC,-(KSP)	
	RTI			;RETURN FROM UNEXPECTED ABORT	

10$:	MOV	M1S,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$	
	MOV	NMGMERR,MMVEC	;RESTORE NORMAL M.M. TRAP HANDLER	
				;ADDRESS TO M.M. TRAP VECTOR	


;;****************************************************************
;*TEST 40	SR2 BIT TEST	
;*	
;*	THIS TEST CHECKS THE BITS IN MEMORY MANAGEMENT REGISTER 2 BY	
;*	CAUSING "READ-ONLY ABORTS" AT VIRTUAL ADDRESSES BETWEEN 100000	
;*	TO 111000 (PHYSICAL ADDRESSES 060000-071000).  KIPDR4 IS USED TO EXECUTE
;*	THE FOLLOWING FOUR WORDS OF CODE WHICH ARE MOVED THRU MEMORY:	
;*	010727	MOV	PC,(PC)+  ;THIS INSTRUCTION SHOULD CAUSE A R/0 ABORT	
;*	000000			  ;ITS VIRTUAL ADDR. SHOULD BE LOCKED UP IN SR2
;*	000137	JMP	@#3$	  ;THIS INSTRUCTION IS ALSO MOVED THRU MEMORY
;*	(ADDR. OF 3$)		  ;IN CASE A R/0 ABORT DOES NOT OCCUR.
;*				  ;IN WHICH CASE SR2 WILL NOT CONTAIN CORRECT ADDR.
;*
;;*****************************************************************
TST40:	SCOPE		
1$:	MOV	#600,KIPAR3	;BE SURE PAR3 IS MAPPED TO 12-16K
	MOV	#600,KIPAR4	;BE SURE PAR4 IS MAPPED TO 12-16K
	MOV	#77406,KIPDR3	;MAP PAGE 3	128 BLOCKS,	R/W
	MOV	#77402,KIPDR4	;MAP PAGE 4	128 BLOCKS,	READ-ONLY
	MOV	#60000,50	;LOAD R0 WITH VIRTUAL ADDR. WHICH USES PDR3
	MOV	#100000,91	;LOAD RI WITH VIRTUAL ADDR. WHICH USES PDR4
	MOV	#3$,MMVEC	;SET M.M.	TRAP VECTOR TO 3$
	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$
2$:	MOV	#010727,(R0)+	;LOAD "MOV PC,(PC)+"	INSTRUCTION AT ADDR.
	CLR	(R0)+		;	REACHED THRU PDR/PAR 4.
	MOV	#000137,(R0)+	;LOAD "JMP @#3$" INSTRUCTION AT VIRT.	ADDR.
	MOV	#35,(R0)	;	IN CASE R/0 VIOL. DOES NOT ABORT
	MOV	R1,PC		;TRANSFER PROGPAM EXECUTION TO "PAGE 4 INSTRUCTIONS"
3$:	MOV	#KERSTK,KSP	;RESTORE STACK POINTER
	MOV	SR2,WASSR2	;READ CONTENTS OF STATUS REG 2
	CMP	R1,WASSR2	;WAS ADDR. OF "RELOCATED - R/0 ABORT"	LOCKED UP?
	BEQ	4$		;BRANCH IF YES
	ERROR	36		;SR2 DID NOT LOCK UP VIRTUAL ADDR. OF R/O VIOL.
				FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 2$"	=	000757
4$:	BIC	#160000,SR0	;CLEAR THE ERROR BITS IN SR0
	SUB	#4,R0		;RESET R0 TO POINT TO NEXT VIRT. ADDR. TO LOAD
	ADD	#2,R1		;FORM VIRTUAL ADDR. THAT SHOULD BE LOCKED UP NEXT
	CMP	R1,#111002	;HAVE ALL VBA'S 100000-111000 BEEN TESTED?
	BLO	2$		;BRANCH IF NO

5$:	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$
	MOV	#77406,KIPDR4	;RESTORE PDR4 TO R/W ACCESS
	MOV	#MGMERR,MMVEC	;RESTORE ADDRESS OF NORMAL M.M.
				;TRAP HANDLER TO M.M. VECTOR
						
						
;;***************************************************************
;*TEST	41	MORE CHECKS OF SR0 & SR2
;*
;*	THIS TEST PERFORMS SOME ADDITIONAL CHECKS OF THE SR0 & SR2 LOGIC.
;*	FIRST IT CHECKS THAT SR2 "TRACKS" ALONG ACTING AS A VIRTUAL ADDRESS
;*	PROGRAM COUNTER.  ALSO SR0 & SR2 ARE LOCKED UP BY A PAGE LENGTH
;*	ABORT,	THEN WITHOUT CLEARING SR0'S ERROR BITS.	A 11/0 ABORT IS CAUSED.
;*	SR0 & SR2 SHOULD NOT BE CHANGED BY THE SECOND ABORT AND THE
;*	INFORMATION ABOUT THE PAGE LENGTH ABORT? SOULU STILL BE LOCKED UP.
;*	IN ADDITION A "RESET" IS EXECUTED TO VERIFY THAT SR0 IS CLEARED
;*	AND 5R2 IS UNLOCKED BY A RESET.  AFTER MEMORY MANAGEMENT IS TURNED BACK ON,
;*	SR2 IS CHECKED TO SEE THAT IT IS TRACKING AGAIN.
;*
;;***************************************************************
TST41:	SCOPE
1$:	MOV	#600,KIPAR5	;MAP KERNEL PAGE 5 TO 12-16K
	MOV	#406,KIPDR4	;SETUP PDR4 FOR PAGE LENGTH ABORT
	MOV	#77402,KIPDR5	;SETUP PDRS FOR 8/0 ABORT
	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$
2$:	MOV	SR2,WASSR2	;READ SR2 TO SEE IF	ITS TRACKING
	MOV	#2$,R1		;PUT EXPECTED VIRTUAL	PC	IN R1
	CMP	R1,WASSR2	;DID SR2 CONTAIN VIRTUAL PC AT 2$?
	BEQ	3$		;BRANCH IF YES
	ERROR	41		;SR2 NOT TRACKING CORRECTLY
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR	2$"	=	000767
3$:	MOV	#4$,$LPERR	;SET LOOP ON ERROR POINTER TO 44
4$:	MOV	SR2,WASSR2	;READ SR2 TO SEE IF ITS	TRACKING
	MOV	#4$,R1		;PUT EXPECTED VIRTUAL PC	IN R1
	CMP	R1,WASSR2	;DID SR2 CONTAIN VIRTUAL PC AT 4$
	BEQ	5$		;BRANCH	IF YES
	ERROR	41		;SR2 NOT TRACKING CORRECTLY
				FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR	4$"	=	000767
5$:	MOV	#6$,$LPERR	;SET LOOP ON ERROR POINTER TO 6$
6$:	MOV	#7$,MMVEC	;PUT ADDRESS OF 7$ IN M.M.	TRAP VECTOR
	CLR	$TMP1		;CLEAR ERROR INDICATOR
	INC	@#100500	;CAUSE PAGE LENGTH ABORT - TRAP TO 7$
7$:	MOV	#KERSTK,KSP	;RESTORE STACK POINTER AFTER ABORT
	MOV	SR0,$TMP0	;SAVE SR0'S INFORMATION ON PG.	LGTH.	ABORT
	MOV	SR2,$TMP2	;SAVE SR2'S INFORMATION ON PG.	LGTH. ABORT
	MOV	#8$,MMVEC	;PUT ADDRESS OF 8$ IN M.M.	TRAP VECTOR
	INC	@#120000	;CAUSE R/O ABORT - TRAP TO 6$
8$:	MOV	#KERSTK,KSP	;RESTORE STACK POINTER AFTER ABORT
	MOV	SR0,WASSR0	;READ SR0 FOLLWOING SECOND KT ABORT
	MOV	SR2,WASSR2	;READ SR2 FOLLOWING SECOND KT ABORT
	CMP	$TMP0,WASSR0	IS SR0 STILL HOLDING INFO ON FIRST ABORT?
	BEQ	9$		;BRANCH	IF YES
	INC	$TMP1		;SET ERROR INDICATOR
9$:	CMP	$TMP2,WASSR2	;DOES SR2 STILL HOLD PC OF FIRST ABORT?
	BEQ	10$		;BRANCH IF YES
	INC	$TMP1		;SET ERROR INDICATOR

10$:	TST	$TMP1		;WERE SR0 OR SR2 CHANGED BY A SECOND ABORT?
	BEQ	11$		;BRANCH IF NO
	ERROR	17		;ONE OF STATUS REGS. CHANGED BY SECOND ABORT
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 6$"	= 000726
11$:	CLR	$TMP1		;CLEAR ERROR	INDICATOR
	RESET			;EXECUTE A RESET, APPLYING AN .INIT"
	MOV	SR0,WASSR0	;READ SR0
	TOT	WASSR0		;WAS SR0 CLEARED BY THE RESET?
	BEQ	12$		;BRANCH	IF YES
	INC	$TMP1		;SR0 NOT CLEARED BY A RESET
12$:	MOV	SR2,WASSR2	;READ SR2
	CMP	#12$,WASSR2	WAS SR2 UNLOCKED BY A RESET?
	BEQ	13$		;BRANCH IF YES
	INC	$TMP1		;SR2 NOT UNLOCKED BY A RESET
13$:	TST	$TMP1		;WERE SR0 & SR2 BOTH "RESET" BY A RESET?
	BEQ	14$		;BRANCH	IF YES
	ERROR	40		;SR0 OR 5132 NOT	"RESET"	BY A RESET
				FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 6$"	= 000676
14$:	INC	SR0		;TURN MEMORY MANAGEMENT BACK ON
15$:	MOV	SR2,WASSR2	;READ SR2 TO SEE	IF	ITS TRACKING AGAIN
	MOV	#15$,R1		;PUT EXPECTED VIRTUAL PC	IN R1
	CMP	R1,WASSR2	;DID 5R2 CONTAIN VIRTUAL PC AT 154
	BEQ	16$		;BRANCH	IF YES
	ERROR	41		;SR2 NOT TRACKING CORRECTLY
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 6$"	= 000663
;;********************************************************************

;	ALL CODE WITH A	';+' DESIGNATION IN THE COMMENT INDICATES THAT IT HAS BEEN
;	ADDED TO THE ORIGINAL REV OF THIS DIAGNOSTIC.THESE ENHANCEMENTS OR CORRECTIONS
;	ARE MADE BY THE PRODUCT ENHANCEMENT GROUP (DIAGNOSTICS).	
	
;.********************************************************************
						
						
16$:	MOV	#215,MMVEC	;+SET UP KTVEC FOR NON-RESIDENT ABORT
	MOV	#77400,KIPDR5	;+SET UP KIPDRS FOR NR ABORT
	MOV	#175,$LPERR	L+SET LOOP ON ERROR POINTER
17$:	CLR	$TMP1		;+CLEAR ERROR INDICATOR
20$:	INC	@#130000	;+CAUSE A NON-RESIDENT ABORT
	INC	$TMP1		;+SET ERROR INDICATOR
	MOV	SR0,WASSR0	;+READ SR0
	MOV	SR2,WASSR2	;+READ SR2
	ERROR	65		;+NON-RESIDENT ABORT DID NOT OCCUR
				
				
	CLR	$TMP1		;+CLEAR ERROR	INDICATOR
21$:	MOV	#KERSTK,KSP	;+RESTORE KERNEL STACK POINTER
22$:	TST	SR0		;+TEST FOR THE NR ABORT IN SR0	(BIT 15)
	BPAI	23$		;+IF SET BRANCH

	INC	$TMP1		;+SET ERROR INDICATOR		
	MOV	SR0,WASSR0	;+READ SR0		
	MOV	SR2,WASSR2	;+READ 5R2		
	ERROR	66		;+NR ABORT ERROR DID NOT SET IN SR0 (BIT 15)	
							
							
	CLR	SIMP1		;+CLEAR ERROR	INDICATOR		
23$:	CMP	SR2,#206	;+TEST THAT SR2 FROZE TO THE VIRTUAL		
				;+ADDRESS OF THE NR ABORT INSTR.		
	BEQ	24$		;+IF EQUAL. BRANCH		
	INC	SIMP1		;+ELSE ERROR		
	MOV	SR0,WASSR0	;+READ SR0		
	MOV	SR2,WASSR2	;+READ 5R2		
	ERROR	67		;+SR2 DID NOT CONTAIN THE CORRECT ADDRESS 
							
							
	CLR	$TMP1		;+CLEAR ERROR INDICATOR		
24$:	MOV	#25$,MMVEC	;+SET KTVEC FOR 2ND NR ABORT		
	INC	@#130000	;+CAUSE ABORT		
	INC	$TMPI		;+SET ERROR INDICATOR		
	MOV	SR0,WASSR0	;+READ SR0		
	MOV	SR2,WASSR2	;+READ SR2		
	ERROR	70		;+2ND NR ABORT DID NOT OCCUR		
							
							
	CLR	$TMP1		;+CLEAR ERROR INDICATOR		
25$:	MOV	#KERSTK,KSP	;+RESTORE KERNEL STACK		
	MOV	SR2,WASSR2	;+READ SR2		
	CMP	WASSR2,#20$	;+TEST 5R2 FOR VIRTUAL ADDRESS OF		
				;+OF THE FIRST NON-RESIDENT ABORT		
	BEQ	26$		;+IF EQUAL BRANCH		
				;+ELSE ERROR		
	INC	$TMP1		;+SET ERROR INDICATOR		
	MOV	SR0,WASSR0	;+READ SR0		
	MOV	#20$,CORSR2	;+READ CORRECT SR2 VALUE		
	ERROR	71		;+SR2 DID NOT CONTAIN THE VALUE OF		
				;+THE FIRST NR ABORT		
									
									
	CLR	$TMP1		;+CLEAR ERROR INDICATOR		
26$:	RESET			;+ISSUE	INIT.	CONDITIONS		
	TST	SR0		;+SR0 SHOULD BE CLEAR		
	BEQ	27$		;+IF TRUE BRANCH		
				;+ELSE ERROR		
	INC	$TMP1		;+SET ERROR INDICATOR		
	MOV	SR0,WASSR0	;+READ S:0		
	CLR	CDRSR0		;+SET CORRECT SR0 VALUE FOR ERROR MSG		
	ERROR	72		;+SR0 DID NOT CLEAR AFTER INIT.		
							
							
							
	CLR	$TMP1		;+CLEAR ERROR INDICATOR		
27$:	INC	SR0		;+TURN MEM MANG ON		
30$:	MOV	SR2,WASSR2	;+READ SR2		
	CMP	WASSR2,#30$	;+IS SR2 TRACKING AGAIN		
	BEQ	31$		;+YES. BRANCH		
				;+ELSE ERROR	
	INC	$TMP1		;+SET ERROR INDICATOR	
	MOV	#30$,R1		;+SET CORRECT SR2 VALUE FOE ERROR MSG 11.40$,R1	
	ERROR 	41		;+ERROR,SR2 IS NOT TRACKING CORRECTLY	
				
				
31$:	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$	
	MOV	#77406,KIPDR4	;RESET PDR4 TO 126 BLKS, R/W	
	MOV	#77406,KIPDRS	;RESET PDRS TO 128 BLKS.	R/W	
	MOV	#MGMERR,MMVEC	;RESTORE ADDRESS OF NORMAL MEMORY	
				;MANAGEMENT TRAP ROUTINE TO M.M. VECTOR	
				
				
;;***************************************************************	
;*TEST 42	USER ABORT PICKS UP KERNEL SPACE VECTOR	
;*
;*	THIS TEST CHECKS TO BE SURE THAT WHEN AN ABORT OCCURS WHILE IN	
;*	USER MODE, THE TRAP VECTOR INFORMATION FETCHED IS TAKEN FROM	
;*	KERNEL SPACE.	USER PAGE 0 IS MAPPED TO 12K (60000-77776) SO	
;*	THAT IF USER SPACE IS USED INSTEAD OF KERNEL,	THE NEW PC THAT	
;*	WAS LOADED AT LOC.  060004 IS USED INSTEAD OF THE NEW PC THAT	
;*	SHOULD BE PICKED UP FROM LOC. 000004.  AN ODD ADDRESS ERROR IS USED	
;*	TO CAUSE A TRAP TO "4".	
;*
;;***************************************************************	
TST42:	SCOPE	
1$:	USR	PC,TOFF		;TURN OFF. T-BIT TRAPPING FOR THIS TEST	
	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$	
2$:	CLR	PSW		;GO TO KERNEL MODE	
	MOV	#KERSTK,KSP	;SETUP KERNEL STACK PTR.	
	MOV	#600,UIPAR0	;MAP USER PAGE 0 TO 12K	
	MOV	#46,@#4		;LOAD KERNEL VECTOR 4 (LOC.4) WITH 4$	
	MOV	#340,@#6	;LOAD VECTOR+2 WITH NEW PSW	
	MOV	#140000,PSW	;GO TO USER MODE 	
	MOV	#USESTK,USP	;SETUP USER STACK PTR.	
	MOV	#3$,@#4		;LOAD USER VECTOR 4 (LOC. 60004) WITH 35	
	MOV	#340,@#6	;LOAD VECTOR+2 WITH NEW PSW	
	TST	3$+1		;CAUSE ODD ADDR. ERROR TRAP TO	
				;SHOULD PICK UP NEW PC=4$ FROM KERNEL	
				;LOC. 4, NOT PC=3$ FROM USER LOC. 4 (=60004)	
3$:	MOV	PSW,R1		;SAVE PSW FOR ERROR	
	MOV	SP,R2		;SAVE VALUE OF STACK POINTER FOR ERROR	
	CLR	PSW		;BE SURE BACK IN KERNEL MODE	
	ERROR	42		;DID NOT TRAP THRU KERNEL SPACE	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 2$" = 000740	
4$:	CLR	PSW		;BE SURE BACK IN KERNEL MODE	
	MOV	#KERSTK,KSP	;RESTORE KERNEL S.P.	IN CASE IT CHANGED	
	CLR	UIPAR0		;REMAP USER PAGE 0 TO 0-4K	
	MOV	#140000,PSW	;GO TO L,ER MODE	
	MOV	#USESTK,USP	;RESTORE USER STACK POINTER	
	CLR	PSW		;GO BACK TO KERNEL MODE	
	MOV	#TIMERR,@#4	;RESTORE ADDR. OF NORMAL CPU TRAP HANDLER TO	
	MOV	#1$,$LPERR	;RESET	LOOP ON ERROR POINTER TO 1$	
	JSR	PC,TON		;TURN T-BIT TRAPPING BACK ON	

;;***************************************************************	
;*TEST 43	RTI IN USER MODE DOES NOT CHANGE PSW	
;*	
;*	THIS TEST CHECKS TO SEE THAT WHEN AN RTI IS EXECUTED IN USER	
;*	MODE, THE MODE OR PRIORITY BITS OF THE PSW ARE NOT CHANGED.
;*
;;***************************************************************	
TST43:	SCOPE	
1$:	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$	
	MOV	#170000,R2	;LOAD "PRESENT & EXPECTED" PSW VALUE INTO R2 
2$:	MOV	R2,PSW		;GO 10 USER MODE-PRIORITY 0	
	MOV	#340,-(SP)	;PUT A NEW PSW (PRIORITY=7) ON STACK	
	MOV	#3$,-(SP)	;PUT NEW PC ON THE STACK	
	RTI			;DO AN RTI FROM USER MODE	
3$:	MOV	PSW,R1		;READ NEW PSW INTO R1	
	BIC	#7437,R1	;MASK OFF COND. CODE, T-BIT, AND UNUSED BITS	
	CLR	PSW		;GO BACK TO KERNEL MODE	
	CMP	R2,R1		;DID PSW STAY IN USER,	PRIORITY.0?	
	BEQ	4$		;BRANCH IF YES	
	ERROR	60		;PSW CHANGED BY AN RTI FROM USER	
				;FOR A TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR=2$"	= 000760	
4$:	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$	

;;*************************************************************** 
;*TEST 44	KT ERROR NOT SERVICED IF ODD ADDR. ERROR	
;*	
;*	THIS TEST CHECKS TO SEE THAT IF A CERTAIN VIRTUAL ADDRESS THAT
;*	WOULD CAUSE A MEMORY MANAGEMENT ERROR CAUSES AN ODD ADDRESS
;*	ERROR FIRST, THE ODD ADDRESS ERROR IS SERVICED BUT THE MEMORY
;*	MANAGEMENT ERROR ISN'T.	THIS MEANS THAT SR0 AND SR2
;*	SHOULD NOT REPORT THE ERROR OR LOCK UP ITS VIRTUAL ADDRESS.
;*	A READ-ONLY VIOLATION IS USED AS THE POTENTIAL MEMORY MANAGEMENT
;*	ERROR
;*
;;***************************************************************	
TST44:	SCOPE
1$:	MOV	#600,KIPAR4	;MAP KERNEL PAGE 4 TO 12-16K
	MOV	#77402,R5	;LOAD PDR4 DATA INTO R5
	MOV	R5,KIPDR4	;MAP PAGE 4 READ-ONLY
	MOV	#4$,@#4		;SET CPU TRAP VECTOR TO ADDRESS OF 4$
	MOV	#3$,@#250	;SET M.M.	TRAP VECTOR TO ADDRESS OF 3$
	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$
2$:	INC	60001		;CAUSE ODD ADDR: ERROR & POTENTIAL R/0 ABORT
3$:	ERROR	43		;TRAPPED THRU M.M. VECTOR BUT SHOULDN'T HAVE
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 2$"	= 000776
4$:	MOV	#KERSTK,K5P	;RESTORE STACK POINTER AFTER TRAPPING
	CLR	$TMP1		;CLEAR ERROR	INDICATOR
	MOV	SR0,WASSR0	;READ STATUS REG.	0
5$:	MOV	SR2,WASSR2	;READ STATUS REG.	2
	MOV	#17,R0		;LOAD EXPECTED SR0 CONTENTS INTO RO
	CMP	R0,WASSR0	;SR0	ERROR BITS LEFT CLEAR BY TRAPPING?
	BEQ	6$		;BRANCH IF YES
	INC	$TMP1		;SR0 ERROR BITS SET WHEN ODD ADDR. SERVICED
6$:	MOV	#56,R1		;LOAD EXPECTED SR2 CONTENTS INTO RI
	CMP	R1,WASSR2	;WAS SR2 LEFT UNLOCKED BY TRAPPING?
	BEQ	7$		;BRANCH IF YES
	INC	$TMP1		;SR2 LOCKED UP BY ODD ADDR.	ERROR
7$:	TST	$TMP1		;WHERE SR0 OR SR2 EFFECTED?
	BEQ	8$		;BRANCH IF NO
	ERROR	44		;SR0 OR SR2 CHANGED BY ODD ADDR. ERROR
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 2$"	=	000741
	BIC	#160000,SR0	;CLEAR ERROR BITS THAT MAY BE SET IN SR0
8$:	MOV	#TIMERR,@#4	;RESTORE ADDRESS OF NORMAL CPU TRAP HANDLER
	MOV	#MGMERR,@#250	;RESTORE ADDRESS OF NORMAL M.M. TRAP HANDLER
	MOV	#77406,KIPDR4	;REMAP FIGE 4 TO READ/WRITE
	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO 1$


;;***************************************************************	
;*TEST 45	PC & PSW SAVED FOR KT ERROR DURING SERVICE OF ODD ADDR. ERROR	
;*	
;*	THIS TEST CHECKS THE PC AND PROCESSOR STATUS WORD SAVED WHEN
;*	A KT ERROR OCCURS DURING THE SECOND PUSH ON THE STACK DURING
;*	SERVICING OF AN ODD ADDR.  ERROR. DURING A "DOUBLE ERROR"
;*	SEQUENCE SUCH AS THIS, THE PSW SAVED WILL BE THE ONE PICKED UP
;*	FROM VECTOR+2 (LOC. 6 IN THIS CASE) AFTER THE FIRST TRAP,
;*	NOT THE PSW PRESENT BEFORE THE FIRST TRAP. SR0 AND SR2
;*	SHOULD RECORD THE KT ERROR (A R/O VIOLATION BY THE USER STACK PTR.)
;*
;*	NOTE THAT THE PREVIOUS MODE BITS <13:12> OF THE PSW
;*	WILL BE SET IN THE PSW THAT IS SAVED.
;*
;;***************************************************************
TST45: SCOPE
1$:	JSR	PC,TOFF		;TURN T?BIT TRAPPING OFF FOR THIS TEST
	MOV	#600,UIPAR3	;MAP USER PAGE 3 TO 12-16K
	MOV	#600,UIPAR4	;MAP USER PAGE 4 TO 12-16K
	MOV	#77402,UIPDR3	;MAP USER PAGE 3 READ?ONLY
	MOV	#77406,UIPDR4	;MAP USER PAGE 4 READ/WRITE
	MOV	#4$,@#4		;LOAD ADDRESS OF 4$ IN CPU (ODD ADDR.) VECTOR
	MOV	#140017,@#6	;LOAD PSW THAT SHOULD BE PUT ON STACK IN VECTOR+2
	MOV	#45,@#250	;LOAD ADDRESS OF 4$ IN M.M. TRAP VECTOR
	MOV	#340,@#250	;LOAD A KERNEL PSW IN MMVEC+2
	MOV	#2$,$LPERR	;SET LOOP ON ERROR POINTER TO 2$
2$:	MOV	#140000,PSW	;GO TO USER MODE
	MOV	#100002,USP	;SET USER STACK PTR. SO SECOND PUSH IS IN PG. 3
3$:	INC	100005		;CAUSE ODD ADDRESS ERROR THAT WILL CAUSE
				;R/O ERROR WHEN TO SAVE OLD PC
4$:	MOV	@(KSP),R1	;PUT PSW SAVED ON KERNEL STACK INTO R1
	MOV	(KSP),R3	;PUT PC SAVED ON KERNEL STACK INTO R3
	MOV	SR0,WASSR0	;READ TH7 CONTENTS OF M.M. STATUS REG. 0
	MOV	SR2,WASSR2	;READ THE CONTENTS OF M.M. STATUS REG. 2
	BIC	#160000,SR0	;CLEAR THE ERROR BITS IN SR0
	CLR	PSW		;BE SURE IN KERNEL MODE
	MOV	#KERSTK,KSP	;RESTORE KERNEL STACK POINTER
	MOV	#140000,PSW	;GO TO USER MODE
	MOV	#USESTK,USP	;RESTORE USER STACK POINTER
	CLR	PSW		;GO BACK TOSR0RNEL MODE
	CLR	$TMP0		;CLEAR ERROR INDICATOR
	CMP	R1,9170017	;WAS THE PSW SAVED THE ONE PICKED UP BY THE
				;ODD ADDR. TRAP FROM ERRVEC+2?
				;VALUE 170017 = PSW FROM LOC. 6 WITH
				;PREVIOUS MODE BITS = USER
	BEQ	5$		;BRANCH IF YES
	INC	$TMP0		;WRONG PSW SAVED DURING *DOUBLE ERROR" SEQUENCE
5$:	CMP	R3,#3$+4	;WAS THE PC AT THE TIME OF THE ODD ADDR. ERROR
				;SAVED ON THE STACK?
	BEQ	6$		;BRANCH IF YES
	INC	$TMP0		;WRONG PC SAVED DURING TRAP SEQUENCE
6$:	CMP	WASSR0,#20147	;DID SR0 REPORT ? USER, PAGE 3, R/0 ABORT?
	BEQ	7$		;BRANCH ,F YES
	INC	$TMP0		;SR0 DID NOT REPORT R/0 ABORT
7$:	CMP	WASSR2,#3$	;DID SR2 LOCK UP VIRTUAL ADDR. OF LAST
				;INSTRUCTION SUCCESSFULLY FETCHED?
	BEQ	8$		;BRANCH IF YES
	INC	$TMP0		;SR2 DID NOT LOCK UP ADDR. OF ODD ADDR. INST.
8$:	TST	$TMP0		;ANY "ERRORS" DURING TRAP SEQUENCE?
	BEQ	9$		;BRANCH IF NO
	ERROR	45		;THE WRONG PC OR PSW WERE SAVED
				;OR SR0 DR SR2 DID NOT REPORT R/O 
				;ERROR DURING ODD ADDS. ? KT TRAP 
				;SEQUENCE
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 2$" = 000710
9$:	MOV	#TIMERR,@#4	;RESTORE ADDRESS OF NORMAL CPU TRAP HANDLER
	MOV	#340,@#6	;RELOAD ERRVEC+2 WITH KERNEL PSW
	MOV	#MGMERR,@#250	;RESTORE ADDRESS OF NORMAL M.M. TRAP HANDLER
	MOV	#77406,UIPDR3	;REMAP USER PAGE 3 READ/WRITE
	MOV	#1$,$LPERR	;RESET LOOP ON ERROR POINTER TO IS
	JSR	PC,TON		;TURN T?BIT TRAPPING BACK ON
;;***************************************************************
;*
;*	THIS GROUP OF TESTS WILL TEST ALL THE LOGIC ASSOCIATED WITH
;*	THE "MOVE FROM PREVIOUS" AND MOVE TO PREVIOUS. INSTRUCTIONS.
;*
;;***************************************************************

;;***************************************************************
;*TEST 46	MOVE FROM PREVIOUS (USER) I-SPACE
;*
;*	THIS TEST USES THE 'MFPI' INSTRUCTION TO ENSURE THAT THE
;*	PREVIOUS MODE IS CLOCKED CORRECTLY
;*	THERE IS A DESCRIPTION BEFORE EACH DESTINATION MODE TESTED.
;*
;*
;*	IF THE CORRECT MODE (USER) IS NOT ENABLED A NON?RESIDENT ABORT
;*	WILL OCCUR AND TRAP TO 23$. WHERE THE ERRORS ARE REPORTED.
;*
;;***************************************************************
TST46: SCOPE
1$;	CLR	KIPAR0		;MAP KERNEL PAGE 0 TO 0-4K
	MOV	#200,KIPAR1	;MAP KERNEL PAGE 1 TO 4-8K
	MOV	#400,KIPAR2	;MAP KERNEL PAGE 2 TO 13?I2K
	MOV	#600,KIPAR3	;MAP KERNEL PAGE 3 TO 12-16K
	MOV	#600,KIPAR4	;MAP KERNEL PAGE 4 TO 12-16K
	MOV	#7600,KIPAR7	;MAP KERNEL PAGE 7 TO THE I/O PAGE
	MOV	#77406,R0	;MAKE ALL KERNEL I-SPACE PAGES RESIDENT
				;READ/WRITE, LENGTH 200 BLOCKS
	MOV	#10,R2		;SET LOOP COUNTER TO 8
	MOV	#KIPDR0,R1	;PUT ADDRESS OF FIRST FOR IN R1	
2$:	MOV	R0,(R1)+	;LOAD PDR WITH 77408	
	SOB	R2,2$		;LOOP TO 2$ UNTIL ALL PDRS LOADED	
	MOV	#10,R2		;SET LOOP COUNTER TO 8	
	MOV	#UIPDR0,R1	;PUT ADDRESS OF FIRST PDR IN R1	
3$:	MOV	R0,(R1)+	;LOAD PDR WITH 77406	
	SOB	R2,3$		;LOOP TO 3$ UNTIL ALL PDRS LOADED	
	MOV	#000,UIPAR0	;MAP USER I PAGE 0 TO 0-4K	
	MOV	#200,UIPAR1	;MAP USER I	PAGE 1	TO 4-BK	
	MOV	#400,UIPAR2	;MAP USER I PAGE 2 TO 8-12K	
	MOV	#600,UIPAR3	;MAP USER I PAGE 3 TO 12-16K	
	MOV	#7600,UIPAR7	;MAP USER I PAGE 7 TO THE I/O PAGE	
	MOV	#4$,$LPERR	;SET LOOP ON ERROR TO 4$	
4$:		
	MOV	#77406,KIPDR4	;KERNEL I-SPACE PAGE 4 READ/WRITE	
	MOV	#600,KIPAR4	;MAP KERNEL 1	PAGE 4 TO 12K	
	MOV	#600,UIPAR4	;MAP USER I	PAGE 4 TO 12K	
	MOV	#36514,R0	;LOAD DATA PATTERN INTO R0	
	MOV	R0,@#100000	;LOAD DATA PATTERN INTO PHY 60000	
	MOV	#23$,MMVEC	;SET M.M.	VECTOR TO 23$	
	CLRB	KIPDR4		;MAKE KERNEL I-SPACE PAGE 4 NON-RESIDENT	
	;THE FOLLOWING WILL TEST DSTM=0 MFPI	
	;		
	MOV	#5$,$LPERR	;SET LOOP ON ERROR POINTER TO 5$	
5$:	MOV	#030340,PSW	;MAKE PREVIOUS MODE USER	
6$:	MFPI	USP		;PUT USER STACK POINTER ON KERNEL	
				;STACK	
	CMP	#KERSTK,KSP	;WAS SOMETHING PUSHED ON STACK AT 6$	
	BEQ	7$		;BRANCH IF NOTHING WAS PUSHED	
	MOV	(KSP)+,R0	;POP KERNEL STACK INTO R0
	MOV	#USESTK,R1	;EXPECTING TO GET 700 AS USP	

	CMP	R0,R1		;DID YOU GET THE RIGHT POINTER?
	BEQ	8$		;BRANCH	IF YOU DID
	ERROR	46		;WRONG THING WAS PUSHED ON STACK
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 5$"	= 000763
	BR	8$		;BRANCH TO NEXT TRY
7$:	ERROR	50		;NOTHING PUSHED ON STACK
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 5$"	=	000761
8$:	;THE FOLLOWING WILL TEST DSTM=1 MFPI.
	MOV	#9$,$LPERR	;SET LOOP ON ERROR POINTER TO 9$
	MOV	#36514,R0	;RELOAD DATA PATTERN IN RO
9$:	MOV	#030340,PSW	;MAKE PREVIOUS MODE USER
	MOV	#100000,R2	;LOAD VIRTUAL ADDRESS INTO R2
	MFPI	(R2)		;READ FROM PHYSICAL 60000
	MOV	(KSP)+,R1	;POP KERNEL STACK INTO R1
	CMP	R0,R1		;WAS DATA FETCHED SAME AS STORED
	BEQ	10$		;BRANCH IF CORRECT DATA WAS FETCHED
	ERROR	46		;WRONG DATA WAS FETCHED
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 9$"	= 000766
10$:	;THE FOLLOWING WILL TEST DSTM=2 MFPI.
	MOV	#11$,ALPERR	;SET LOOP ON ERROR POINTER TO 11$
11$:	MOV	#030340,PSW	;MAKE PREVIOUS MODE USER
	MOV	#100000,R2	;LOAD VIRTUAL ADDRESS INTO R2
	MFPI	(R2)+		;READ FROM PHYSICAL 60000
	MOV	(KSP)+,R1	;POP KERNEL STACK INTO R1
	CMP	R0,R1		;WAS DATA FETCHED SAME AS STORED
	BEQ	12$		;BRANCH IF CORRECT DATA WAS FETCHED
	ERROR	46		;WRONG DATA WAS FETCHED
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 11$"	= 000766
12$:	;THE FOLLOWING WILL TEST DSTM=3 MFPI.		

	MOV	#13$,$LPERR	;SET LOOP ON ERROR POINTER TO 13$	
13$:	MOV	#030340,PSW	;MAKE PREVIOUS MODE USER	
	MFPI	@#100000	;READ FROM PHYSICAL 60000	
	MOV	(KSP)+,R1	;POP KERNEL STACK INTO RI	
	CMP	R0,R1		;WAS DATA FETCHED SAME AS STORED	
	BEQ	14$		;BRANCH IF CORRECT DATA WAS FETCHED	
	ERROR	46		;WRONG DATA WAS FETCHED	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR	13$"	=	000767		
14$:	;THE FOLLOWING WILL TEST DSTM=4 MFPI.		
	MOV	#15$,$LPERR	;SET LOOP ON ERROR POINTER 70 15$		
15$:	MOV	#030340,PSW	;MAKE PREVIOUS MODE USER		
	MOV	#100002,R2	;LOAD VIRTUAL ADDRESS INTO R2		
	MFPI	-(R2)		;READ FROM PHYSICAL 60000		
	MOV	(KSP)+,111	;POP KERNEL STACK INTO R1		
	CMP	R0,R1		;WAS DATA FETCHED SAME AS STORED		
	BEQ	18$		;BRANCH IF CORRECT DATA WAS FETCHED		
	ERROR	46		;WRONG DATA WAS FETCHED		
				;FOR TIGHTER SCOPE LOOP		
				;REPLACE ERROR CALL WITH		
				;"BR 15$"	= 000766		
16$:					
	;THE FOLLOWING WILL TEST DSTM=5 MFPI.		
	;							
	MOV	#17$,$LPERR	;SET LOOP ON ERROR POINTER TO 17$ 
17$:	MOV	#030340,PSW	;MAKE PREVIOUS MODE USER		
	MOV	#100000,$TMP2	;LOAD TEST LOC.	VIRT.	ADDR INTO LOC.	$TMP2	
	MOV	#<$TMP2+2>,R2	;LOAD ADDR. OF $TMP2+2 INTO R2		
	MFPI	@-(R2)		;READ FROM PHYSICAL 60000		
	MOV	(KSP)+,R1	;POP KERNEL STACK INTO R1		
	CMP	R0,R1		;WAS DATA FETCHED SAME AS STORED		
	BEQ	18$		;BRANCH IF CORRECT DATA WAS FETCHED		
	ERROR	46		;WRONG DATA WAS FETCHED		
				;FOR TIGHTER SCOPE LOOP		
				;REPLACE ERROR CALL WITH		
				;"BR 17$"	= 000763		
18$:	;THE FOLLOWING WILL TEST DSTM=6 MFPI.		
	;
	MOV	#19$,$LPERR	;SET LOOP ON ERROR POINTER TO 19$ 
19$:	MOV	#030340,PSW	;MAKE PREVIOUS MODE USER		
	CLR	R2		;MAKE REGISTER 2 A ZERO		
	MFPI	100000(R2)	;READ FROM PHYSICAL 60000		
	MOV	(KSP)+,R1	;POP KERNEL STACK INTO RI		
	CMP	R0,R1		;WAS DATA FETCHED SAME AS STORED		
	BEQ	20$		;BRANCH IF CORRECT DATA WAS FETCHED		
	ERROR	46		;WRONG DATA WAS FETCHED		
				;FOR TIGHTER SCOPE LOOP		
				;REPLACE ERROR CALL WITH		
				;"BR	19$"	= 000766		
20$:	;THE FOLLOWING WILL TEST DSTM=7 MFPI.		
	;
	MOV	#21$,$LPERR	;SET LOOP ON ERROR POINTER TO 21$		
21$:	MOV	#030340,PSW	;MAKE PREVIOUS MODE USER		
	MOV	#100000,$TMP2	;LOAD TEST LOC.	V.A.	INTO $TMP2		
	MOV	#$TMP2,R2	;LOAD ADDRESS OF $TMP2 INTO R2		
	MFPI	@0(R2)		;USE $TMP2 TO FETCH VIRTUAL		
				;ADDRESS OF 60000		
	MOV	(KSP)+,R1		;POP KERNEL STACK INTO RI		
	CMP	R0,R1		;WAS DATA FETCHED SAME AS STORED		
	BEG	22$		;BRANCH IF CORRECT DATA WAS FETCHED		
	ERROR	46		;WRONG DATA WAS FETCHED		
				;FOR TIGHTER SCOPE LOOP		
				;REPLACE ERROR CALL WITH		
				;"BR 21$"	= 000762		

22$:	MOV	#MGMERR,MMVEC	;SET M.M. VECTOR TO NORMAL ROUTINE	
	MOV	#15,$LPERR	
	BR	TST47		;SET LOOP POINTER TO START OF TEST	
				;;BRANCH TO NEXT TEST	


23$:	MOV	(KSP)+,TRAPPC	;SAVE PC & PS OF TRAP	
	MOV	(KSP)+,TRAPPS	
	MOV	SR0,WASSR0	;SAVE SR0 FOR ERROR TYPEDUT	
	MOV	SR2,WASSR2	;SAVE SR2 FOR ERROR TYPEDUT	
	BIC	#160000,5R0	;CLEAR ERROR BITS IN SR0 AND LEAVE	
	ERROR	51		;TRIED TO READ NONRESIDENT PAGE	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;A "NOP"	= 000240	
	MOV	TRAPPS,-(KSP)	;PUT PC & PS OF TRAP ON STACK	
	MOV	TRAPPC,-(KSP)	
	RTI	


;;******************************************************************
;*TEST 47	MOVE TO PREVIOUS (USER) I-SPACE	
;*	
;*	THIS TEST USES THE 'MTPI' INSTRUCTION TO ENSURE THAT THE	
;*	PREVIOUS MODE IS CLOCKED CORRECTLY	
;*	THERE IS A DESCRIPTION BEFORE EACH DESTINATION MODE TESTED,	
;*	
;*
;*	IF THE CORRECT MODE IS NOT ENABLED A NON-RESIDENT ABORT	
;*	WILL OCCUR AND TRAP TO 20$, WHERE THE ERRORS ARE REPORTED.	
;*
;;***************************************************************	
TST47:	SCOPE	
1$:	MOV	#77406,KIPDR4	;KERNEL I-SPACE PAGE 4 READ/WRITE	
	MOV	#77406,UIPOR4	;USER I-SPACE PAGE 4 READ/WRITE	
	MOV	#600,KIPAR4	;MAP KERNEL I PAGE 4 TO 12K	
	MOV	#600,UIPAR4	;MAP USER I PAGE 4 TO 12K	
	MOV	#20$,MMVEC	;SET M.M. VECTOR TO 20$	
	;THE FOLLOWING WILL TEST DSTM=0 MTPI	
	;	
2$:	MOV	#030340,PSW	;MAKE PREVIOUS :,ODE USER	
	MOV	#7777,-(KSP)	;PUSH DATA ON KERNEL STACK	
	MTPI	USP		;LOAD USER STACK POINTER	
	MFPI	USP		;READ USER STACK POINTER	
	MOV	(KSP)+,R1	;POP KERNEL STACK INTO RI	
	CMP	#7777,R1	;WAS USER STACK POINTER CHANGED	
	BEG	3$		;BRANCH IF IT WAS	
	ERROR	50		;USER STACK POINTER NOT CHANGED	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 25"	= 000764	
3$:	MOV	#030340,PSW	;MAKE PREVIOUS MODE USER	
	MOV	#USESTK,-(KSP)	;GET READY TO RESTORE USER 5.	POINT	
	MTPI	USP		;RESTORE USER STACK POINTER	
4$:	;THIS WILL TEST DSTM = 1 MTPI.	
	MOV	#4$,$LPERR	;SET LOOP ON ERROR POINTER TO 5$	
	MOV	#100000,R2	;LOAD VIRTUAL ADDRESS INTO R2	

	MOV	#125252,R0	;LOAD TEST DATA INTO R0	
5$:	MOV	R0,-(KSP)	;PUSH TEST DATA ON KERNEL STACK	
	CLRB	KIPDR4		;MAKE KERNEL I PAGE 4 NON-RESIDENT	
	MTPI	(R2)		;LOAD TEST DATA INTO PHYSICAL 60000	
	MOVB	#006,KIPDR4	;MAKE KERNEL PAGE 4 RESIDENT	
	MOV	(R2),R1		;READ FROM ADDRESS 60000	
	CMP	R0,R1		;SEE IF DATA WAS STORED AT CORRECT PLACE	
	BEO	8$		;BRANCH IF STORE WAS CORRECT	
	ERROR	47		;INCORRECT STORE	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 55"	= 000765	
6$:	;THE FOLLOWING WILL TEST DSTM=2 MTPI.	
	;
	MOV	MOS,$LPERR	;SET LOOP ON ERROR POINTER TO 8$	
	MOV	#030340,PSW	;MAKE PREVIOUS MODE USER	
	MOV	#125252,R0	;LOAD TEST DATA INTO R0
	MOV	#100000,R2	;LOAD VIRTUAL ADDRESS INTO R2	
8$:	MOV	R0,-(KSP)	;PUSH TEST DATA ON KERNEL STACK	
	CLRB	KIPDR4		;MAKE KERNEL PAGE 4 NON-RESIDENT	
	MTPI	(R2)		;LOAD TEST DATA INTO PHYSICAL 80000	
	MOVB	#006,KIPDR4	;MAKE KERNEL PAGE 4 RESISENT	
	MOV	@#100000,R1	;READ FROM ADDRESS 60000	
	CMP	R0,R1		;SEE IF DATA WAS STORED CORRECTLY	
	BEQ	9$		;BRANCH IF STORE WAS CORRECT	
	ERROR	47		;INCORRECT STORE	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 8$" = 000764	
9$:	;THIS WILL TEST DSTM = 3 MTPI.	
	MOV	#10$,$LPERR	;SET LOOP ON ERROR POINTER TO 10$	
	MOV	#030340,PSW	;MAKE PREVIOUS MODE USER	
	MOV	#52525,R0	;LOAD TEST DATA INTO R0	
10$:	MOV	R0,-(KSP)	;PUSH TEST DATA ON KERNEL STACK	
	CLRB	KIPDR4		;MAKE KERNEL I PAGE 4 NON-RESIDENT	
	MTPI	@#100000	;LOAD TEST DATA INTO PHYSICAL 80000	
	MOVB	#006,KIPDR4	;MAKE KERNEL PAGE 4 RESIDENT	
	MOV	@#100000,R1	;READ FROM ADDRESS 60000	
	CMP	R0,R1		;SEE IF DATA WAS STORED CORRECTLY	
	BEQ	11$		;BRANCH IF STORE WAS CORRECT			
	ERROR	47		;INCORRECT STORE			
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR	10$"	= 000763
11$:	;THIS	WILL TEST DSTM = 4 MTPI.
	MOV	#12$,$LPERR	;SET LOOP ON ERROR POINTER TO 12$
	MOV	#030340,PSW	;MAKE PREVIOUS MODE USER
	MOV	#125252,R0	;LOAD TEST DATA INTO R0
12$:	MOV	R0,-(KSP)	;PUSH TEST DATA ON KERNEL STACK
	MOV	#100002,R2	;LOAD VIRTUAL ADDRESS INTO R2

	CLRB	KIPDR4		;MAKE KERNEL I	PAGE 4 NON-RESIDENT	
	MTPI	-(R2)		;LOAD TEST DATA	INTO PHYSICAL 60000	
	MOVB	#006,KIPDR4	;MAKE KERNEL PAGE 4 RESIDENT	
	MOV	@#100000,R1	;READ FROM ADDRESS 60000	
	CMP	R0,R1		;SEE IF DATA WAS STORED CORRECTLY	
	BEG	13$		;BRANCH IF STORE WAS CORRECT	
	ERROR	47		;INCORRECT STORE	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR	126"	=	000762	
13$:	;THE FOLLOWING WILL TEST DSTM=5 MTPI.	
	;
	MOV	#14$,$LPERR	;SET LOOP ON ERROR POINTER TO 14$	
	MOV	#030340,PSW	;MAKE PREVIOUS MODE USER	
	MOV	$52525,R0	;LOAD TEST DATA INTO R0	
	MOV	#<$TMP2+2>,R2	;LOAD ADDR. OF LOC. $TMP2+2 INTO R2	
	MOV	#100000,$TMP2	;LOAD VIRT. ADDR. OF TEST LOC. INTO $TMP2
	MOV	R0,-(KSP)	;PUSH TEST DATA ON KERNEL STACK	
	CLRB	KIPDR4		;MAKE KERNEL PAGE 4 NON-RESIDENT	
	MTPI	@-(R2)		;LOAD TEST DATA	INTO PHYSICAL 60000	
	MOVB	#006,KIPDR4	;MAKE KERNEL PAGE 4 RESIDENT	
	MOV	@#100000,R1	;READ FROM ADDRESS 60000	
	CMP	R0,R1		;SEE IF DATA WAS STORED CORRECTLY	
	BEQ	15$		;BRANCH IF STORE WAS CORRECT	
	ERROR	47		;INCORRECT STORE	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR	14$"	=	000764	
15$:	;THIS WILL TEST DSTM = 6 MTPI.	
	;			
	MOV	6166,6LPERR	;SET LOOP ON ERROR POINTER TO 16$	
	MOV	6030340,PSW	;MAKE PREVIOUS MODE USER	
	MOV	652525,R0	;LOAD TEST DATA	INTO R0	
	CLR	R2		;MAKE REGISTER 2 ZERO	
16$:	MOV	R0,-(KSP)	;PUSH TEST DATA ON KERNEL STACK	
	CLRB	KIPDR4		;MAKE KERNEL	I PAGE 4 NON-RESIDENT	
	MTPI	100000(R2)	;LOAD TEST DATA INTO PHYSICAL 60000	
	MOVB	#006,KIPDR4	;MAKE KERNEL PAGE 4 RESIDENT	
	MOV	@#100000,R1	;READ FROM ADDRESS 60000	
	CMP	R0,R1		;SEE IF	DATA WAS STORED CORRECTLY	
	BEO	17$		;BRANCH IF STORE WAS CORRECT	
	ERROR	47		;INCORRECT STORE	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR	16$"	=	000763	
17$:	;THE FOLLOWING WILL TEST DSTM=7 MTPI.	
	;
	MOV	#18$,$LPERR	;SET LOOP ON ERROR POINTER TO 18$	
	MOV	#030340,PSW	;MAKE PREVIOUS MODE USER	
	MOV	#125252,R0	;LOAD TEST DATA INTO R0	
	MOV	#100000,$TMP2	;LOAD VIRT.	ADDR. OF TEST	LOCATION	
				;INTO LOCATION $TMP2	
	MOV	#$TMP2,R2	;LOAD ADDRESS OF $TMP2 INTO R2	
18$:	MOV	R0,-(KSP)	;PUSH TEST DATA ON KERNEL STACK	
	CLRB	KIPDR4		;MAKE KERNEL PAGE 4 NON-RESIDENT	
	MTPI	@0(R2)		;LOAD TEST DATA INTO PHYSICAL 60000	

	MOVB	#006,KIPDR4	;MAKE KERNEL PAGE 4 RESIDENT	
	MOV	@#100000,R1	;READ FROM ADDRESS 60000	
	CMP	R0,R1		;SEE IF DATA WAS STORED CORRECTLY	
	BEQ	19$		;BRANCH IF STORE WAS CORRECT	
	ERROR	47		;INCORRECT STORE	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 16$"	= 000763	
19$:	MOV	#15,$LPERR	;SET	LOOP POINTER TO START OF TEST	
	MOV	#MGMERR,MMVEC	;RESTORE M.M. VECTOR TO NORMAL ROUTINE	
	BR	TST50		;;BRANCH TO NEXT TEST	
				

20$:	MOV	(KSP)+,TRAPPC	;SAVE PC & PS OF TRAP	
	MOV	(KSP)+,TRAPPS	
	MOV	SR0,WASSR0	;SAVE SR0 FOR ERROR TYPEOUT	
	MOV	SR2,WAS5R2	;SAVE 5R2 FOR ERROR TYPEOUT	
	BIC	#160000,SR0	;CLEAR ERROR BITS IN SR0	
	ERROR	51		;TRIED TO LOAD A N.R.	PAGE 4	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;A	"NOP"	= 000240	
	MOV	TRAPPS,-(KSP)	;PUT PC & P5 OF TRAP ON STACK	
	MOV	TRAPPC,-(KSP)	
	RTI		;RETURN TO TEST	



;;***************************************************************	
;*TEST 50	MOVE FROM PREVIOUS (KERNEL) I-SPACE TO USER MODE	
;*	
;*	THIS TEST CHECKS THAT IF THE PREVIOUS MODE IS KERNEL THE	
;*	FETCH IS FROM KERNEL SPACE.	
;*	THERE 15 A DESCRIPTION BEFORE EACH DESTINATION MODE TESTED,	
;*	
;*	IF THE CORRECT MODE IS NOT ENABLED A NON-RESIDENT ABORT	
;*	WILL OCCUR AND TRAP TO 21$, WHERE THE ERRORS ARE REPORTED.	
;*	
;;****************************************************************	
TST50:	SCOPE	
1$:	MOV	#77406,R0	;MAKE ALL USER I-SPACE PAGES RESIDENT	
				;READ/WRITE,	LENGTH 200 BLOCKS	
	MOV	#10,R2		;SET	LOOP COUNTER TO B	
	MOV	#UIPDR0,R1	;LOAD ADDRESS OF FIRST PDR IN R1	
2$:	MOV	R0,(R1)+	;LOAD PG.1 WITH	77406	
	SOB	R2,2$		;LOOP UNTIL 8 USER PDRS LOADED	
	MOV	#3$,6LPERR	;SET LOOP ON ERROR TO 3$	
3$:	MOV	#140340,PSW	;GO TO USER MODE FOR THIS TEST	
	MOV	#77406,KIPDR4	;KERNEL	I-SPACE PAGE 4 READ/WRITE	
	MOV	#600,KIPAR4	;MAP KERNEL I	PAGE 4 TO 124	
	MOV	#600,UIPAR4	;MAP USER I	PAGE 4 TO 12K	
	MOV	#36514,R0	;LOAD DATA PATTERN INTO R0	
	MOV	R0,@#100000	;LOAD DATA PATTERN INTO PHY 60000	
	MOV	#100000,R2	;LOAD VIRTUAL ADDRESS INTO R2	
	;THE FOLLOWING WILL TEST DSTM=0 MFPI
	;
	MOV	#21$,MMVEC	;SET M.M.	VECTOR TO 21$	
	CLRB	UIPDR4		;MAKE USER I-SPACE PAGE 4 NON-RESIDENT	
	MOV	#140340,PSW	;MAKE PREVIOUS MODE KERNEL PRESENT USER	
4$:	MFPI	KSP		;PUT KERNEL STACK POINTER ON USER STACK	
	CMP	#USESTK,USP	;WAS SOMETHING PUSHED ON STACK AT 1$	
	BEQ	5$		;BRANCH IF NOTHING WAS PUSHED	
	MOV	(USP)+,R0	;POP USER STACK INTO R0	
	MOV	#KERSTK,R1	;EXPECTING 1100 AS KSP	
	CMP	R0,R1		;DID YOU GET THE RIGHT POINTER?	
	BEQ	6$		;BRANCH IF YOU DID	
	ERROR	46		;WRONG THING WAS PUSHED ON STACK	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 4$"	= 000766
	BR	6$		;BRANCH TO NEXT TRY	
5$:	ERROR	50		;NOTHING PUSHED ON STACK	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 4$"	= 000764	
6$:	;THE	FOLLOWING WILL TEST DSTM=1 MFPI.	
	MOV	#7$,$LPERR	;SET LOOP ON ERROR POINTER TO 76	
7$:	MOV	#140340,PSW	;MAKE PREVIOUS MODE KERNEL PRESENT USER	
	MOV	#36514,R0	;LOAD DATA EXPECTED INTO R0	
	MOV	#100000,R2	;LOAD VIRTUAL ADDRESS INTO R2	
	MFPI	(R2)		;READ FPnM PHYSICAL 60000	
	MOV	(USP)+,R1	;POP USER STACK	INTO 131	
	CMP	R0,R1		;WAS DATA FETCHED SAME AS STORED	
	BE0	8$		;BRANCH IF CORRECT DATA WAS FETCHED	
	ERROR	46		;WRONG DATA WAS FETCHED	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 7$"	= 000764	
8$:	;THE FOLLOWING WILL TEST DSM=2 MFPI.	
	MOV	#9$,$LPERR	;SET LOOP ON ERROR POINTER TO 9$	
9$:	MOV	#140340,PSW	;MAKE PREVIOUS MODE KERNEL PRESENT USER	
	MOV	#100000,92	;LOAD VIRTUAL ADDRESS INTO R2	
	MFPI	(R2)+		;READ FROM PHYSICAL 60000	
	MOV	(USP)+,R1	;POP USER STACK	INTO RI	
	CMP	R0,R1		;WAS DATA FETCHED SAME AS STORED	
	BEQ	10$		;BRANCH IF CORRECT DATA WAS FETCHED	
	ERROR	46		;WRONG DATA WAS FETCHED	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 9$"	= 000766	
10$:	;THE FOLLOWING WILL TEST DSTM=3 MFPI.	
	MOV	#11$,$LPERR	;SET LOOP ON ERROR POINTER TO 11$	
11$:	MOV	#140340,PSW	;MAKE PREVIOUS MODE KERNEL PRESENT USER	
	MFPI	@#100000	;READ FROM PHYSICAL 60000	
	MOV	(USP)+,R1	;POP USER STACK INTO RI	
	CMP	R0,R1		;WAS DATA FETCHED SAME AS STORED	
	BEQ	12$		;BRANCH IF CORRECT DATA WAS FETCHED	
	ERROR	46		;WRONG DATA WAS FETCHED	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 11$"	= 000767	

12$:	;THE FOLLOWING WILL TEST DSTM=4 MFPI.	
	MOV	#135,5LPERR	;SET LOOP ON ERROR POINTER TO 13$	
13$:	MOV	#140340,PSW	;MAKE PREVIOUS MODE DERNEL PRESENT USER	
	MOV	#100002,R2	;LOAD VIRTUAL ADDRESS INTO R2	
	MFPI	-(R2)		;READ FROM PHYSICAL 60000	
	MOV	(USP)+,R1	;POP USE., STACK	INTO RI	
	CMP	R0,R1		;WAS DATA FETCHED SAME AS STORED	
	BEQ	14$		;BRANCH IF CORRECT DATA WAS FETCHED	
	ERROR	46		;WRONG DATA WAS FETCHED	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 13$" =	000766	
14$:	;THE FOLLOWING WILL TEST DSTM=5 MFPI.	
	;
	MOV	#15$,$LPERR	;SET LOOP ON ERROR POINTER TO 15$	
15$:	MOV	#140340,PSW	;MAKE PREVIOUS MODE KERNEL PRESENT USER	
	MOV	#100000,$TMP2	;LOAD TEST LOC.	VIRT. ADDR INTO LOC. 2TMP2	
	MOV	#<$TMP2+2>,R2	;LOAD ADDRESS OF 6TMP2+2 INTO R2	
	MFPI	@-(R2)		;READ FROM PHYSICAL 60000	
	MOV	(USP)+,R1	;POP USER STACK	INTO RI	
	CMP	R0,R1		;WAS DATA FETCHED SAME AS STORED	
	BEQ	16$		;BRANCH IF CORRECT DATA FETCHED	
	ERROR	46		;WRONG DATA WAS FETCHED	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR	15$"	=	000763	
16$:	;THE FOLLOWING WILL TEST DSTM=6 MFPI.	
	;			
	MOV	#17$,$LPERR	;SET LOOP ON ERROR POINTER TO 17$.	
17$:	MOV	#140340,PSW	;MAKE PREVIOUS MODE KERNEL PRESENT USER	
	CLR	R2		;MAKE REGISTER 2 A ZERO	
	MFPI	100000(R2)	;READ FROM PHYSICAL 60000	
	MOV	(USP)+,R1	;POP USER STACK	INTO R1	
	CMP	R0,R1		;WAS DATA FETCHED SAME AS STORED	
	BEQ	18$		;BRANCH IF CORRECT DATA FETCHED	
	ERROR	46		;WRONG DATA WAS FETCHED	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR	17$"	= 000766	
18$:	;THE FOLLOWING WILL TEST DSTM=7 MFPI.	
	;				
	MOV	#19$,$LPERR	;SET LOOP ON ERROR POINTER TO 19$	
19$:	MOV	#140340,PSW	;MAKE PREVIOUS MODE KERNEL PRESENT USER	
	MOV	#100000,$TMP2	;LOAD TEST LOC.	VIRT.	ADDR.	INTO $TMP2	
	MOV	#$TMP2,R2	;LOAD ADDRESS OF 6TMP2 INTO R2	
	MFPI	@0(R2)		;READ FROM PHYSICAL 60000	
	MOV	(USP)+,R1	;POP USER STACK	INTO RI	
	CMP	R0,R1		;WAS DATA FETCHED SAME AS STORED	
	BEG	20$		;BRANCH IF CORRECT DATA FETCHED	
	ERROR	46		;WRONG DATA WAS FETCHED	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR	19$"	= 000762	
20$:	MOV	#MGMERR,MMVEC	;SET M.M. VECTOR TO NORMAL ROUTINE	
	MOV	#00340,PSW	;GO BACK TO KERNEL MODE,	PREVIOUS KERNEL	
	MOV	#1$,$LPERR	;SET LOOP POINTER TO START OF TEST	
	BR	TST51		;;BRANCH TO NEXT TEXT	
				
				
21$:	MOV	(KSP)+,TRAPPC	;SAVE PC & PS OF TRAP	
	MOV	(KSP)+,TRAPPS	
	MOV	SR0,WASSR0	;SAVE SR0 FOR ERROR TYPEOUT	
	MOV	SR2,WASSR2	;SAVE SR2 FOR ERROR TYPEOUT	
	BIC	#160000,SR0	;CLEAR ERROR BITS IN SR0	
	ERROR	51		;TRIED TO READ NON?RESIDENT PAGE	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;A "NOP"	= 000240	
	MOV	TRAPPS,-(KSP)	;PUT PC & PS OF TRAP ON STACK	
	MOV	TRAPPC,-(KSP)	
	RTI			;RETURN TO TEST	

;;**************************************************************
;*TEST 51	MOVE FROM/TO D-SPACE = MOVE FROM/TO I-SPACE	
;*	
;*	THIS TEST CHECKS THAT SINCE THFRE IS NO DISTINCTION	
;*	BETWEEN INSTRUCTION AND DATA SPACE IN THE 11/34	
;*	MFPD & MTPD SHOULD BE DECODED THE SAME AS MOPS & MTPI.	
;*	
;;**************************************************************
TST51:	SCOPE	
1$:	MOV	#030340,PSW	;MAKE PREVIOUS MODE=USER,CURRENT=KERNEL	
	MFPD	USP		;MFPD SHOULD ACT LIKE MFPI PUTTING	
				;USER STACK POINTER ON THE KERNEL STACK	
	CMP	#KERSTK,KSP	;WAS SOMETHING PUSHED ON KERNEL STACK?	
	BEQ	2$		;BRANCH IF NO	
	MOV	(KSP)+,R0	;POP KERNEL STACK INTO R0	
	MOV	#USESTK,R1	;EXPECTING TO GET 700 AS USP	
	CMP	R0,R1		;DID GET RIGHT POINTER VALUE?	
	BEQ	3$		;BRANCH IF YES	
	ERROR	53		;WRONG THING WAS PUSHED ON STACK	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 1$"	= 000763	
	BR	3$		;BRANCH TO NEXT TRY	
2$:	ERROR	54		;NOTHING PUSHED ON STACK	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 1$"	= 000761	
3$:	MOV	#4$,$LPERR	;SET LOOP ON ERROR POINTER TO 4$	
4$:	MOV	#7777,-(KSP)	;PUSH DATA ON KERNEL STACK	
	MTPD	USP		;LOAD Tf.: USER STACK POINTER	
	MFPD	USP		;READ USER STACK POINTER	
	MOV	(KSP)+,R1	;POP KERNEL STACK INTO RI	
	CMP	#7777,R1	;WAS USER STACK POINTER CHANGED?	
	BEQ	5$		;BRANCH IF YES	
	ERROR	54		;USER STACK POINTER NOT CHANGED	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;"BR 4$"	= 000767	
5$:	MOV	#USESTK,-(KSP)	;GET READY TO RESTORE USER STK. PTR.	
	MTPD	USP		;RESTORE USER STACK POINTER	
	MOV	#1$,$LPERR	;SET LOOP POINTER TO START OF TEST
;;*****************************************************************
;*TEST 52	MOVE FROM PREVIOJS I-SPACE (PREVIOUS=CURRENT-KERNEL)
;.
;.	THIS TEST CHECKS THAT IF BOTH PREVIOUS AND CURRENT MODES
;.	ARE KERNEL, AND THE SOURCE MODE IS 0, THE DESTINATION
;*	STACK IS NOT DECREMENTED BEFORE ACCESS.
;.	"MFPI KSP" SHOULD PUSH THE NON?DECREMENTED VALUE
;	OF KSP (1100) ONTO THE STACK (AT LOC. 1076).
;;*****************************************************************
TST52:	SCOPE
1$:	CLR	@#PSW		;SET PREVIOUS .. CURRENT = KERNEL
	MOV	#STACK,R0	;SETUP VALUE FOR STACK POINTER
	MOV	R0,KSP		;LOAD STACK POINTER
	MFPI	KSP		;THE VALUE "STACK" SHOULD BE PUSHED
				;BEFORE BEING QECREMENTED
	MOV	(KSP),R1	;READ DATA WHICH WAS PUSHED
	CMP	R0,R1		;WAS THE ORIGINAL VALUE OF THE
				;STACK POINTER PUSHED?
	BEQ	2$		;BRANCH IF YES
	ERROR	46		;MFPI FETCHED WRONG DATA
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 1$" = 000766
2$:	TST	-(R0)		;SETUP EXPECTED STACK POINTER VALUE
	CMP	KSP,R0		;WAS THE STACK POINTER DECREMENTED?
	BEQ	3$		;BRANCH IF YES
	ERROR	50		;STACK NOT PUSHED BY THE MFPI
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;"BR 1$" = 000762
3$:	MOV	#STACK,KSP	;RESTORE STACK POINTER




.SBTTL	**********************************************************
.SBTTL END OF PASS ROUTINE

;;***************************************************************
;*INCREMENT THE PASS NUMBER ($PASS)
;*TYPE "END PASS #XXXXX TOTAL NUMBER OF ERRORS SINCE LAST REPORT YYYYY"
;*WHERE XXXXX AND YYYYY ARE DECIMAL NUMBERS
;*IF SW12=1 INHIBIT TRACE TRAP
;*IF THERES A MONITOR GO TO IT
;*IF THERE ISN'T JUMP TO LOOP

$EOP:
	SCOPE
	CLR	$TSTNM		;;ZERO THE TEST NUMBER
	CLR	$TIMES		;;ZERO THE NUMBER OF ITERATIONS
	INC	$PASS		;;INCREMENT THE PASS NUMBER
	BIC	#100000,SPASS	;;DON'T ALLOW A NEG. NUMBER
	DEC	(PC)+		;;LOOP?
$EOPCT: .WORD	1
	BGT	$DOAGN		;;YES
	MOV	(PC)+,0(PC)+	;;RESTORE COUNTER
SENDCT: .WORD	1
	$EOPCT
	TYPE	,65$	;;TYPE ASCIZ STRING
	BR	64$	;;GET OVER THE ASCIZ
;;65$: .ASCIZ <12><15>/END PASS #/
64$:
	MOV	$PASS,-(SP)	;;SAVE $PASS FOR TYPEOUT
				;;TYPE PASS NUMBER
	TYPDS			;;GO TYPE--DECIMAL ASCII WITH SIGN
	TYPE	,67$		;;TYPE ASCIZ STRING
	BR	66$		;;GET OVER THE ASCIZ
;;67$: .ASCIZ / TOTAL ERRORS SINCE LAST REPORT /
66$:
	MOV	$ERTTL,-(SP)	;;SAVE SERTTL FOR TYPEOUT
				;;TOTAL NUMBER OF ERRORS
	TYPDS			;;GO TYPE--DECIMAL ASCII WITH SIGN
	TYPE	,$CRLF		;;TYPE CARRIAGE RETURN, LINE FEED
	CLR	$ERTTL		;;CLEAR ERROR TOTAL
$GET42: MOV	#42,R0		;;GET MONITOR ADDRESS
	BEQ	$DOAGN		;;BRANCH IF NO MONITOR
	CLR	-(SP)		;;INSURE THE .T. BIT IS CLEAR
	MOV	#$CLR.T,-(SP)	;;SETUP FOR AN RTI OR RTT
	BR	$RTRN		;;GO DO AN RTI OR RTT TO LOAD THE PSW
				;;WITH A CLEARED "T" BIT
$CLR.T:
	MOV	@#42,R0		;;INSURE RO CONTAINS THE MONITORS
	BEQ	$DOAGN		;;RETURN ADDRESS
	RESET			;;CLEAR THE WORLD
SENDAD: JSR	PC,(R0)		;;GO TO MONITOR
	NOP			;;SAVE ROOM
	NOP			;;FOR
	NOP			;;ACT11
$DOAGN:
	TRAP	0		;;PUSH OLD PSW AND PC ON STACK
	BIC	#20,(SP)	;;CLEAR THE .T. BIT
	BIT	#BIT12,@SWR	;;RUN WITH TRACE TRAP?
	BNE	1$		;;BR IF NO
	COM	$TBIT		;;IS IT TIME FOR TRACE TRAP
	BMI	1$		;;BR IF NO
	BIS	#20,(SP)	;;SET TRACE TRAP
1$:	MOV	#$LOOP,-(SP)	;;JUMP TO START OF TEST
$RTRN: RTI			;;RETURN--THIS IS CHANGED TO
       				;;AN "RTT" IF "RTT" IS A LEGAL
				;;INSTRUCTION
$LOOP:
	JMP	@(PC)+		;;RETURN
$RTNAD:	.WORD	LOOP
$TBIT:	.WORD	0		;;"T" BIT STATE INDICATOR
$ENULL: .BYTE	-1,-1,0		;;NULL CHARACTER STRING
	.EVEN
.SUBTT	SCOPE HANDLER ROUTINE

;;***************************************************************
;*THIS ROUTINE CONTROLS THE LOOPING OF SUBTESTS. IT WILL INCREMENT
;*AND LOAD THE TEST NUMBER(STSTNM) INTO THE DISPLAY REG.(DISPLAY<7:0>)
;*AND LOAD THE ERROR FLAG (SERFLG) INTO DISPLAY<15:0>
;*THE SWITCH OPTIONS PROVIDED BY THIS ROUTINE ARE:
;*SW14=1	LOOP ON TEST
;*SW11=1	INHIBIT ITERATIONS
;*SW09=1	LOOP ON ERROR
;*SW08=1	LOOP ON TEST IN SWR<7:0>
;*CALL
;*	SCOPE	;;SCOPE.IOT

$SCOPE:
	CKSWR	;;TEST FOR CHANGE IN SOFT?SWR
1$:	BIT	#BIT14,@SWR	;;LOOP ON PRESENT TEST?
	BNE	$OVER		;;YES IF SW14=1
;#####START OF CODE FOR THE XOR TESTER#####
$XTSTR: BR	6$	    	;;IF RUNNING ON THE "XOR" TESTER CHANGE
				;;THIS INSTRUCTION TO A "NOP" (NOP*240)
	MOV	@#ERRVEC,-(SP)	;;SAVE THE CONTENTS OF THE ERROR VECTOR
	MOV	#5$,@#ERRVEC	;;SET FOR TIMEOUT
	TST	@#177060	;;TIME OUT ON XOR?
	MOV	(SP)+,@#ERRVEC	;;RESTORE THE ERROR VECTOR
	BR	$SVLAD		;;GO TO THE NEXT TEST
5$:	CMP	(SP)+,(SP)+	;;CLEAR THE STACK AFTER A TIME OUT
	MOV	(SP)+,@#ERRVEC	;;RESTORE THE ERROR VECTOR
	BR	7$	      	;;LOOP ON THE PRESENT TEST
6$:;#####END OF CODE FOR THE XOR TESTER#####
	BIT	#BIT08,@SWR	;;LOOP ON SPEC. TEST?
	BEQ	2$		;;BR IF 10
	CMPB	@SWR,$TSTNM	;;ON THE RIGHT TEST?	SWR<7:0>
	BEQ	$OVER		;;BR IF YES
2$:	TSTB	$ERFLG		;;HAS AN ERROR OCCURRED?
	BEQ	3$		;;BR IF N3
	CMPB	$ERMAX,$ERFLG	;;MAX. ERRORS FOR THIS TEST OCCURRED?
	BHI	3$		;;BR IF NO
	BIT	#BIT09,@SWR	;;LOOP ON ERROR?
	BEG	4$		;;BR IF NO
7$:	MOV	$LPERR,$LPADR	;;SET LOOP ADDRESS TO LAST SCOPE
	BR	$OVER
4$:	CLRB	SERFLG		;;ZERO THE ERROR FLAG
	CLR	$TIMES		;;CLEAR THE NUMBER OF ITERATIONS TO MAKE
	BR	1$		;;ESCAPE TO THE NEXT TEST
3$:	BIT	#BITI1,@SWR	;;INHIBIT	ITERATIONS?
	BNE	1$		;;BR	IF	YES
	TST	$PASS		;;IF FIRST PASS OF PROGRAM
	BEQ	1$		;;	INHIBIT	ITERATIONS
	INC	$ICNT		;;INCREMENT	ITERATION COUNT
	CMP	$TIMES,$ICNT	;;CHECK THE NUMBER OF ITERATIONS MADE
	BGE	$OVER		;;BR	IF MORE	ITERATION REQUIRED
1$:	MOV	#1,$ICNT	;;REINITIALIZE	THE	ITERATION COUNTER
	MOV	$MXCNT,$TIMES	;;SET NUMBER OF ITERATIONS TO DO
$SVLAD:	INCB	$TSTNM		;;COUNT TEST NUMBERS
	MOVB	$TSTNM,$TESTN	;;SET TEST NUMBER IN APT MAILBOX
	MOV	(SP),$LPADR	;;SAVE SCOPE	LOOP ADDRESS
	MOV	(SP),$LPERR	;;SAVE ERROR	LOOP ADDRESS
	CLR	$ESCAPE		n;;CLEAR THE ESCAPE FROM ERROR ADDRESS
	MOVB	#1,$ERMAX	;;ONLY ALLOW ONE(1)	ERROR ON NEXT TEST
$OVER:	MOV	$TSTNM,@DISPLAY	;;DISPLAY TEST NUMBER
	MOV	$LPADR,(SP)	;;FUDGE RETURN ADDRESS
	RTI			;;FIXES	PS
$MXCNT:	200			;;MAX.	NUMBER OF ITERATIONS
.SBTTL	ERROR HANDLER ROUTINE

;;***************************************************************
;*THIS ROUTINE WILL INCREMENT THE ERROR FLAG AND THE ERROR COUNT,
;*SAVE THE ERROR ITEM NUMBER AND THE ADDRESS OF THE ERROR CALL
;*AND GO TO ERRTYP ON ERROR
;*THE SWITCH OPTIONS PROVIDED BY THIS ROUTINE ARE:
;*SW15=1	HALT ON ERROR
;*SW13=1	INHIBIT ERROR TYPEOUTS
;*SW10=1	BELL ON ERROR
;*SW09=1	LOOP ON ERROR
;*CALL
;.	ERROR	N	;;ERROR=EMT AND N=ERROR ITEM NUMBER

$ERROR:
	CKSWR			;;TEST	FOR CHANGE IN SOFT-SWR
	MOV	R0,$REGO	;SAVE THE CONTENTS OF R0
	MOV	R1,$REG1	;SAVE THE CONTENTS OF RI
	MOV	R2,$REG2	;SAVE THE CONTENTS OF R2
	MOV	R3,$REG3	;SAVE THE CONTENTS OF R3
	MOV	R4,$REG4	;SAVE THE CONTENTS OF R4
	MOV	R5,$REG5	;SAVE THE CONTENTS OF R5
	MOVB	$TSTNM,TESTNO	;SAVE THE TEST NUMBER
7$:	INCB	$ERFLG	;;SET THE ERROR FLAG
	BEQ	7$		;;DON'T	LET THE FLAG GO TO ZERO
	MOV	$TSTNM,@DISPLAY	;;DISPLAY TEST NUMBER AND ERROR FLAG
	BIT	#BIT10,@SWR	;;BELL ON ERROR?
	BEQ	1$		;;NO - SKIP
	TYPE	,$BELL		;;RING BELL
1$:	INC	$ERTTL		;;COUNT THE NUMBER OF ERRORS
	MOV	(SP),$ERRPC	;;GET ADDRESS OF ERROR INSTRUCTION
	SUB	#2,$ERRPC
	MOVB	@$ERRPC,$ITEMB	;;STRIP AND SAVE THE ERROR ITEM CODE
	BIT	#BIT13,@SWR	;;SKIP TYPEOUT IF SET
	BNE	20$		;;SKIP TYPEOUTS	
	JSR	PC,ERRTYP	;;GO TO USER ERROR ROUTINE	
	TYPE	,$CRLF	
20$:	
	CMPB	#APTENV,$ENV	;;RUNNING IN APT MODE	
	BNE	2$		;;NO,SKI	APT ERROR REPORT	
	MOVB	$ITEMB,21$	;;SET ITEM NUMBER AS ERROR NUMBER	
	JSR	PC,$ATY4	;;REPORT	FATAL ERROR TO APT	
21$:	.BYTE	0	
	.BYTE	0	
22$:	BR	22$		;;APT ERROR LOOP	
2$:	TST	0SWR		;;HALT ON ERROR	
	BPL	3$		;;SKIP	IF CONTINUE	
	HALT			;;HALT ON ERROR!	
	CKSWR			;;TEST FOR CHANGE IN SOFT-SWR	
3$:	BIT	#BIT09,@SWR	;;LOOP ON ERROR SWITCH SET?	
	BEQ	4$		;;BR IF NO	
	MOV	$LPERR,(SP)	;;FUDGE RETURN FOR LOOPING	
4$:	TST	$ESCAPE		;;CHECK FOR AN ESCAPE ADDRESS	
	BEQ	5$		;;BR	IF NONE	
	MOV	$ESCAPE,(SP)	;;FUDGE RETURN ADDRESS FOR ESCAPE	
5$:	
	CMP	#$ENDAD,(SP)	;;ACT-11	AUTO-ACCEPT?	
	BNE	6$		;;BRANCH IF NO	
	HALT			;;YES	
6$:	
	RTI			;;RETURN	
.SBTTL	ERROR MESSAGE TYPEOUT ROUTINE	

;;***************************************************************	
;*THIS ROUTINE USES THE "ITEM CONTROL BYTE* ($ITEMB) TO DETERMINE WHICH	
;*ERROR IS TO BE REPORTED.  IT THEN OBTAINS, FROM THE "ERROR TABLE" ($ERRTB),
;*AND REPORTS THE APPROPRIATE INFORMATION CONCERNING THE ERROR.	
;*	
;*NOTES:	
;*1)	THIS ROUTINE PROVIDES AN AUTOMATIC .CARRIAGE RETURN-LINE FEED	
;*	FOR "EM", "DH",	AND "DT".	
;*2)	TWO SPACES ARE TYPED AFTER EACH NUMBER FOR "DT"	
;*3)	FOR $ITEMB=0, JUST THE ERROR PC	IS TYPED	
;*4)	THE AVAILABLE FORMATS FOR TYPING DATA ARE:	
;*	DF	FORMAT	
;*	0	TYPE A 6 DIGIT OCTAL NUMBER (FROM 16-BIT BINARY)	
;*	1	TYPE A DECIMAL NUMBER WITHOUT LEADING ZEROS	
;*	2	TYPE A 16 DIGIT BINARY NUMBER	
;*	3	TYPE A 6 DIGIT OCTAL NUMBER (FROM 18-BIT BINARY)	
;*	

ERRTYP:	
	TYPE	,$CRLF		;"CARRIAGE RETURN" 6 "LINE FEED"	
	MOV	R0,-(SP)	;SAVE RO	
	CLR	R0		;PICKUP THE ITEM INDEX	
	BISB	@$$ITEMB,R0	
	BNE	1$		;IF	ITEM NUMBER IS ZERO,	JUST	
				;TYPE THE PC OF THE ERROR	
	MOV	$ERRPC,-(SP)	;;SAVE SERRPC FOR TYPEOUT	
				;;ERROR ADDRESS	
	TYPDC			;;GO TYPE--OCTAL ASCII(ALL DIGITS)	
	BR	13$		;GET OUT	
1$:	DEC	R0		;ADJUST THE INDEX SO THAT IT WILL	
	ASL	R0		;	WORK FOR THE ERROR TABLE	
	ASL	R0	
	ASL	R0	
	ADD	#$ERRTB,R0	;FORM TABLE POINTER	
	MOV	(R0)+,2$	;PICKUP "ERROR MESSAGE"	POINTER	
	BEQ	3$		;SKIP TYPEOUT	IF NO POINTER	
	TYPE			;TYPE THE "ERROR MESSAGE"
	2$:	.WORD	0	;"ERROR MESSAGE. POINTER GOES HERE	
	TYPE	,$CRLF		;"CARRIAGE RETURN"	&	"LINE FEED"	
3$:	MOV	(R0)+,4$	;PICKUP "DATA HEADER"	POINTER	
	TYPE	5$		;SKIP TYPEOUT	IF 0	
				;TYPE THE "DATA HEADER"	
4$:	.WORD	0		;.DATA HEADER" POINTER GOES HERE	
	TYPE	,$CRLF		;"CARRIAGE RETURN" &	"LINE FEED"	
5$:	MOV	R1,-(SP)	;SAVE R1
	MOV	(R0)+,R1	;PICKUP	"DATA TABLE"	POINTER	
	BEQ	12$		;BR IF NO DATA TO BE TYPED	
	MOV	(R0)+,R0	;PICKUP	"DATA FORMAT	POINTER	
6$:	TSTB	(R0)		;IS	IT FORMAT 0?	
	BNE	7$		;BR IF NO	

;*THIS CODE IS	FOR OCTAL (16-BIT) FORMAT (DF=0)	
	MOV	@(R1)+,-(SP)	;;SAVE V(R1)+ FOR TYPEDUT	
	TYPOC			;;GO TYPE--OCTAL ASCII(ALL DIGITS)	
	BR	11$	
;*THIS CODE IS	FOR DECIMAL FORMAT (DF=1)	
7$:	CMPB	(R0),#1		;;IS	IT	FORMAT	I?	
	BNE	8$		;BRANCH	IF NO	
	MOV	@(R1)+,-(SP)	;;SAVE P(R1)+ FOR TYPEDUT	
	TYPDS			;;GO TYPE--DECIMAL ASCII WITH SIGN	
	BR	11$	

;*THIS CODE IS	FOR BINARY FORMAT (DF=2)	
8$:	CMPB	(R0),#2		;IS	IT FORMAT 2?	
	BNE	9$		;BRANCH IF NO	
	MOV	@(R1)+,-(SP)	;;SAVE 11(R1)+ FOR TYPEOUT	
	TYPBN			;;GO TYPE-BINARY ASCII	
	BR	11$	

;*THIS CODE IS	FOR OCTAL (18-BIT) FORMAT (DF=3)	
9$:	MOV	(R1)+,-(SP)	;PUT ADDRESS OF FIRST LOC.	ON STACK	
	JSR	PC,$DB20	;CONVERT TWO LOCS. TO AN ASCII STRING	
	ADD	#5,(SP)		;ONLY NEED 6 CHARACTERS NOT 11	
	MOV	(SP)+,10$	;PUT ADDRESS OF ASCII CHARS.	AT 10$	
	TYPE			;TYPE OCTAL VALUE OF 18-BIT BINARY NO.	
10$:	.WORD	0	

11$:	TST	(R1)		;IS THERE ANOTHER NUMBER?	
	BEQ	12$		;BR	IF NO 	
	TYPE	,14$		;TYPE TWO(2)	SPACES	
	TSTB	(R0)+		;POINT TO NEW "DATA FORMAT"	
	BR	6$		;LOOP	
12$:	MOV	(SP)+,R1	;TWO(2)	SPACES		
13$:	MOV	(SP)+,R0			
	TYPE	,$CRLF			
	RTS	PC			
14$:	.ASCII	/  /			
	.EVEN			
4572				

.SBTTL	*****  SUBROUTINES USED BY THIS PROGRAM  *****
	
.SBTTL	TURN OFF T-BIT AND SAVE CURRENT PSW
;;***************************************************************
;*
;*	THIS SUBROUTINE IS USED TO TURN OFF THE TRACE TRAP BIT IN THE PSW
;*	IF IT IS ON.	THE PROCESSOR STATUS IS SAVED IN "TBITPS" S0 THAT
;*	THE PSW CAN BE RESTORED TO ITS PREVIOUS CONDITION WHEN CONDITIONS
;*	WARRANT T-BIT TRAPPING.
;*
;;***************************************************************

TOFF:	BIT	PSW,NTBIT	;IS THE T-BIT SET IN THE PSW?
	BEQ	1$		;EXIT IF NO
	MOV	PSW,-(SP)	;PUSH PRESENT POW ON THE STACK
	MOV	(SP),TBITPS	;ALSO SAVE IT	IN "TBITPS"	FOR
				;RESTORING LATER
	BIC	#TBIT,(SP)	;CLEAR THE T-BIT	(BIT 4)	IN THE PSW
	MOV	#1$,-(SP)	;PUSH PC OF "RTS" ON STACK
	RTT			;"RETURN"	TO 1$ WITH T-BIT OFF
1$:	RTS	PC		;RETURN TO PROGRAM
	
.SBTTL	TURN ON T-BIT AND RESTORE PREVIOUS PSW
;;***************************************************************
;*
;*	THIS SUBROUTINE IS USED TO RESTORE THE PROCESSOR STATUS TO ITS
;*	PREVIOUS CONDITION BY RESTORING THE "T-BIT PSW" SAVED BY THE
;*	"TOFF"	SUBROUTINE IN THE "TBITPS" LOCATION.
;*
;;***************************************************************
TON:	BIT	TBITPS,NTBIT	;WAS T-BIT ON	IN THE PREVIOUS PSW?
	BEQ	1$		;EXIT	IF NO
	MOV	TBITPS,-(SP)	;PUSH PREVIOUS PSW ON THE STACK
	MOV	N340,TBITPS	;RESET THE "TBITPS"	LOCATION
	MOV	N1S,-(SP)	;PUSH PC OF	"RTS" ON STACK
	RTT			;"RETURN"	TO 1$ WITH T-BIT RESTORED
1$:	RTS	PC		;RETURN TO PROGRAM
	
.SBTTL	SET ALL WRITEABLE BITS IN ALL PAR/PDR'S
;;***************************************************************
;*
;*	THIS SUBROUTINE IS USED BY THE PAR/PDR DUAL ADDRESSING TEST
;*	TO SET ALL WRITEABLE BITS IN ALL KERNEL AND USE PAR'S AND
;*	PDR'S TO A 1.	THE "INITIAL STATE" OF HAVING ALL BITS=1 IS
;*	USED TO SEE THAT ONLY ONE REGISTER IS CLEARED IN RESPONSE TO
;*	A SINGLE PAR OR PDR ADDRESS.
;*
;;***************************************************************
	
SETREG: MOV	#10,R2		;LOAD LOOP COUNTER WITH AN 8
	MOV	#KIPDR0,R1	;LOAD ADDRESS OF FIRST PDR	INTO RI
1$:	MOV	#-1,(R1)+	;SET BITS	IN KERNEL PDR TO 1
	SOB	R2,1$		;LOOP TO 1$ UNTIL ALL KERNEL PDR'S LOADED
	MOV	#10,R2		;LOAD LOOP COUNTER WITH AN 8
	MOV	#KIPAR0,R1	;LOAD ADDRESS OF FIRST PAR INTO RI
2$:	MOV	#-1,(R1)+	;SET BITS IN A KERNEL PAR TO I
	SOB	R2,2$		;LOOP TO 2$ UNTIL ALL KERNEL PAR'S LOADED
	MOV	#10,R2		;LOAD LOOP COUNTER WITH AN 8
	MOV	#UIPDR0,RI	;LOAD ADDRESS OF FIRST PDR INTO RI
3$:	MOV	#-1,(R1)+	;SET	BITS	IN A USER	PDR	TO	I
	SOB	R2,3$		;LOOP TO 3$ UNTIL ALL USER PDR'S LOADED
	MOV	#10,R2		;LOAD LOOP COUNTER WITH AN B
	MOV	#UIPAR0,R1	;LDAD ADDRESS OF FIRST PAR INTO RI
4$:	MOV	#-1,(R1)+	;SET BITS	IN A USER PAR TO 1
	SOB	R2,4$		;LOOP TO 4$ UNTIL ALL USER PAR'S LOADED
	RTS	PC		;RETURN TO TEST

.SBTTL	READ & COMPARE KERNEL & USER PAR/PDR'S
;;***************************************************************
;*
;*	THIS SUBROUTINE IS USED BY PAR/PDR DUAL ADDRESSING TEST TO
;*	READ ALL THE PAR'S AND PDR'S TO SEE THAT ONLY ONE REGISTER
;*	WAS CLEARED IN RESPONSE TO A SINGLE PAR OR POR ADDRESS.
;*	ANY FAILURES FOUND BY THE PAR/PDR DUAL ADDRESSING TEST WILL
;*	BE REPORTED BY THIS SUBROUTINE.
;*
;;***************************************************************
CMPRED:
	MOV	NKIPDR0,RI	;LOAD ADDRESS OF FIRST KERNEL PDR IN Ill
	MOV	#10,R4		;LOAD LOOP COUNTER WITH AN 8
	MOV	#77416,R5	;PUT EXPECTED POR CONTENTS IN R5
1$:	MOV	(R1),R2		;READ A KERNEL PDR	INTO R2
	CMP	R2,R5		;ARE ALL WRITEABLE BITS SET AL EXPECTED?
	BEQ	2$		;BRANCH IF YES
	CMP	R1,R0		;WAS IT THE REG.	THAT WAS CLEARED?
	BED	2$		;BRANCH	IF YES
	ERROR	16		;A PDR WAS EFFECTED BY CLEARING A DIFFERENT PAR/PDR
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;AN "RTS PC"	= 000207
2$:	ADD	#2,R1		;FORM NEXT KERNEL PDR ADDRESS
	SOB	R4,1$		;LOOP TO 1$ UNTIL ALL KERNEL PDR'S CHECKED
	MOV	#KIPAR0,RI	;LOAD ADDRESS OF FIRST KERNEL PAR IN RI
	MOV	#10,R4		;LOAD LOOP COUNTER WITH AN 8
	MOV	#7777,R5	;PUT EXPECTED PAR CONTENTS IN R5
3$:	MOV	(R1),R2		;READ A KERNEL PAR INTO R2
	CMP	R2,R5		;ARE ALL WRITEABLE BITS SET AS EXPECTED?
	BEQ	4$		;BRANCH IF YES
	CMP	R1,R0		;WAS IT THE REG.	THAT WAS CLEARED?
	BED	4$		;BRANCH IF YES
	ERROR	16		;A PAR WAS EFFECTED BY CLEARING A DIFFENENT PAR/PDR
				;FOR TIGHTER SCOPE LOOP
				;REPLACE ERROR CALL WITH
				;AN "RTS PC"	= 000207
4$:	ADD	#2,R1		;FORM NEXT KERNEL PAR ADDRESS
	SOB	R4,3$		;LOOP TO 3$ UNTIL ALL KERNEL PAR'S CHECKED
	MOV	#UIPDR0,RI	;LOAD ADDRESS OF FIRST USER PDR	IN RI
	MOV	#10,124		;LOAD LOOP COUNTER WITH AN 8
	MOV	#77416,95	;PUT EXPECTED PDR CONTENTS IN R5
5$:	MOV	(R1),R2		;READ A USER PDR INTO R2
	CMP	R2,R5		;ARE ALL WRITABLE BITS SET AS EXPECTED?
	BED	6$		;BRANCH IF YES
	CMP	R1,R0		;WAS IT THE REG.	THAT WAS CLEARED?
	BEQ	8$		;BRANCH IF YES	
	ERROR	16		;A FOR WAS EFFECTED BY CLEARING A DIFFERENT PAR/PDR	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;AN "RTS PC"	= 000207	
6$:	ADD	#2,R1		;FORM NEXT USER PDR ADDRESS	
	SOB	R4,5$		;LOOP TO 5$ UNTIL ALL USER PDR'S CHECKED	
	MOV	#UIPAR0,R1	;LOAD ADDRESS OF FIRST USER PAR IN R1	
	MOV	#10,R4		;LOAD LOOP COUNTER WITH AN 8	
	MOV	#7777,R5	;PUT EXPECTED PAR CONTENTS IN R5	
7$:	MOV	(R1),R2		;READ A USER PAR INTO R2	
	CMP	R2,R5		;ARE ALL WRITEABLE BITS SET AS EXPECTED?	
	BEG	8$		;BRANCH IF YES	
	CMP	R1,R0		;WAS IT THE REG.	THAT WAS CLEARED?	
	BEQ	8$		;BRANCH IF YES	
	ERROR	16		;A PAR WAS EFFECTED BY CLEARING A DIFFERENT PAR/PDR	
				;FOR TIGHTER SCOPE LOOP	
				;REPLACE ERROR CALL WITH	
				;AN "RTS PC" = 000207	
8$:	ADD	#2,R1		;FORM NEXT USER PAR ADDRESS	
	SOB	R4,7$		;LOOP TO 7$ UNTIL ALL USER PAR'S CHECKEDBEQ	
	RTS	PC		;RETURN TO TEST	

.SBTTL	CONVERT	VIRTUAL ADDRESS TO PHYSICAL ADDRESS
;;***************************************************************	
;*	
;*	THIS SUBROUTINE IS USED TO FORM AN 18-BIT PHYSICAL ADDRESS	
;*	(PBA) FROM THE 1=-BIT VIRTUAL ADDRESS (VBA) AND THE APPROPRIATE	
;*	PAGE ADDRESS REGISTER (PAR).  THE SAME METHOD USED BY THE MEMORY	
;*	MANAGEMENT LOGIC IS USED.  VBA <15:13> SELECTS WHICH PAR/PDR	
;*	IS TO BE USED, VBA <5:0>+PBA <5:0>, AND VBA <12:6> IS ADDED	
;*	TO PAR <11:00> TO GIVE PBA <17:6>. BIT <17:6>. BITS <17:16> OF THE
;*	PHYSICAL ADDRESS ARE LEFT IN LOC. "PBAHI" AND BITS <15:00>	
;*	ARE LEFT IN(PBA) "PBALO". THE PSW'S "CURRENT MODE" BITS	
;*	ARE USED TO SELECT THE KERNEL OR USER PAR/PDR'S.  THE ROUTINE	
;*	IS ENTERED WITH LOC. "VIRT1" CONTAINING THE 16-BIT VIRTUAL	
;*	ADDRESS.	
;*	
;;***************************************************************	

FORMPA: MOV	#KIPAR0,R2	;LOAD ADDRESS OF FIRST KERNEL PAR IN R2	
	BIT	#14000,PSW	;IN USER MODE?	
	BEQ	1$		;BRANCH	IF NO	
	MOV	#UIPAR0,R2	;LOAD ADDRESS OF FIRST USER PAR IN R2	
1$:	MOV	VIRT1,R0	;LOAD VIRTUAL ADDR.	(VBA)	INTO RO	
	ASH	#-14,R0		;GET BITS <15:13> DOWN TO BIT#KIPAR0,R2	
	BIC	#177761,R0	;MASK OF ALL BITS BUT	BITS <3:1>	
	ADD	R0,R2		;ADD OFFSET TO BASE PAR ADDRESS	
	MOV	(R2),R0		;GET BITS <11:00> FROM APPROPRIATE PAR	
	MOV	R0,R2		;COPY PAR BITS <11:00> INTO R2	
	MOV	VIRT1,PBALO	;PUT VIRTUAL ADDR.	IN LOC.	"PBALO"	
	BIC	#160000,PBALO	;CLEAR OFF BITS <15:13> OF ORIGINAL VBA	
	ASH	#-12,R2		;GET PAR <11:00> DOWN TO BITS <1:0> OF R2	
	BIC	#177774,R2	;CLEAR OFF ALL BITS BUT BITS <1:0>	
	ASH	#6,R0		;SHIFT PAR<9:0> TO <15:6> OF RO	
	BIC	#77,R0		;CLEAR BITS <5:0> OF RO	
	ADD	R0,PBALO	;IN EFFECT, ADD VBA<12:0> TO PAR<9:0>
				;(PAR<9:0> IN BITS <15:6> OF R0)
	ADC	R2		;ADD ANY CARRY TO R2
	MOV	R2,PBAHI	;PUT BITS <17:18> OF PHYSICAL ADDR. IN PBAHI
	RTS	PC		;RETURN TO PROGRAM


.SBTTL	TTY INPUT ROUTINE	
	
;;***************************************************************
.ENABL	LSB	
	
;;***************************************************************	
;*SOFTWARE SWITCH REGISTER CHANGE ROUTINE.	
;*ROUTINE IS ENTERED FROM THE TRAP HANDLER, AND WILL	
;*SERVICE THE TEST FOR CHANGE IN SOFTWARE SWITCH REGISTER TRAP CALL	
;*WHEN OPERATING IN TTY FLAG MODE. 
$CKSWR: CMP	#SWREG,SWR	;;IS THE SOFT-SWR SELECTED?	
	BNE	15$		;;BRANCH IF NO	
	TSTB	@#TKS		;;CHAR THERE? 	
	BPL	15$		;;IF NO,	DON'T WAIT AROUND	
	MOVB	PSTKB,-(SP)	;;SAVE THE CHAR	
	BIC	#^C177,(SP)	;;STRIP-OFF THE ASCII	
	CMP	#7,(SP)+	;;IS	IT	A CONTROL G?	
	BNE	15$		;;NO,	RETURN TO USER	
	CMPB	$AUTOB,1/1	;;ARE WE RUNNING IN AUTO-MODE?	
	BEQ	15$		;;BRANCH	IF YES	

	TYPE	,$CNTLG		;;ECHO THE CONTROL-G (.0)	
SGTSWR:	TYPE	,$MSWR		;;TYPE CURRENT CONTENTS	
	MOV	SWREG,-(SP)	;;SAVE SWREG FOR TYPEOUT	
	TYPOC			;;GO TYPE--OCTAL ASCII(ALL DIGITS)	
	TYPE	,$MNEW		;;PROMPT FOR NEW SWR	
19$:	CLR	-(SP)		;;CLEAR COUNTER	
	CLR	-(SP)		;;THE NEW SWR	
7$:	TSTB	@$TKS		;;CHAR THERE?	
	BPL	7$		;;IF NOT TRY AGAIN	

	MOVB	@$TKB,-(SP)	;;PICK UP CHAR	
	BIC	#^C177,(SP)	;;MAKE	IT	7-BIT ASCII	

	CMP	(SP),#3		;;IS	IT A CONTROL-C?	
	BNE	9$		;;BRANCH IF NOT 	
	TYPE	,$CNTLC		;;YES,	ECHO CONTROL-C ("C)	
	ADD	#6,SP		;;CLEAN UP STACK	
	CMPB	$INTAG,M1	;;REENABLE TTY KEYBOARD INTERRUPTS?	
	BNE	8$		;;BRANCH IF NO 	
	MOV	#100,@$TKS	;;ALLOW TTY KEYBOARD INTERRUPTS	
8$:	JMP	CNTRLC		;;CONTROL-C RESTART	


9$:	CMP	(SP),#25	;;IS IT A CONTROL-U7	
	BNE	10$		;;BRANCH IF NOT	
	TYPE	,SCNTLU		;;YES,	ECHO CONTROL-U ("U)	
20$:	ADD	#6,SP		;;IGNORE PREVIOUS INPUT	
	BR	19$		;;LET'S	TRY	IT	AGAIN	


10$:	CMP	(SP),#15	;;IS	IT	A <CR>7	
	BNE	16$		;;BRANCH IF NO	
	TST	4(SP)		;;YES,	IS IT THE FIRST CHAR?	
	BEQ	11$		;;BRANCH IF YES	
	MOV	2(SP),@SWR	;;SAVE NEW SWR	

11$:	ADD	#6,SP		;;CLEAR UP STACK	
14$:	TYPE	,$CRLF		;;ECHO <CR> AND <LF>	
	CMPB	$INTAG,#1	;;RE-ENABLE TTY KBD INTERRUPTS?	
	BNE	15$		;;BRANCH IF NOT 	
	MOV	#100,@$TKS	;;RE-ENABLE TTY KBD INTERRUPTS	
15$:	RTI			;;RETURN	
16$:	JSR	PC,$TYPEC	;;ECHO CHAR	
	CMP	(SP),#60	;;CHAR < 0?	
	BLT	18$		;;BRANCH	IF YES	
	CMP	(SP),#67	;;CHAR >	7?	
	BGT	18$		;;BRANCH IF YES	
	BIC	#60,(SP)+	;;STRIP-OFF	ASCII	
	TST	2(SP)		;;IS THIS THE	FIRST CHAR	
	BEQ	17$		;;BRANCH	IF YES	
	ASL	(SP)		;;NO,	SHIFT	PRESENT	
	ASL	(SP)		;;	CHAR OVER TO MAKE	
	ASL	(SP)		;;	ROOM FOR NEW ONE.	
17$:	INC	2(SP)		;;KEEP COUNT OF CHAR	
	BIS	-2(SP),(SP)	;;SET	IN NEW CHAR	
	BR	7$		;;GET THE NEXT ONE	
18$:	TYPE	,$QUES		;;TYPE 7<cR><Lr>	
	BR	20$		;;SIMULATE CONTROL-U	
.DSABL	LSB	


;;***********************************,****************************	
;*THIS ROUTINE WILL INPUT A SINGLE CHARACTER FROM THE TTY	
;*CALL:
;*	RDCHR		;;INPUT A SINGLE CHARACTER FROM THE TTY	
;*	RETURN HERE	;;CHARACTER IS ON THE STACK	
;*			;;WITH PARITY BIT STRIPPED OFF	
;	

$RDCHR: MOV	(SP),-(SP)	;;PUSH DOWN THE PC	
	MOV	4(SP),2(SP)	;;SAVE THE PS	
1$:	TSTB	@$TKS		;;WAIT	
	BPL	1$		;;A CHARACTER	
	MOVB	@$TKB,4(SP)	;;READ THE TTY	
	BIC	#^C<177>,4(SP)	;;GET RID OF JUNK IF ANY	
	CMP	4(SP),#23	;;IS	IT A CONTROL-S?	
	BNE	3$		;;BRANCH IF NO	
2$:	TSTB	@$TKS		;;WAIT FOR A CHARACTER	
	BPL	2$		;;LOOP UNTIL ITS THERE	
	MOVB	@$TKB,-(SP)	;;GET CHARACTER	
	BIC	#^C177,(SP) 	;;MAKE	IT	7-BIT ASCII	
	CMP	(SP)+,#21	;;IS IT A CONTROL-0?	
	BNE	2$		;;IF NOT DISCARD IT	
	BR	1$		;;YES,	RESUME	
3$:	CMP	4(SP),#140	;;IS	IT UPPER CASE?	
	BLT	4$		;;BRANCH IF YES	
	CMP	4(SP),#175	;;IS	IT	A SPECIAL CHAR?	
	BGT	4$		;;BRANCH IF YES	
	BIC	#40,4(SP)	;;MAKE	IT UPPER CASE	
4$:	RTI	;;GO BACK TO USER	
;;***************************************************************
;*THIS ROUTINE WILL INPUT A STRING FROM THE TTY	
;*CALL:				
;*	RDLIN			;;INPUT A STRING FROM THE TTY			
;*	RETURN HFRE		;;ADDRESS OF FIRST CHARACTER WILL BE ON	THE STACK
;*				;;TERMINATOR WILL BE A BYTE OF ALL 0'S 

$RDLIN: MOV	R3,-(SP)	;;SAVE			
	CLR	-(SP)		;;CLEAR THE RUBOUT KEY			
1$:	MOV	#$TTYIN,R3	;;GET ADDRESS			
2$:	CMP	#$TTYIN+8.,R3	;;BUFFER	FULL?			
	BLOS	4$		;;BR	IF	YES			
	RDCHR			;;GO READ ONE CHARACTER FROM THE TTY 
	MOVB	(SP)+,(R3)	;;GET CHARACTER			
	CMPB	#3,(R3)		;;IS IT A CONTROL-C?			
	BNE	10$		;;BRANCH	IF NO			
	TYPE	,$CNTLC		;;TYPE A CONTROL-C ("C)			
	TST	(SP)+		;;CLEAN RUBOUT KEY OFF OF THE STACK 
	MOV	(SP)+,R3	;;RESTORE R3			
	JMP	CNTRLC		;;GOTD< CONTROL-C RESTART			
10$:	CMPB	#177,(R3)	;;IS	IT A RUBOUT			
	BNE	5$		;;BR	IF	NO			
	TST	(SP)		;;IS THIS THE FIRST RUBOUT?			
	BNE	6$		;;BR	IF	NO			
	MOVB	#'\,9$		;;TYPE A BACK SLASH			
	TYPE	,9$				
	MOV	#-1,(SP)	;;SET THE RUBOUT KEY			
6$:	DEC	R3		;;BACKUP BY ONE			
	CMP	R3,#$TTYIN	;;STACK EMPTY?			
	BLO	4$		;;BR	IF	YES			
	MOVB	(R3),9$		;;SETUP TO TYPEOUT THE DELETED CHAR. 
	TYPE	,9$		;;GO TYPE			
	BR	2$		;;GO READ ANOTHER CHAR.			
5$:	TST	(SP)		;;RUBOUT KEY SET?			
	BEQ	7$		;;BR	IF	NO			
	MOVB	#'\,9$		;;TYPE A BACK SLASH			
	TYPE	,9$				
	CLR	(SP)		;;CLEAR THE RUBOUT KEY			
7$:	CMPB	#25,(R3)	;;IS CHARACTER A CTRL U?			
	BNE	8$		;;BR	IF NO			
	TYPE	,$CNTLU		;;TYPE A CONTROL .U.			
	BR	1$		;;GO START OVER			
8$:	CMPB	#22,(R3)	;;IS CHARACTER A "-R"?
	BNE	3$		;;BRANCH	IF NO			
	CLRB	(R3)		;CLEAR THE CHARACTER			
	TYPE	,$CRLF		;;TYPE	A	"CR"	&	"LF" 
	TYPE	,$TTYIN		;;TYPE THE INPUT STRING			
	BR	2$		;;GO PICKUP ANOTHER CHACTER			
4$:	TYPE	,$QUES		;TYPE	A	'?'			
	BR	1$		;;CLEAR THE BUFFER AND LOOP			
3$:	MOVB	(R3),9$		l;ECHO THE CHARACTER			
	TYPE	,9$				
	CMPB	#15,(R3)+	;;CHECK FOR RETURN			
	BNE	2$		;;LOOP IF NOT RETURN			
	CLRB	-1(R3)		;;CLEAR RETURN	(THE	15)			
	TYPE	,$LF		;;TYPE A LINE FEED			
	TST	(SP)+		;;CLEAN RUBOUT KEY FROM THE STACK 
	MOV	(SP)+,R3	;;RESTORE R3			

	MOV	(SP),-(SP)	;;ADJUST THE STACK AND PUT ADDRESS OF	THE
	MOV	4(SP),2(SP)	;;FIRST ASCII CHARACTER ON IT	
	MOV	#$TTYIN,4(SP)	
	RTI			;;RETURN	
9$:	.BYTE	0		;;STORAGE FOR ASCII CHAR.	TO TYPE	
	.BYTE	0		;;TERMINATOR	
$TTYIN:	.BLKB	8.		;;RESERVE 8 BYTES FOR TTY INPUT	
$CNTLC:	.ASCIZ	/^C/<15><12>	;;CONTROL "C"
$CNTLU:	.ASCIZ	/^U/<15><12>	;;CONTROL "U"	
$CNTLG:	.ASCIZ	/^G/<15><12>	;;CONTROL "G"	
$MSWR:	.ASCIZ	<15><12>/SWR = /	
			
$MNEW:	.ASCIZ	/  NEW = /	
			
.EVEN		
			
.SBTTL	CONTROL-C SERVICING ROUTINE	
			
;*	THE FOLLOWING CODE IS EXECUTED WHEN A CONTROL-C HAS	
;*	BEEN TYPED INSTEAD OF A NEW SWITCH REG, VALUE.	
;*.	(IN OTHER WORDS, AFTER A CONTROL-G WAS TYPED).
;*	A NEW SWITCH REG. VALUE WILL BE ASKED FOR,
;*	THE TEST NUMBER AND PASS NUMBER WILL BE TYPED,
;*	AND THEN THE PROGRAM WILL GO TO "END-OF-PASS" AND CONTINUE
	
CNTRLC: MOV	SPASS,STMP5	;GET THE VALUE OF "SPASS"
	INC	$TMP5		;FORM CURRENT PASS NO.
	TYPE	,CMSG		;TYPE THE TEST STOPS MESSAGE
	MOVB	$TSTNM,1$	;SAVE THE TEST NUMBER
	MOV	1$,-(SP)	;;SAVE 1$ FOR TYPEOUT
	TYPOC			;;GO TYPE--OCTAL ASCII(ALL DIGITS)
	TYPE	,2$		;TYPE 2 SPACES
	MOV	$TMP5,-(SP)	;;SAVE SIMP5 FOR TYPEOUT
	TYPDS			;;GO TYPE--DECIMAL ASCII WITH SIGN
	GTSWR			;ASK FOR NEW SWR VALUE
	JMP	$EOP+2	;CONTINUE AT 5E0P+2
1$:	.WORD	0	;BUFFER FOR TEST NUMBER
2$:	.ASCIZ	/  /	;TWO SPACES AND THE STOP MESSAGE
CMSG:	.ASCII	/JUMPING TO END-OF-PASS/<15><12>
	.ASCIZ	/TESTNO PASSNO/<15><12>
	.EVEN
.SBTTL	TYPE ROUTINE
	
;;***************************************************************
;*ROUTINE TO TYPE ASCIZ MESSAGE. MESSAGE MUST TERMINATE WITH A 0 BYTE.
;*THE ROUTINE WILL INSERT A NUMBER OF NULL CHARACTERS AFTER A LINE FEED.
;*NOTE1:	SNULL CONTAINS THE CHARACTER TO BE USED AS THE FILLER CHARACTER.
;*NOTE2:	$FILLS CONTAINS THE NUMBER OF FILLER CHARACTERS REQUIRED.
;*NOTE3:	$FILLC CONTAINS THE CHARACTER TO FILL AFTER.
;*
;*CALL:
;1) USING A TRAP INSTRUCTION
;*	TYPE	,MESADR		;;MESADR IS FIRST ADDRESS OF AN ASCIZ STRING
;*OR
;*	TYPE
;*	MESADR
;*

$TYPE:	TSTB	$TPFLG		;;IS THERE A TERMINAL?
	BPL	1$		;;BR	IF YES
	HALT			;;HALT HERE IF NO TERMINAL
	BR	3$		;;LEAVE
1$:	MOV	R0,-(SP)	;;SAVE RO
	MOV	@2(SP),R0	;;GET ADDRESS OF ASCIZ STRING
	CMPB	#APTENV,$ENV	;;RUNNING IN APT MODE
	BNE	62$	;;NO,GO CHECK FOR APT CONSOLE
	BITB	#APTSPOOL,$ENVM ;;SPOOL MESSAGE TO APT
	BE0	62$		;;NO,GO CHECK FOR CONSOLE
	MOV	R0,61$		;;SETUP MESSAGE ADDRESS FOR APT
	JSR	PC,$ATY3	;;SPOOL MESSAGE TO APT

61$:	.WORD	0		;;MESSAGE ADDRESS
62$:	BITB	#APTCSUP,$ENVM	;;APT CONSOLE SUPPRESSED
	BNE	60$		;;YES,SKIP TYPE OUT
2$:	MOVB	(R0)+,-(SP)	;;PUSH CHARACTER TO BE TYPED ONTO STACK
	BNE	4$		;;BR IF	IT ISN'T THE TERMINATOR
	TST	(SP)+		;;IF TER .INATOR POP IT OFF THE STACK
60$:	MOV	(SP)+,R0	;;RESTORE RO
3$:	ADD	#2,(SP)		;;ADJUST RETURN PC
	RTI			;;RETURN
4$:	CMPB	#HT,(SP)	;;BRANCH IF <HT>
	BE0	8$	
	CMPB	#CRLF,(SP)	;;BRANCH IF NOT <CRLF>
	BNE	5$	
	TST	(SP)+		;;POP	<CR><LF> EQUIV
	TYPE			;;TYPE A CR AND LF
	$CRLF	
	CLRB	$CHARCNT	;;CLEAR CHARACTER COUNT
	BR	2$		;;GET NEXT CHARACTER
5$:	JSR	PC,$TYPEC	;;GO TYPE THIS CHARACTER
6$:	CMPB	$FILLC,(SP)+	;;IS	IT TIME	FOR FILLER CHARS.?
	BNE	2$		;;IF NO GO GET NEXT CHAR.
	MOV	$NULL,-(SP)	;;GET # OF FILLER CHARS.	NEEDED
				;;AND THE NULL CHAR.
7$:	DECB	1(SP)		;;DOES A NULL NEED TO BE TYPED?
	BLT	6$		;;BR IF NO--00 POP THE NULL OFF OF STACK
	JSR	PC,$TYPEC	;;GO TYPE A NULL
	DECB	$CHARCNT	;;DO NOT COUNT AS A COUNT
	BR	7$		;;LOOP
	
;HORIZONTAL TAB PROCESSOR	
	
8$:	MOVB	#' ,(SP)	;;REPLACE TAB WITH SPACE
9$:	JSR	PC,$TYPEC	;;TYPE A SPACE
	BITB	#7,$CHARCNT	;;BRANCH IF NOT AT
	BNE	9$		;;TAB STOP
	TST	(SP)+		;;POP SPACE OFF STACK
	BR	2$		;;GET NEXT CHARACTER
$TYPEC:	TSTB	@$TPS		;;WAIT UNTIL PRINTER IS READY
	BPL	$TYPEC	
	MOVB	2(SP),@$TPB	;;LOAD CHAR TO DC TYPED INTO DATA REG.
	CMPB	#CR,2(SP)	;;IS CHARACTER A CARRIAGE RETURN?
	BNE	1$		;;BRANCH	IF NO
	CLRB	$CHARCNT	;;YES--CLEAR CHARACTER COUNT
	BR	$TYPEX		;;EX1T
1$:	CMPB	#LF,2(SP)	;;IS CHARACTER A LINE FEED?
	BEQ	$TYPEX		;;BRANCH IF YES
	INCB	(PC)+		;;COUNT THE CHARACTER
SCHARCNT:.WORD	0	;;CHARACTER COUNT STORAGE
$TYPEX: RTS	PC	
	
.SBTTL	APT COMMUNICATIONS ROUTINE	
	
;;****************************************************************	
$ATY1:	MOVB	#1,$FFLG	;;TO REPORT FATAL ERROR
$ATY3:	MOVB	#1,$MFLG	;;TO TYPE A MESSAGE
	BR	$ATYC	

$ATY4:	MOVB	#1,SFFLG	;;TO ONLY REPORT FATAL ERROR	
$ATYC:	
	MOV	R0,-(SP)	;;PUSH RO ON STACK	
	MOV	R1,-(SP)	;;PUSH R1	ON STACK	
	TSTB	$MFLG		;;SHOULD TYPE A MESSAGE?	
	BEQ	5$		;;IF NOT:	BR	
	CMPB	#APTENV,$ENV	;;OPERATING UNDER APT?	
	BNE	3$		;;IF NOT:	BR	
	BITB	#APTSPOOL,$ENVM	;;SHOULD SPOOL MESSAGES?	
	BEQ	3$		;;IF NOT:	BR	
	MOV	@4(SP),R0	;;GET MESSAGE ADDR.	
	ADD	#2,4(SP)		;;BUMP RETURN ADDR.	
1$:	TST	$MSGTYPE	;;SEE IF DONE W/ LAST OMISSION?	
	BNE	1$		;;IF NOT:	WAIT	
	MOV	R0, $MSGAD	;;PUT ADDR IN MAILBOX	
2$:	TSTB	(R0)+		;;FIND END OF MESSAGE	
	BNE	2$
		
	SUB	$MSGAD,R0	;;SUB START OF MESSAGE	
	ASR	R0		;;GET MESSAGE LNGTH IN WORDS	
	MOV	R0,$MSGLGT	;;PUT LENGTH IN MAILBOX	
	MOV	#4,$MSGTYPE	;;TELL APT TO TAKE MSG.	
	BR	5$	
3$:	MOV	@4(SP),45	;;PUT MSG ADDR IN JSR LINKAGE	
	ADD	#2,4(SP)		;;BUMP RETURN ADDRESS	
	MOV	177776,-(SP)	;;PUSH 177776 ON STACK	
	JSR	PC,$TYPE	;;CALL TYPE MACRO	
4$:	.WORD	0	
5$:	
10$:	TSTB	$FFLG		;;SHOULD REPORT FATAL ERROR?
	BEQ	12$		;;IF NOT:	BR	
	TST	$ENV		;;RUNNING UNDER APT?	
	BEQ	12$		;;OF NOT	BR	
11$:	1ST	$MSGTYPE	;FINISHED LAST MESSAGE?	
	BNE	11$		;;IF NOT:	WAIT	
	MOV	@4(SP),SFATAL	;;GET ERROR #	
	ADD	#2,4(SP)	      ;;BUMP RETURN ADDR.	
	INC	$MSGTYPE	;;TELL APT TO TAKE ERROR	
12$:	CLRB	$FFLG		;;CLEAR FATAL FLAG	
	CLRB	$LFLG		;;CLEAR LOG FLAG	
	CLRB	$MFLG		;;CLEAR MESSAGE FLAG	
	MOV	(SP)+,R1	;;POP STACK INTO RI	
	MOV	(SP)+,R0	;;POP STACK INTO RO	
	RTS	PC		;;RETURN	
$MFLG:	.BYTE	0		;;MESSG.	FLAG	
$LFLG:	.BYTE	0		;;LOG FLAG	
$FFLG:	.BYTE	0		;;FATAL FLAG	
	.EVEN	
APTSIZE=200	
APTENV=001	
APTSPOOL=100	
APTCSUP=040	
.SBTTL	BINARY TO ASCII AND TYPE ROUTINE	

;****************************************************************
;*THIS ROUTINE IS USED TO CHANGE A 16-BIT BINARY NUMBER TO A 16-BIT	
;*BINARY-ASCII NUMBER AND TYPE IT.	
;*CALL:
;*	MOV	NUMBER,-(SP)	;;NUMBER TO BE TYPED
;*	TYPBN			;;TYPE IT

$TYPBN: MOV	R1,-(SP)	;;SAVE R1	ON THE STACK
	MOV	6(SP),R1	;;GET THE INPUT NUMBER
	SEC			;;SET "C" SO CAN KEEP TRACK OF THE NUMBER OF BITS
1$:	MOVB	#'0,$BIN	;;SET CHARACTER TO AN ASCII "0".
	ROL	R1		;;GET THIS BIT
	BEQ	2$		;;DONE?
	ADCB	$BIN		;;NO--SET THE CHARACTER EQUAL TO THIS BIT
	TYPE	,$BIN		;;GO TYPE THIS BIT
	CLC			;;CLEAR "C" SO CAN KEEP TRACK OF BITS
	BR	1$		;;GO DO THE NEXT BIT
2$:	MOV	(SP)+,R1	;;POP THE STACK INTO R1
	MOV	2(SP),4(SP)	;;ADJUST THE STACK
	MOV	(SP)+,(SP)
	RTI			;;RETURN TO USER
$BIN:	.BYTE	0,0		;;STORAGE FOR ASCII CHAR	AND TERMINATOR
.SBTTL	BINARY TO OCTAL (ASCII) AND TYPE

;;***************************************************************
;*THIS ROUTINE IS USED TO CHANGE A 16-BIT BINARY NUMBER TO A 6-DIGIT
;*OCTAL (ASCII) NUMBER AND TYPE IT.
;*$TYPOS---ENTER HERE TO SETUP SUPPRESS ZEROS AND NUMBER OF DIGITS TO TYPE
;*CALL:
;*	MOV	NUM,-(SP)	;;NUMBER TO BE TYPED
;*	TYPOS			;;CALL FOR TYPEOUT
;*	.BYTE	N		;;N=1 TO 6 FOR NUMBER OF DIGITS TO TYPE
;*	.BYTE	M		;;M=1 OR 0
;*					;;1=TYPE LEADING ZEROS
;*					;;O=SUPPRESS LEADING ZEROS
;*
;*$TYPON----ENTER HERE TO TYPE OUT WITH THE SAME PARAMETERS AS THE LAST
;*$TYPOS OR $TYPOC
;*CALL:
;*	MOV	NUM,-(SP)	;;NUMBER TO BE TYPED
;*	TYPON			;:CALL FOR TYPEOUT
;*
;*$TYPOC---ENTER HERE FOR TYPEOUT OF A 16 BIT NUMBER
;*CALL:
;*	MOV	NUM,-(SP)	;;NUMBER TO BE TYPED
;*	TYPOC			;;CALL FOR TYPEOUT

$TYPOS: MOV	@(SP),-(SP)	;;PICKUP THE MODE
	MOVB	1(SP),$OFILL	;;LOAD ZERO FILL SWITCH
	MOVB	(SP)+,$OMODE+1	;;NUMBER OF DIGITS TO TYPE
	ADD	#2,(SP)		;;ADJUST RETURN ADDRESS
	BR	$TYPON
$TYPOC: MOVB	#1,$0FILL	;;SET THE ZERO FILL SWITCH
	MOVB	#6,$OMODE+1	;;SET FOR SIX(6)	DIGITS
$TYPON: MOVB	#5,$OCNT	;;SET THE ITERATION COUNT
	MOV	R3,-(SP)	;;SAVE R3
	MOV	R4,-(SP)	;;SAVE R4
	MOV	R5,-(SP)	;;SAVE R5
	MOVB	$OMODE+1,R4	;;GET THE NUMBER OF DIGITS TO TYPE
	NEG 	R4
	ADD 	#6,R4		;;SUBTRACT IT FOR MAX. ALLOWED
	MOVB	R4,$OMODE	;;SAVE IT FOR USE
	MOV	$OFILL,R4	;;GET THE ZERO FILL SWITCH
	MOV	12(SP),R5	;;PICKUP THE INPUT NUMBER
	CLR	R3		;;CLEAR	HE OUTPUT WORD
1$:	ROL	R5		;;ROTATE MSB INTO "C"
	BR	3$		;;GO DO MSB
2$:	ROL	R5		;;FORM THIS DIGIT
	ROL	R5
	ROL	R5
	MOV	R5,R3
3$:	ROL	R3		;;GET LSB OF THIS DIGIT
	DECB	$OMODE		;;TYPE THIS DIGIT?
	BPL 	7$	       ;;BR	IF NO

	BIC	#177770,R3	;;GET RID OF JUNK
	BNE	4$		;;TEST	FOR 0
	TST	R4		;;SUPPRESS THIS 07
	BEQ	5$		;;BR	IF	YES
4$:	INC	R4		;;DON'T SUPPRESS ANYMORE 0'S
	BIS	#'0,R3		;;MAKE THIS DIGIT ASCII
5$:	BIS	#' ,R3		;;MAKE ASCII	IF NOT ALREADY
	MOVB	R3,8$		;;SAVE FOR TYPING
	TYPE	,8$		;;GO TYPE THIS DIGIT
7$:	DECB	$OCNT		;;COUNT BY 1
	BGT	2$		;;BR IF MORE TO DO
	BLT	6$		;;BR	IF DONE
	INC	R4		;;INSURE	LAST DIGIT	ISN'T A BLANK
	BR	2$		;;GO DO THE LAST DIGIT
6$:	MOV	(SP)+,R5	;;RESTORE R5
	MOV	(SP)+,R4	;;RESTORE R4
	MOV	(SP)+,R3	;;RESTORE R3
	MOV	2(SP),4(SP)	;;SET THE STACK FOR RETURNING
	MOV	(SP)+,(SP)
	RTI			;;RETURN
8$:	.BYTE	0		;;STORAGE FOR ASCII DIGIT
	.BYTE	0		;;TERMINATOR FOR TYPE ROUTINE
$OCNT:	.BYTE	0		;;OCTAL DIGIT COUNTER 
$OFILL:	.BYTE	0		;;ZERO FILL SWITCH 
$OMODE:	.WORD	0		;;NUMBER OF DIGITS TO TYPE
.SBTTL	CONVERT	BINARY TO DECIMAL AND TYPE ROUTINE

;;**************************************************************
;*THIS ROUTINE IS USED TO CHANGE A 16-BIT BINARY NUMBER TO A 5-DIGIT
;*SIGNED DECIMAL (ASCII) NUMBER AND TYPE IT.  DEPENDING ON WHETHER THE 
;*NUMBER IS POSITIVE OR NEGATIVE A SPACE OR A MINUS SIGN WILL BE TYPED.
;*BEFORE THE FIRST DIGIT OF THE NUMBER.  LEADING ZEROS WILL ALWAYS BE
;*REPLACED WITH SPACES. 
;*CALL:	
;*	MOV	NUM,-(SP)	;;PUT THE BINARY NUMBER ON THE STACK 
;*	TYPDS			;;GO TO THE ROUTINE

$TYPDS:
	MOV	R0,-(SP)	;;PUSH RO ON STACK 
	MOV	R1,-(SP)	;;PUSH R1 ON STACK 
	MOV	R2,-(SP)	;;PUSH R2 ON STACK
	MOV	R3,-(SP)	;;PUSH R3 ON STACK	
	MOV	R5,-(SP)	;;PUSH R5 ON STACK	
	MOV	#20200,-(SP)	;;SET BLANK SWITCH AND SIGN	
	MOV	20(SP),R5	;;GET THE INPUT NUMBER	
	BPL	1$		;;BR	IF	INPUT	IS POS.	
	NEG	R5		;;MAKE THE BINARY NUMBER POS.	
	MOVB	#'-,1(SP)	;;MAKE THE ASCII NUMBER NEG.	
1$:	CLR	R0		;;ZERO THE CONSTANTS INDEX	
	MOV	#$DBLK,R3	;;SETUP THE OUTPUT POINTER	
	MOVB	#' ,(R3)+	;;SET THE FIRST CHARACTER TO A BLANK	
2$:	CLR	R2		;;CLEAR THE BCD NUMBER	
	MOV	$DTBL(R0),R1	;;GET THE CONSTANT	
3$:	SUB	R1,R5		;;FORM THIS BCD DIGIT	
	BLT	4$		;;BR IF	DONE	
	INC	R2		;;INCREASE THE BCD DIGIT BY 1	
	BR	3$	
4$:	ADD	R1,R5		;;ADD BACK THE CONSTANT	
	TST	R2		;;CHECK IF BCD DIGIT=0	
	BNE	5$		;;FALL THROUGH IF 0	
	TSTB	(SP)		;;STILL DOING LEADING O'S?	
	BMI	7$		;;BR	IF YES	
5$:	ASLB	(SP)		;;MSD7	
	BCC	6$		;;BR IF NO	
	MOVB	1(SP),-1(R3)	;;YES--SET THE SIGN	
6$:	BIS	#'0,R2		;;MAKE THE BCD DIGIT ASCII	
7$:	BIS	#' ,R2		;;MAKE IT A SPACE IF NOT ALREADY A DIGIT	
	MOVB	R2,(R3)+	;;PUT THIS CHARACTER IN THE OUTPUT BUFFER	
	TST	(R0)+		;;JUST	INCREMENTING	
	CMP	R0,#10		;;CHECK THE TABLE INDEX	
	BLT	2$		;;GO DO THE NEXT DIGIT	
	BGT	8$		;;GO TO EXIT	
	MOV	R5,R2		;;GET THE LSD	
	BR	6$		;;GO CHANGE TO ASCII	
8$:	TSTB	(SP)+		;;WAS THE LSD THE FIRST NON-ZERO?	
	BPL	9$		;;BR IF ND	
	MOVB	-1(SP),-2(R3)	;;YES--SET THE SIGN FOR TYPING	
9$:	CLRB	(R3)		;;SET THE TERMINATOR	
	MOV	(SP)+,R5	;;POP STACK INTO R5	
	MOV	(SP)+,R3	;;POP STACK INTO R3	
	MOV	(SP)+,R2	;;POP STACK INTO R2	
	MOV	(SP)+,R1	;;PDP STACK INTO R1
	MOV	(SP)+,R0	;;POP STACK INTO R0	
	TYPE	,$DBLK		;;NOW TYPE THE NUMBER	
	MOV	2(SP),4(SP)	;;ADJUST THE STACK	
	MOV	(SP)+,(SP)	
	RTI			;;RETURN TO USER	
$DTBL:	10000.	
	1000.	
	100.	
	10.	
$DBLK:	.BLKW	4	
.SBTTL	SAVE AND RESTORE R0-R5 ROUTINES	
				
;;***************************************************************	
;*SAVE R0-R5	
;*CALL:	
;*	SAVREG			
;*UPON RETURN FROM $SAVREG THE STACK WILL LOOK LIKE:			
;*			
;*TOP---(+16)			
;* +2---(+18)			
;* +4---R5			
;* +6---R4			
;* +8---R3			
;*+10---R2			
;*+12---R1			
;*+14---R0			
				
$SAVREG: 			
	MOV	R0,-(SP)	;;PUSH R0 ON STACK			
	MOV	R1,-(SP)	;;PUSH R1 ON STACK			
	MOV	R2,-(SP)	;;PUSH R2 ON STACK			
	MOV	R3,-(SP)	;;PUSH,(13 ON STACK			
	MOV	R4,-(SP)	;;PUSHIS4 ON STACK			
	MOV	R5,-(SP)	;;PUSH R5 ON STACK			
	MOV	22(SP),-(SP)	;;SAVE PS OF MAIN FLOW			
	MOV	22(SP),-(SP)	;;SAVE PC OF MAIN FLOW			
	MOV	22(SP),-(SP)	;;SAVE PS OF CALL			
	MOV	22(SP),-(SP)	;;SAVE PC OF CALL			
	RTI			
				
;*RESTORE R0-R5			
;*CALL:			
;*	RESREG
$RESREG: 			
	MOV	(SP)+,22(SP)	;;RESTORE PC OF CALL 
	MOV	(SP)+,22(SP)	;;RESTORE PS OF CALL			
	MOV	(SP)+,22(SP)	;;RESTORE PC OF MAIN FLOW			
	MOV	(SP)+,22(SP)	;;RESTORE PS OF MAIN FLOW			
	MOV	(SP)+,R5	;;POP STACK INTO R5			
	MOV	(SP)+,R4	;;POP STACK INTO R4			
	MOV	(SP)+,R3	;;POP STACK INTO R3			
	MOV	(SP)+,R2	;;POP STACK INTO R2			
	MOV	(SP)+,R1	;;POP STACK INTO R1			
	MOV	(SP)+,R0	;;POP STACK INTO RO			
	RTI			
.SBTTL	DOUBLE LENGTH BINARY TO OCTAL ASCII CONVERT ROUTINE			
			
;;*************************************************************** 
;*THIS ROUTINE WILL CONVERT A 32-BIT UNSIGNED BINARY NUMBER TO AN 
;*UNSIGNED OCTAL ASCIZ NUMBER. 
;*CALL			
;*	MOV	NPNTR,-(SP)	;;POINTER TO LOW WORD OF BINARY NUMBER 
;*	JSR	PC,ONSDB20	;;CALL THE ROUTINE			
;*	RETURN			;;THE ADDRESS OF THE FIRST ASCIZ CHAR. IS ON THE STACK
			
$DB20:	SAVREG			;;SAVE ALL REGISTERS			
	MOV	2(SP),R1	;;PICKUP THE POINTER TO LOW WORD 
	MOV	#$OCTVL+13.,R5	;;POINTER TO DATA TABLE			
	MOV	#12.,R4		;;DO	CHARACTERS			
	MOV	#^C7,R3			

	MOV	(R1)+,R0	;;LOWER WORD
	MOV	(R1)+,R1	;;HIGH WORD
	CLR	R2		;;TERMINATOR
1$:	MOVB	R2,-(R5)	;;PUT CHARACTER IN DATA TABLE
	MOV	R0,R2		;:GET THIS DIGIT
	DEC	R4		;;COUNT	THIS CHARACTER
	BGT	3$		;;BR IF NOT THE LAST DIGIT
	BED	2$		;;BR IF	IT	IS THE LAST DIGIT
	INC	R5		;;ALL DIGITS DONE?ADJUST POINTER FOR FIRST
	MOV	R5,2(SP)	;;ASCIZ CHAR. 8 PUT IT ON THE STACK
	RESREG			;;RESTORE ALL REGISTERS
	RTS	PC		;;RETURN TO USER
2$:	ASR	R3		;;POSITION THE MASK FOR THE LAST DIGIT
3$:	ROR	R1		;;POSITION THE BINARY NUMBER FOR
	ROR	R0		;;	THE NEXT OCTAL DIGIT
	ROR	R1	
	ROR	R0	
	ROR	R1	
	ROR	R0	
	BIC	R3,R2		;;MASK OUT ALL JUNK
	ADD	#'0,R2		;;MAKE THIS CHAR. ASCII
	BR	1$		;;GO PUT IT IN THE DATA TABLE
$OCTVL:	.BLKB	14.		;;RESERVE DATA TABLE

.SBTTL	TRAP DECODER
	
;;***************************************************************
;*THIS ROUTINE WILL PICKUP THE LOWER BYTE OF THE "TRAP" INSTRUCTION
;*AND USE IT TO INDEX THROUGH THE TRAP TABLE FOR THE STARTING ADDRESS
;*OF THE DESIRED ROUTINE. THEN USING THE ADDRESS OBTAINED IT WILL
;*GO TO THAT ROUTINE.
	
$TRAP:	MOV	R0,-(SP)	;;SAVE R0
	MOV	2(SP),R0	;;GET TRAP ADDRESS
	TST	-(R0)		;;BACKUP BY 2
	MOVB	(R0),R0		;;GET RIGHT BYTE OF TRAP
	ASL	R0		;;POSITION FOR INDEXING
	MOV	$TRPAD(R0),R0	;;INDEX TO TABLE
	RTS	R0		;;GO TO ROUTINE
	
	
;;THIS IS USE TO HANDLE THE "GETPRI" MACRO
	
$TRAP2: MOV	(SP),-(SP)	;;MOVE THE PC rowN
	MOV	4(SP),2(SP)	;;MOVE THE P5W DOWN
	RTI			;;RESTORE THE PSW
	
.SBTTL	TRAP TABLE
	
;*THIS TABLE CONTAINS THE STARTING ADDRESSES OF THE ROUTINES CALLED
;?BY THE "TRAP"	INSTRUCTION.
	
;	ROUTINE
;	-------	
$TRPAD:	.WORD	$TRAP2
	$TYPE	;;CALL=TYPE	TRAP+1(104401)	TTY TYPEOUT ROUTINE
	$TYPOC	;;CALL=TYPOC	TRAP+2(104402)	TYPE OCTAL NUMBER (WITH LEADING ZEROS)
	$TYPOS	;;CALL=TYPOS	TRAP+3(104403)	TYPE OCTAL NUMBER (NO LEADING ZEROS)
	$TYPON	;;CALL=TYPON	TRAP+4(104404)	TYPE OCTAL NUMBER (AS PER LAST CALL)
	$TYPDS	;;CALL=TYPDS	TRAP+5(104405)	TYPE DECIMAL NUMBER (WITH SIGN)
	$TYPBN	;;CALL=TYPBN	TRAP+6(104406)	TYPE BINARY (ASCII) NUMBER
	
	$GTSWR	;;CALL=GTSWR	TRAP+7(104407)	GET SOFT-SWR SETTING
	
	$CKSWR	;;CALL=CKSWR	TRAP+10(104410)	VEST FOR CHANGE IN SUFI-SWR
	$RDCHR	;;CALL=RDCHR	TRAP+11(104411) TTY TYPEIN CHARACTER ROUTINE
	$RDLIN	;;CALL=RDLIN	TRAP+12(104412) TTY TYPEIN STRING ROUTINE
	$SAVREG ,;CALL=SAVREG	TRAP+13(104413) SAVE R0-R5 ROUTINE
	$RESREG ;;CALL=RESREG	TRAP+14(104414) RESTORE R0-R5 ROUTINE
.SBTTL	POWER DOWN AND UP ROUTINES
	
;;***************************************************************
;POWER DOWN ROUTINE
$PWRDN: MOV	#$ILLUP,@#PWRVEC ;;SET FOR FAST UP
	MOV	#340,@#PWRVEC+2 ;;PRIO:7
	MOV	R0,-(SP)	;;PUSH R0 ON STACK
	MOV	R1,-(SP)	;;PUSH R1 ON STACK
	MOV	R2,-(SP)	;;PUSH R2 ON STACK
	MOV	R3,-(SP)	;;PUSH R3 ON STACK
	MOV	R4,-(SP)	;;PUSH R4 ON STACK
	MOV	R5,-(SP)	;;PUSH R5 ON STACK
	MOV	@SWR,-(SP)	;;PUSH @SWR ON STACK
	MOV	SP,SSAVR6	;;SAVE SP
	MOV	#SPWRUP,@#PWRVEC ;;SET UP VECTOR
	HALT		
	BR	.-2	;;HANG UP


;;*********************************************************************
;POWER UP ROUTINE			
$PWRUP: MOV	#$ILLUP,@#PWRVEC ;;SET FOR FAST DOWN
	MOV	SSAVR6,SP	;;GET SP
	CLR	SSAVR6		;;WAIT LOOP FOR THE TTY
1$:	INC	SSAVR6		;;WAIT FOR THE INC
	BNE	1$		;;OF WORD
	MOV	(SP)+,@SWR	;;POP STACK INTO @SWR
	MOV	(SP)+,R5	;;POP STACK INTO R5
	MOV	(SP)+,R4	;;POP STACK INTO R4
	MOV	(SP)+,R3	;;POP STACK INTO R3
	MOV	(SP)+,R2	;;PDP STACK INTO R2
	MOV	(SP)+,R1	;;POP STACK INTO R1
	MOV	(SP)+,R0	;;PDP STACK INTO R0
	MOV	#$PWRDN,@#PWRVEC ;;SET UP THE POWER DOWN VECTOR
	MOV	#340,@#PWRVEC+2	;;PRIO:7
	TYPE			;;REPORT THE POWER FAILURE
$PWRMG:	.WORD	PWRMSG		;;POWER FAIL MESSAGE POINTER
	MOV	(PC)+,(SP)	;;RESTAP- AT START
$PWRAD:	.WORD	START		;;RESTART ADDRESS
	BIC	#20,2(SP)	;;CLEAR	.T"	BIT
	CLR	STBIT		;;CLEAR THE "T" BIT FLAG
	RTI		
$ILLUP:	HALT			;;THE POWER UP SEQUENCE WAS STARTED
	BR	.-2		;; BEFORE THE POWER DOWN WAS COMPLETE
$SAVR6:	0			;;PUT THE SP HERE
PWRMSG:	.ASCIZ	<12><15>? POWER FAILURE - RESTARTING ?(12><15>	
			
	.EVEN		

.SBTTL	ERROR MESSAGES, DATA HEADERS?TABLES 8 FORMATS	
EM1:	.ASCIZ	/UNEXPECTED CPU TRAP TO LOC. 004/	
EM2: 	.ASCIZ	/UNEXPECTED MEM. MGMT. TRAP TO LOC. 250/	
EM3: 	.ASCIZ	/PRIORITY BITS SET WRONG IN PSW/	
EM4: 	.ASCIZ	/MODE BITS SET WRONG IN PSW/	
EM5:	.ASCIZ	/DUAL ADDRESSING BETWEEN HI8L0 BYTES OF	PSW/
EM6:	.ASCIZ	/KERNEL RB CHANGED BY WRITING USER RB/	
EM7:	.ASCIZ	/A MEMORY MGMT. REG. TIMED OUT/	
EM10: 	.ASCIZ	/SUMMARY OF MEM. MGMT. REG. TIMEOUTS/	
EM11: 	.ASCIZ	/MEM. MGMT. REG. WOULD NOT CLEAR/	
EM12: 	.ASCIZ	/MEM. MGMT. REG. BITS NOT SET CORRECTLY/
EM13: 	.ASCIZ	/SRO EFFECTED BY WRITE TO PSW/
EM14: 	.ASCIZ	/SRI DID NOT READ ALL ZEROS/
EM15: 	.ASCIZ	/DUAL ADDRESSING BETWEEN BYTES OF PAR OR PDR/
EM16:	.ASCIZ	/DUAL ADDRESSING BETWEEN PAR?PDR'S/
EM17:	.ASCIZ	/PHYS. ADDR. FORMED WRONG IN MAINT. MODE/
EM20: 	.ASCIZ	/PHYS. ADDR. FORMED WRONG IN RELOCATE MODE/
EM21: 	.ASCIZ	/W?BIT DID NOT GET SET IN PDR/
EM22: 	.ASCIZ	/W?BIT SET IN MORE THAN ONE PDR/
EM23:	.ASCIZ	/W-BIT NOT CLEARED BY WRITING TO PDR/
EM24:	.ASCIZ	/WRITING SRO SET W-BIT IN KIPDR7/
EM25: 	.ASCIZ	/W-BIT GOT SET DURING ODD ADDR. ABORT/
EM26: 	.ASCIZ	/MEMORY MGMT. ACCESS ABORT DID NOT OCCUR/
EM27:	.ASCIZ	/ACCESS ERROR DID NOT ABORT INSTRUCTION/
EM30: 	.ASCIZ	/SRO DID NOT REPORT ACCESS ERROR CORRECTLY/
EM31: 	.ASCIZ	/DID NOT LOCKUP CORRECT VIRTUAL ADDR./
EM32: 	.ASCIZ	/PAGE LGTH. ABORT OCCURRED WHEN IT SHOULDN'T HAVE/
EM33: 	.ASCIZ	/PAGE LGTH. ABORT DID NOT OCCUR WHEN IT SHOULD HAVE/
EM34: 	.ASCIZ	/SRO DID NOT REPORT PAGE LGTH. ABORT CORRECTLY/
EM37:	.ASCIZ	/SRO OR SR2 CHANGED BY A SECOND ABORT/
EM40: 	.ASCIZ	/SRO OR SR2 WERE NOT "RESET. BY A RESET/
EM41: 	.ASCIZ	/SR2 NOT TRACKING CORRECTLY/
EM42: 	.ASCIZ	/DID NOT TRAP THRU KERNEL SPACC/
EM43: 	.ASCIZ	/KT ERROR SERVICED ON ODD ADDR. ERROR/
EM44: 	.ASCIZ	/SRO OR SR2 CHANGED BY ODD ADDR. ERROR/
EM45:	.ASCIZ	/ERROR DURING "DOUBLE ERROR" (KT & ODD ADDR.)/
EM46:	.ASCIZ	/MFPI INSTRUCTION PUSHED WRONG DATA/
EM47:	.ASCIZ	/MTPI INSTRUCTION LOADED WRONG DATA/
EM50:	.ASCIZ	/STACK NOT PUSHED BY MFPI-MTPI/
EM51:	.ASCIZ	/KERNEL PAGE ACCESS INSTEAD OF USER: MFPI-MTPI/
EM52:	.ASCIZ	/WRONG PDR'S REFERENCED WHILE IN RELOCATE MODE/
EM53:	.ASCIZ	/MFPD INSTRUCTION PUSHEC WRONG DATA/
EM54:	.ASCIZ	/STACK NOT PUSHED BY MFPD-MTPD/
EM55:	.ASCIZ	/PAR OR PDR CHANGED BY A RESET/
EM56:	.ASCIZ	/ILLEGAL MODE 01 NOT ABORTED/
EM57:	.ASCIZ	/SRO DID NOT REPORT ILLEGAL MODE 01 CORRECTLY/
EM60:	.ASCIZ	/PSW CHANGED BY AN RIO IN USER MODE/
EM61:	.ASCIZ	/MAINT. MODE (SRO <87,) NOT DISABLED BY A RESET/
EM62:	.ASCIZ	/DATA INCORRECT AFTER A MAINT. MODE WRITE/
EM63:	.ASCIZ	/SOURCE RELOCATED IN MAINT. MODE/
EM64:	.ASCIZ	/NON RESIDENT ABORT DID NOT OCCUR/
EM65:	.ASCIZ	/ERROR FLAG FOR NR ABORT (BIT15) IN SRO DID NOT SET/
EM66: 	.ASCIZ	/SR2 DID NOT FREEZE THE VIRTUAL ADDRS OF THE ABORTD INTR/
EM67: 	.ASCIZ	/2ND NON RESIDENT ABORT DID NOT OCCUR/
EM70:	.ASCIZ	/2ND NON RESIDENT ABORT CAUSED SR2 TO CHANGE/
EM71:	.ASCIZ	/SRO WAS NOT CLEARED BY INIT. /
DH1:	.ASCIZ	/OLD PC	OLD PSW R6 WAS	TESTNO	ERRORPC/
DM2:	.ASCIZ	/OLD PC	OLD PSW R6 WAS	SRO	SR2	TESTNO	ERRORPC/
DH3:	.ASCIZ	/WROTE	READ	TESTNO	ERRORPC/
DH7:	.ASCIZ	/ADDRESS TESTNO	ERRORPC/		
DH10:	.ASCII	/REGISTER-ADDRS	NUM	OF/<CRLF>		
	.ASCIZ	/AND-ED	OR-ED	TIMOUTS TESTNO	ERRORPC/		
DM11: 	.ASCII	/REGISTR READ	READ-(BINARY)/4CRLF>		
	.ASCIZ	/ADDRESS (OCTAL) 5432109876543210	TESTNO	ERRORPC/		
DM12: 	.ASCII	/REGISTR WROTE	READ	READ-(BINARY)/<CRLF>		
	.ASCIZ	/ADDRESS (OCTAL) (OCTAL) 5432109876543210	TESTNO	ERRORPC/	
DH13:	.ASCIZ	/READ	TESTNO	ERRORPC/		
DM16:	.ASCII	/PAR-PDR PAR-PDR/<CRLF>		
	.ASCIZ	/CLEARED EFFECTD EXPECTD RECEIVD TESTNO	ERRORPC/		
DH17:	.ASCII	/PHYSICL VIRTUAL/<CRLF>				
	.ASCIZ	/ADDRESS ADDRESS KIPAR4	TESTNO	ERRORPC/			
DH20: 	.ASCII	/PHYSICL PAR 4	PAR 5/<CRLF>				
	.ASCIZ	/ADDRESS VBA	VBA	PAR 4	PAR 5	PSW	TESTNO	ERRORPC/
DH21: 	.ASCII	/PDR	VIRTUAL/<CRLF>				
	.ASCIZ	/TESTED	ADDRESS TESTNO	ERRORPC/				
DH22: 	.ASCII	/PDR IN	PDR	VIRTUAL/				
	.ASCIZ	/ERROR	TESTED	ADDRESS TESTNO	ERRORPC/			
DH23: 	.ASCIZ	/PDR	TESTNO	ERRORPC/				
DH24:	.ASCIZ	/PDR WAS EXPECTD TESTNO	ERRORPC/	
DH26:	.ASCIZ	/PDR 4	PSW	TESTNO	ERRORPC/	
DH30:	.ASCIZ	/SRO WAS EXPECTD PDR 4	PSW	TESTNO	ERRORPC/
DM31:	.ASCIZ	/SR2 WAS EXPECTD PDR 4	PSW	TESTNO	ERRORPC/
DH32:	.ASCIZ	/V.B.A.	KIPDR4	SRO WAS S82 WAS TESTNO	ERRORPC/
DH33: 	.ASCIZ	/V.B.A.	KIPDR4	TESTNO	ERRORPC/	
DH34: 	.ASCIZ	/V.B.A.	KIPDR4	SRO WAS EXPECTD TESTNO	ERRORPC/
DM35:	.ASCIZ	/V.B.A.	KIPDR4	SR2 WAS EXPECTD TESTNO	ERRORPC/
DH36:	.ASCIZ	/982 WAS EXPECTD TESTNO	ERRORPC/	
DH37:	.ASCII	/FIRST ABORT	SECOND ABORT/<CRLF>	
	.ASCIZ	/SRO WAS 5R2 WAS SRO WAS SR2 WAS TESTNO	ERRORPC/
DH40:	.ASCIZ	/SRO WAS SR2 WAS TESTNO	ERRORPC/	
DH42:	.ASCIZ	/PSW WAS R6 WAS	TESTNO	ERRORPC/	
DH44: 	.ASCII	/EXPECTED	RECEIVED/<CRLF>	
	.ASCIZ	/SRO	SR2	SRO WAS SR2 WAS TESTNO	ERRORPC/
DH45: 	.ASCII	/EXPECTED:/<CRLF>	
	.ASCII	/PSW	PC	SRO	SR2/<CRLF>	
	.ASCII	/170017	(35+4)	020147	(35)/<CRLF>			
	.ASCII	/RECEIVED:/<CRLF>			
	.ASCIZ	/PSW	PC	SRO	SR2	TESTNO	ERRORPC/			
DH46:	.ASCII	/DATA	DATA/<CRLF>			
	.ASCIZ	/EXPECTD RECEIVD TESTNO	ERRORPC/			
DH50:	.ASCIZ	/TESTNO	ERRORPC/			
DH51:	.ASCIZ	/SRO WAS SR2 WAS TESTNO	ERRORPC/			
DH52:	.ASCII	/PHYSICL PAR 4/<CRLF>			
	.ASCIZ	/ADDRESS V.B.A.	PAR 4	SRO WAS SR2 WAS PSW	TESTNO	ERRORPC/	
DH57:	.ASCIZ	/SRO WAS EXPECT() TESTNO	ERRORPC/			
DH60:	.ASCIZ	/PSW WAS EXPECTD TESTNO ERRORPC/
DH61:	.ASCIZ	/SRO	SR2	TESTNO ERRORPC/
DH62:	.ASCIZ	/SR2 EXP 5R2 REC TESTNO ERRORPC/
DH63:	.ASCIZ	/SRO EXP SRO REC TESTNO ERRORPC/


	.EVEN

DT1:	.WORD	TRAPPC,TRAPPS,WASR6,TESTNO,$ERRPC,0
DT2:	.WORD	TRAPPC,TRAPPS,WASR6,WASSR0,WASSR2,TESTNO,$ERRPC,0
DT3:	.WORD	$REG0,$REG1,TESTNO,$ERRPC,0
DT7:	.WORD	$REG0,TESTNO,$ERRPC,0
DT10:	.WORD	ANDADR,ORADR,TONUM,TESTNO,$ERRPC,0
DT11:	.WORD	$REG0,$REG1,$REG1,TESTNO,$ERRPC,0
DT12:	.WORD	$REG0,$REG1,$REG2,$REG2,TESTNO,$ERRPC,0
DT13:	.WORD	$REG0,TESTNO,$ERRPC,0
DT16:	.WORD	$REG0,$REG1,5REG5,$REG2,TESTNO,$ERRPC,0
DT17:	.WORD	PBALO,VIRT1,$REG4,TESTNO,$ERRPC,0
DT20:	.WORD	PBALO,VIRT1,VIRT2,$REG4,$REG5,$TMPO,TESTNO,$ERRPC,0
DT21:	.WORD	$REG5,$REG3,TESTNO,$ERRPC,0
DT22:	.WORD	$REG0,$REG5,$REG3,TESTNO,$ERRPC,0
DT23:	.WORD	$REG5,TESTNO,$ERRPC,0
DT24:	.WORD	$REG2,$REG1,TESTNO,$ERRPC,0
DT26:	.WORD	$REG2,$TMPO,TESTNO,$ERRPC,0
DT30:	.WORD	WASSR0,$REG3,$REG2,$TMPO,TESTNO,$ERRPC,0
DT31:	.WORD	WASSR2,$REG4,$REG2,$TMPO,TESTNO,$ERRPC,0
DT32:	.WORD	$REG0,$REG4,WASSR0,WASSR2,TESTNO,$ERRPC,0
DT33:	.WORD	$REG0,$REG4,TESTNO,$ERRPC,0
DT34:	.WORD	$REG0,$REG4,WASSR0,$REG2,TESTNO,$ERRPC,0
DT35:	.WORD	$REG0,$REG4,WASSR2,$REG3,TESTNO,$ERRPC,0
DT36:	.WORD	WASSR2,$REG1,TESTNO,$ERRPC,0
DT37:	.WORD	$TMPO,$TMP2,WASSR0,WASSR2,TESTNO,$ERRPC,0
DT40:	.WORD	WASSR0,WASSR2,TESTNO,$ERRPC,0
DT42:	.WORD	$REG1,$REG2,TESTNO,$ERRPC,0
DT44:	.WORD	$REG0,EREG1,WASSR0,WASSR2,TESTNO,$ERRPC,0
DT45:	.WORD	$REG1,$REG3,WASSR0O,WASSR2,TESTNO,$ERRPC,0
DT46:	.WORD	$REG0,$REG1,TESTNO,$ERRPC,0
DT50:	.WORD	TESTNO,$ERRPC,0
DT51:	.WORD	WASSR0,WASSR2,TESTNO,$ERRPC,0
DT52:	.WORD	PBALO,VIRT1,$REG4,WASSR0,WASSR2,$TMPO,TESTNO,$ERRPC,0
DT57:	.WORD	WASSR0,$REG1,TESTNO,$ERRPC,0
DT60:	.WORD	$REG1,$REG2,TESTNO,$ERRPC,0
DT64:	.WORD	WASSR2,$REG4,TESTNO,$ERRPC,0
DT65:	.WORD	WASSR0,WASSR2,TESTNO,$ERRPC,0
DT66:	.WORD	CORSR2,WASSR2,TESTNO,$ERRPC,0
DT67:	.WORD	CORSR0,WASSR0,TESTNO,$ERRPC,0

DF1:	.BYTE	0,0,0,0,0
DF2:	.BYTE	0,0,0,0,0,0,0
DF3:	.BYTE	0,0,0,0
DF7:	.BYTE	0,0,0
DF10:	.BYTE	0,0,1,0,0
DF11:	.BYTE	0,0,2,0,0
DF12:	.BYTE	0,0,0,2,0,0
DF13:	.BYTE	0,0,0
DF16:	.BYTE	0,0,0,0,0,0
DF17:	.BYTE	3,0,0,0,0
DF20:	.BYTE	0,0,0,0,0,0,0,0
DF21:	.BYTE	0,0,0,0
DF22:	.BYTE	0,0,0,0,0
DF23:	.BYTE	0,0,0
DF24:	.BYTE	0,0,0,0
DF30:	.BYTE	0,0,0,0,0,0
DF46:	.BYTE	0,0,0,0
DF50:	.BYTE	0,0
DF51:	.BYTE	0,0,0,0
DF52:	.BYTE	3,0,0,0,0,0,0,0
DF57:	.BYTE	0,0,0,0
DF60:	.BYTE	0,0,0,0
DF61:	.BYTE	0,0,0,0

.END
