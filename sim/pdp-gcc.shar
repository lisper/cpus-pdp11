#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 06/10/1993 12:38 UTC by mike@donoussa
# Source directory /nfs/cuba!u.u20/mike/gcc-2.4.2
#
# existing files will NOT be overwritten unless -c is specified
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#     33 -rw-r--r-- README.pdp
#  36618 -rwxr-xr-x configure
#  13823 -rwxr-xr-x config.sub
#  34256 -rw------- config/pdp11/pdp11.c
#  45121 -rw------- config/pdp11/pdp11.h
#  53378 -rw------- config/pdp11/pdp11.md
#    969 -rw-r--r-- config/pdp11/xm-pdp11.h
#
# ============= README.pdp ==============
if test -f 'README.pdp' -a X"$1" != X"-c"; then
	echo 'x - skipping README.pdp (File already exists)'
else
echo 'x - extracting README.pdp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README.pdp' &&
X
This pdp11 port is for gcc-2.4.2
SHAR_EOF
chmod 0644 README.pdp ||
echo 'restore of README.pdp failed'
Wc_c="`wc -c < 'README.pdp'`"
test 33 -eq "$Wc_c" ||
	echo 'README.pdp: original size 33, current size' "$Wc_c"
fi
# ============= configure ==============
if test -f 'configure' -a X"$1" != X"-c"; then
	echo 'x - skipping configure (File already exists)'
else
echo 'x - extracting configure (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'configure' &&
#!/bin/sh
# Configuration script for GNU CC
#   Copyright (C) 1988, 1990, 1991, 1992 Free Software Foundation, Inc.
X
#This file is part of GNU CC.
X
#GNU CC is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2, or (at your option)
#any later version.
X
#GNU CC is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
X
#You should have received a copy of the GNU General Public License
#along with GNU CC; see the file COPYING.  If not, write to
#the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
#
# Shell script to create proper links to machine-dependent files in
# preparation for compiling gcc.
#
# Options: --srcdir=DIR		specifies directory where sources are.
# 	   --host=HOST		specifies host configuration.
#	   --target=TARGET	specifies target configuration.
#	   --build=TARGET	specifies configuration of machine you are
#				using to compile GCC.
#	   --prefix=DIR		specifies directory to install in.
#	   --local-prefix=DIR	specifies directory to put local ./include in.
#	   --exec-prefix=DIR	specifies directory to install executables in.
#	   --with-gnu-ld	arrange to work with GNU ld.
#	   --with-gnu-as	arrange to work with GAS.
#	   --with-stabs		arrange to use stabs instead of host debug format.
#	   --nfp		assume system has no FPU.
#
# If configure succeeds, it leaves its status in config.status.
# If configure fails after disturbing the status quo, 
# 	config.status is removed.
#
X
progname=$0
X
# Default --srcdir to the directory where the script is found, 
# if a directory was specified.
# The second sed call is to convert `.//configure' to `./configure'.
srcdir=`echo $0 | sed 's|//|/|' | sed 's|/[^/]*$||'`
if [ x$srcdir = x$0 ]
then
srcdir=
fi
X
host=
X
# Default prefix to /usr/local.
prefix=/usr/local
X
# local_prefix specifies where to find the directory /usr/local/include
# We don't use $(prefix) for this
# because we always want GCC to search /usr/local/include
# even if GCC is installed somewhere other than /usr/local.
# Think THREE TIMES before specifying any other value for this!
# DO NOT make this use $prefix!
local_prefix=/usr/local
# Default is to let the Makefile set exec_prefix from $(prefix)
exec_prefix='$(prefix)'
X
remove=rm
hard_link=ln
symbolic_link='ln -s'
copy=cp
X
# Record all the arguments, to write them in config.status.
arguments=$*
X
#for Test
#remove="echo rm"
#hard_link="echo ln"
#symbolic_link="echo ln -s"
X
target=
host=
build=
X
for arg in $*;
do
X  case $next_arg in
X  --srcdir)
X    srcdir=$arg
X    next_arg=
X    ;;
X  --host)
X    host=$arg
X    next_arg=
X    ;;
X  --target)
X    target=$arg
X    next_arg=
X    ;;
X  --build)
X    build=$arg
X    next_arg=
X    ;;
X  --prefix)
X    prefix=$arg
X    next_arg=
X    ;;
X  --local-prefix)
X    local_prefix=$arg
X    next_arg=
X    ;;
X  --exec-prefix)
X    exec_prefix=$arg
X    next_arg=
X    ;;
X  *)
X    case $arg in
X     -srcdir | --srcdir | --srcdi | --srcd | --src | --sr | --s)
X	next_arg=--srcdir
X	;;
X     -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=* | --s=*)
X	srcdir=`echo $arg | sed 's/-*s[a-z]*=//'`
X	;;
X     -host | --host | --hos | --ho | --h)
X	next_arg=--host
X	;;
X     -host=* | --host=* | --hos=* | --ho=* | --h=*)
X	host=`echo $arg | sed 's/-*h[a-z]*=//'`
X	;; 
X     -target | --target | --targe | --targ | --tar | --ta | --t)
X	next_arg=--target
X	;;
X     -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
X	target=`echo $arg | sed 's/-*t[a-z]*=//'`
X	;; 
X     -build | --build | --buil | --bui | --bu | --b)
X	next_arg=--build
X	;;
X     -build=* | --build=* | --buil=* | --bui=* | --bu=* | --b=*)
X	build=`echo $arg | sed 's/-*b[a-z]*=//'`
X	;; 
X     -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
X	next_arg=--prefix
X	;;
X     -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
X	prefix=`echo $arg | sed 's/-*p[a-z]*=//'`
X	;;
X     -local-prefix | --local-prefix | --local-prefi | --local-pref | --local-pre \
X	| --local-pr | --local-p | --local- | --local | --loc | --lo | --l)
X	next_arg=--local-prefix
X	;;
X     -local-prefix=* | --local-prefix=* | --local-prefi=* | --local-pref=* \
X	| --local-pre=* | --local-pr=* | --local-p=* | --local-=* | --local=* \
X	| --loc=* | --lo=* | --l=*)
X	local_prefix=`echo $arg | sed 's/-*l[-a-z]*=//'`
X	;;
X     -exec-prefix | --exec-prefix | --exec-prefi | --exec-pref | --exec-pre \
X	| --exec-pr | --exec-p | --exec- | --exec | --exe | --ex | --e)
X	next_arg=--exec-prefix
X	;;
X     -exec-prefix=* | --exec-prefix=* | --exec-prefi=* | --exec-pref=* \
X	| --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* | --exec=* \
X	| --exe=* | --ex=* | --e=*)
X	exec_prefix=`echo $arg | sed 's/-*e[-a-z]*=//'`
X	;;
X     -with-gnu-ld | --with-gnu-ld | --with-gnu-l)
X	gnu_ld=yes
X	;;
X     -gas | --gas | --ga | --g | -with-gnu-as | --with-gnu-as | -with-gnu-a)
X        gas=yes
X	;;
X     -nfp | --nfp | --nf | --n)
X	nfp=yes
X	;;
X     -with-stabs | -with-stab | -with-sta | -with-st | -with-s \
X	| --with-stabs | --with-stab | --with-sta | --with-st | --with-s \
X	| -stabs | -stab | -sta | -st  \
X	| --stabs | --stab | --sta | --st)
X	stabs=yes
X	;;
X     -with-* | --with-*) ;; #ignored
X     -x | --x) ;; # ignored
X     -*)
X	echo "Invalid option \`$arg'" 1>&2
X	exit 1
X	;;
X     *)
# Allow configure HOST TARGET
X	if [ x$host = x ]
X	then
X		host=$target
X	fi
X	target=$arg
X	;;
X    esac
X  esac
done
X
# Find the source files, if location was not specified.
if [ x$srcdir = x ]
then
X	srcdirdefaulted=1
X	srcdir=.
X	if [ ! -r tree.c ]
X	then
X		srcdir=..
X	fi
fi
X
if [ ! -r ${srcdir}/tree.c ]
then
X	if [ x$srcdirdefaulted = x ]
X	then
X	  echo "$progname: Can't find compiler sources in \`${srcdir}'" 1>&2
X	else
X	  echo "$progname: Can't find compiler sources in \`.' or \`..'" 1>&2
X	fi
X	exit 1
fi
X
if [ -r ${srcdir}/config.status ] && [ x$srcdir != x. ]
then
X	echo "$progname: \`configure' has been run in \`${srcdir}'" 1>&2
X	exit 1
fi
X
# Complain if an arg is missing
if [ x$target = x ]
then
X	echo "No target specified." 1>&2
X
X	echo "\
Usage: `basename $progname` [--host=HOST] [--build=BUILD]
X       [--prefix=DIR] [--local-pref=DIR] [--exec-pref=DIR]
X       [--with-gnu-as] [--with-gnu-ld] [--with-stabs] [--nfp] TARGET" 1>&2
X	echo "Where HOST, TARGET and BUILD are three-part configuration names " 1>&2
X	if [ -r config.status ]
X	then
X		tail +2 config.status 1>&2
X	fi
X	exit 1
fi
X
# Default other arg
if [ x$host = x ]
then
X	host=$target
fi
# If $build was not specified, use $host.
if [ x$build = x ]
then
X	build=$host
fi
X
build_xm_file=
host_xm_file=
host_xmake_file=
host_broken_install=
host_install_headers_dir=install-headers-tar
X
# Validate the specs, and canonicalize them.
canon_build=`/bin/sh $srcdir/config.sub $build` || exit 1
canon_host=`/bin/sh $srcdir/config.sub $host` || exit 1
canon_target=`/bin/sh $srcdir/config.sub $target` || exit 1
X
# Decode the host machine, then the target machine.
# For the host machine, we save the xm_file variable as host_xm_file;
# then we decode the target machine and forget everything else
# that came from the host machine.
for machine in $canon_build $canon_host $canon_target; do
X
X	cpu_type=
X	xm_file=
X	tm_file=
X	out_file=
X	xmake_file=
X	tmake_file=
X	header_files=
X	# Set this to force installation and use of collect2.
X	use_collect2=
X	# Set this to override the default target model.
X	target_cpu_default=
X	# Set this to force use of install.sh.
X	broken_install=
X	# Set this to control which fixincludes program to use.
X	fixincludes=fixincludes
X	# Set this to control how the header file directory is installed.
X	install_headers_dir=install-headers-tar
X
X	case $machine in
X	# Support site-specific machine types.
X	*local*)
X		cpu_type=`echo $machine | sed -e 's/-.*//'`
X		rest=`echo $machine | sed -e "s/$cpu_type-//"`
X		xm_file=${cpu_type}/xm-$rest.h
X		tm_file=${cpu_type}/$rest.h
X		if [ -f $srcdir/config/${cpu_type}/x-$rest ] ; \
X		then xmake_file=${cpu_type}/x-$rest; \
X		else true; \
X		fi
X		if [ -f $srcdir/config/${cpu_type}/t-$rest ] ; \
X		then tmake_file=${cpu_type}/t-$rest; \
X		else true; \
X		fi
X		;;
X	vax-*-bsd*)			# vaxen running BSD
X		use_collect2=yes
X		;;
X	vax-*-ultrix*)			# vaxen running ultrix
X		tm_file=vax/ultrix.h
X		use_collect2=yes
X		;;
X	vax-*-vms*)			# vaxen running VMS
X		xm_file=vax/xm-vms.h
X		tm_file=vax/vms.h
X		;;
X	vax-*-sysv*)			# vaxen running system V
X		xm_file=vax/xm-vaxv.h
X		tm_file=vax/vaxv.h
X		;;
X        pdp11-*-*)
X		xm_file=pdp11/xm-pdp11.h
X		tm_file=pdp11/pdp11.h
X		;;
# This hasn't been upgraded to GCC 2.
#	tahoe-harris-*)			# Harris tahoe, using COFF.
#		tm_file=tahoe/harris.h
#		;;
#	tahoe-*-bsd*)			# tahoe running BSD
#		;;
X	i[34]86-*-osfrose*)		# 386 using OSF/rose
# The following line (and similar below) is not redundant since this can
# be used for i486 or i386.
X		cpu_type=i386
X		tm_file=i386/osfrose.h
X		xmake_file=i386/x-osfrose
X		tmake_file=i386/t-osfrose
X		use_collect2=yes
X		;;
X	i[34]86-sequent-bsd*) 		# 80386 from Sequent
X		cpu_type=i386
X		use_collect2=yes
X		if [ x$gas = xyes ]
X		then
X			tm_file=i386/seq-gas.h
X		else
X			tm_file=i386/sequent.h
X		fi
X		;;
X	i[34]86-next-*)
X		cpu_type=i386
X		tm_file=i386/next.h
X		out_file=i386/next.c
X		xm_file=i386/xm-next.h
X		tmake_file=i386/t-next
X		xmake_file=i386/x-next
X		;;
X	i[34]86-*-bsd*)
X		cpu_type=i386
X		tm_file=i386/386bsd.h
#		tmake_file=t-libc-ok
# Next line turned off because both 386BSD and BSD/386 use GNU ld.
#		use_collect2=yes
X		;;
X	i[34]86-*-mach*)
X		cpu_type=i386
X		tm_file=i386/mach.h
#		tmake_file=t-libc-ok
X		use_collect2=yes
X		;;
X	i[34]86-*-sco3.2v4*)	 	# 80386 running SCO 3.2v4 system
X		cpu_type=i386
X		xm_file=i386/xm-sco.h
X		xmake_file=i386/x-sco4
X		fixincludes=fixinc.sco
X		broken_install=yes
X		install_headers_dir=install-headers-cpio
X                if [ x$stabs = xyes ]
X		then
X			tm_file=i386/sco4dbx.h
X			tmake_file=i386/t-svr3dbx
X		else
X			tm_file=i386/sco4.h
X			tmake_file=i386/t-sco
X		fi
X		;;
X	i[34]86-*-sco*)		 	# 80386 running SCO system
X		cpu_type=i386
X		xm_file=i386/xm-sco.h
X		xmake_file=i386/x-sco
X		broken_install=yes
X		install_headers_dir=install-headers-cpio
X                if [ x$stabs = xyes ]
X		then
X			tm_file=i386/scodbx.h
X			tmake_file=i386/t-svr3dbx
X		else
X			tm_file=i386/sco.h
X			tmake_file=i386/t-sco
X		fi
X		;;
X	i[34]86-*-isc*)			# 80386 running ISC system
X		cpu_type=i386
X		xm_file=i386/xm-isc.h
X		case $machine in
X		  i[34]86-*-isc3*)
X		    xmake_file=i386/x-isc3
X		    ;;
X		  *)
X		    xmake_file=i386/x-isc
X		    ;;
X		esac
X		echo $xmake_file
X                if [ x$gas = xyes ]
X		then
X			if [ x$stabs = xyes ]
X			then
X				tm_file=i386/iscdbx.h
X				tmake_file=i386/t-svr3dbx
X			else
X				# iscgas.h, a nonexistent file, was used here.
X				tm_file=i386/isccoff.h
X				tmake_file=i386/t-isc
X			fi
X		else
X			tm_file=i386/isccoff.h
X			tmake_file=i386/t-isc
X		fi
X		install_headers_dir=install-headers-cpio
X		broken_install=yes
X		;;
X	i[34]86-ibm-aix*)		# IBM PS/2 running AIX
X		cpu_type=i386
X                if [ x$gas = xyes ]
X		then
X			tm_file=i386/aix386.h
X			tmake_file=i386/t-aix
X		else
X			tm_file=i386/aix386ng.h
X			use_collect2=yes
X		fi
X		xm_file=i386/xm-aix.h
X		xmake_file=i386/x-aix
X		broken_install=yes
X		fixincludes=fixinc.ps2
X		;;
X	i386-sun-sunos*)		# Sun i386 roadrunner
X		xm_file=i386/xm-sun.h
X		tm_file=i386/sun.h
X		use_collect2=yes
X		;;
X	i[34]86-*-linux*)               # Intel 80386's running Linux
X		cpu_type=i386
X		xm_file=i386/xm-linux.h
X		xmake_file=i386/x-linux
X		tm_file=i386/linux.h
X		fixincludes=Makefile.in #On Linux, the headers are ok already.
X		broken_install=yes
X		;;
X	i486-ncr-sysv4*)		# NCR 3000 - i486 running system V.4
X		cpu_type=i386
X		xm_file=i386/xm-sysv4.h
X		xmake_file=i386/x-ncr3000
X		tm_file=i386/sysv4.h
X		tmake_file=t-svr4
X		;;
X	i[34]86-*-sysv4*)		# Intel 80386's running system V.4
X		cpu_type=i386
X		xm_file=i386/xm-sysv4.h
X		tm_file=i386/sysv4.h
X		tmake_file=t-svr4
X		xmake_file=x-svr4
X		;;
X	i[34]86-*-sysv*)		# Intel 80386's running system V
X		cpu_type=i386
X		xm_file=i386/xm-sysv3.h
X		xmake_file=i386/x-sysv3
X		if [ x$gas = xyes ]
X		then
X			if [ x$stabs = xyes ]
X			then
X				tm_file=i386/svr3dbx.h
X				tmake_file=i386/t-svr3dbx
X			else
X				tm_file=i386/svr3gas.h
X				tmake_file=t-svr3
X			fi
X		else
X			tm_file=i386/sysv3.h
X			tmake_file=t-svr3
X		fi
X		;;
X	i[34]86-*-solaris2* | i[34]86-*-sunos5*)
X		cpu_type=i386
X		xm_file=i386/xm-sysv4.h
X		tm_file=i386/sol2.h
X		tmake_file=i386/t-sol2
X		xmake_file=x-svr4
X		fixincludes=fixinc.svr4
X		broken_install=yes
X		;;
X	i860-*-mach*)
X		xm_file=i860/xm-i860.h
X		tm_file=i860/mach.h
X		tmake_file=t-libc-ok
X		;;
X	i860-*-sysv3*)
X		xm_file=i860/xm-sysv3.h
X		xmake_file=i860/x-sysv3
X		tm_file=i860/sysv3.h
X		tmake_file=t-svr3
X		;;
X	i860-*-sysv4*)
X		xm_file=i860/xm-sysv4.h
X		xmake_file=i860/x-sysv4
X		tm_file=i860/sysv4.h
X		tmake_file=t-svr4
X		;;
X	i860-alliant-*)		# Alliant FX/2800
X		xm_file=i860/xm-fx2800.h
X		xmake_file=i860/x-fx2800
X		tm_file=i860/fx2800.h
X		tmake_file=i860/t-fx2800
X		;;
X	i860-*-bsd*)
X		if [ x$gas = xyes ]
X		then
X			tm_file=i860/bsd-gas.h
X		else
X			tm_file=i860/bsd.h
X		fi
X		use_collect2=yes
X		;;
X	elxsi-elxsi-*)
X		use_collect2=yes
X		;;
X	sparc-tti-*)
X		tm_file=sparc/pbd.h
X		xm_file=sparc/xm-pbd.h
X		;;
X	sparc-*-sunos4*)
X		tm_file=sparc/sparc.h
X		use_collect2=yes
X		;;
X	sparc-*-sunos3*)
X		tm_file=sparc/sun4o3.h
X		use_collect2=yes
X		;;
X	sparc-*-sysv4*)
X		xm_file=sparc/xm-sysv4.h
X		tm_file=sparc/sysv4.h
X		tmake_file=t-svr4
X		xmake_file=sparc/x-sysv4
X		;;
X	sparc-*-solaris2* | sparc-*-sunos5*)
X		xm_file=sparc/xm-sol2.h
X		tm_file=sparc/sol2.h
X		tmake_file=sparc/t-sol2
X		xmake_file=sparc/x-sysv4
X		fixincludes=fixinc.svr4
X		broken_install=yes
X		;;
X	sparclite-*-*)
X		cpu_type=sparc
X		tm_file=sparc/lite.h
X		use_collect2=yes
X		;;
X	m68k-cbm-sysv4*)		# Commodore variant of V.4.
X		tm_file=m68k/amix.h
X		xm_file=m68k/xm-amix.h
X		xmake_file=m68k/x-amix
X		tmake_file=t-svr4
X		header_files=math-68881.h
X		;;
X	m68k-*-sysv4*)			# Motorola m68k's running system V.4
X		tm_file=m68k/m68kv4.h
X		xm_file=m68k/xm-m68kv.h
X		tmake_file=t-svr4
X		header_files=math-68881.h
X		;;
X	m68k-bull-sysv*)		# Bull DPX/2
X		if [ x$gas = xyes ]
X		then
X			tm_file=m68k/dpx2g.h
X		else
X			echo dpx2 supported only with GAS 1>&2
X			exit 1
X			tm_file=m68k/dpx2.h
X		fi
X		xm_file=m68k/xm-m68kv.h
X		xmake_file=m68k/x-dpx2
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68k-next-*)
X		tm_file=m68k/next.h
X		out_file=m68k/next.c
X		xm_file=m68k/xm-next.h
X		tmake_file=m68k/t-next
X		xmake_file=m68k/x-next
X		header_files=math-68881.h
X		;;
X	m68k-sun-sunos3*)
X		if [ x$nfp = xyes ]
X		then
X			tm_file=m68k/sun3n3.h
X		else
X			tm_file=m68k/sun3o3.h
X		fi
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68k-sun-sunos*)		# For SunOS 4 (the default).
X		if [ x$nfp = xyes ]
X		then
X			tm_file=m68k/sun3n.h
X		else
X			tm_file=m68k/sun3.h
X		fi
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68k-sun-mach*)
X		tm_file=m68k/sun3mach.h
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68k-tti-*)
X		tm_file=m68k/pbb.h
X		xm_file=m68k/xm-m68kv.h
X		header_files=math-68881.h
X		;;
X	m68k-hp-hpux*)	# HP 9000 series 300
X		xm_file=m68k/xm-hp320.h
X		if [ x$gas = xyes ]
X		then
X			xmake_file=m68k/x-hp320g
X			tmake_file=m68k/t-hp320g
X			tm_file=m68k/hp320g.h
X		else
X			xmake_file=m68k/x-hp320
X			tm_file=m68k/hp320.h
X		fi
X		broken_install=yes
X		install_headers_dir=install-headers-cpio
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68k-hp-bsd*)			# HP 9000/3xx running Berkeley Unix
X		tm_file=m68k/hp3bsd.h
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68k-hp-bsd4.4)			# HP 9000/3xx running 4.4bsd
X		tm_file=m68k/hp3bsd44.h
X		xmake_file=m68k/x-hp3bsd44
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68k-isi-bsd*)
X		if [ x$nfp = xyes ]
X		then
X			tm_file=m68k/isi-nfp.h
X		else
X			tm_file=m68k/isi.h
X		fi
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68k-sony-newsos3*)
X		if [ x$gas = xyes ]
X		then
X			tm_file=m68k/news3gas.h
X		else
X			tm_file=m68k/news3.h
X		fi
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68k-sony-bsd* | m68k-sony-newsos*)
X		if [ x$gas = xyes ]
X		then
X			tm_file=m68k/newsgas.h
X		else
X			tm_file=m68k/news.h
X		fi
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68k-altos-sysv*)		   # Altos 3068
X		if [ x$gas = xyes ]
X		then
X		        xm_file=m68k/xm-altos3068.h
X		        tm_file=m68k/altos3068.h
X		else
X			echo "The Altos is supported only with the GNU assembler" 1>&2
X			exit 1
X		fi
X		header_files=math-68881.h
X	        ;;
X	m68k-motorola-sysv*)
X		tm_file=m68k/mot3300.h
X		xm_file=m68k/xm-mot3300.h
X		xmake_file=m68k/x-alloca-c
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68k-crds-unos*)
X		xm_file=m68k/xm-crds.h
X		xmake_file=m68k/x-crds
X		tm_file=m68k/crds.h
X		broken_install=yes
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68k-apollo-*)
X		xmake_file=m68k/x-apollo68
X		tm_file=m68k/apollo68.h
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X        m68k-plexus-sysv*)
X		tm_file=m68k/plexus.h
X		xm_file=m68k/xm-plexus.h
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68k-ncr-sysv*)			# NCR Tower 32 SVR3
X		tm_file=m68k/tower-as.h
X		xm_file=m68k/xm-tower.h
X		xmake_file=m68k/x-tower
X		tmake_file=t-svr3
X		header_files=math-68881.h
X		;;
X	m68k-*-sysv3*)			# Motorola m68k's running system V.3
X		xm_file=m68k/xm-m68kv.h
X		xmake_file=m68k/x-m68kv
X		tmake_file=t-svr3
X		header_files=math-68881.h
X		;;
X	m68000-sun-sunos3*)
X		cpu_type=m68k
X		tm_file=m68k/sun2.h
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68000-sun-sunos4*)
X		cpu_type=m68k
X		tm_file=m68k/sun2o4.h
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68000-hp-hpux*)		# HP 9000 series 300
X		cpu_type=m68k
X		xm_file=m68k/xm-hp320.h
X		if [ x$gas = xyes ]
X		then
X			xmake_file=m68k/x-hp320g
X			tm_file=m68k/hp310g.h
X		else
X			xmake_file=m68k/x-hp320
X			tm_file=m68k/hp310.h
X		fi
X		broken_install=yes
X		install_headers_dir=install-headers-cpio
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68000-hp-bsd*)			# HP 9000/200 running BSD
X		cpu_type=m68k
X		tm_file=m68k/hp2bsd.h
X		xmake_file=m68k/x-hp2bsd
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68000-att-sysv*)
X		cpu_type=m68k
X		xm_file=m68k/xm-3b1.h
X		if [ x$gas = xyes ]
X		then
X			tm_file=m68k/3b1g.h
X		else
X			tm_file=m68k/3b1.h
X		fi
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	m68000-convergent-sysv*)
X		cpu_type=m68k
X		xm_file=m68k/xm-3b1.h
X		tm_file=m68k/ctix.h
X		use_collect2=yes
X		header_files=math-68881.h
X		;;
X	ns32k-sequent-bsd*)
X		tm_file=ns32k/sequent.h
X		use_collect2=yes
X		;;
X	ns32k-encore-bsd*)
X		tm_file=ns32k/encore.h
X		use_collect2=yes
X		;;
# This has not been updated to GCC 2.
#	ns32k-ns-genix*)
#		xm_file=ns32k/xm-genix.h
#		xmake_file=ns32k/x-genix
#		tm_file=ns32k/genix.h
#		broken_install=yes
#		use_collect2=yes
#		;;
X	ns32k-merlin-*)
X		tm_file=ns32k/merlin.h
X		use_collect2=yes
X		;;
X	ns32k-tek6100-bsd*)
X		tm_file=ns32k/tek6100.h
X		broken_install=yes
X		use_collect2=yes
X		;;
X	ns32k-tek6200-bsd*)
X		tm_file=ns32k/tek6200.h
X		broken_install=yes
X		use_collect2=yes
X		;;
X	ns32k-pc532-mach*)
X		tm_file=ns32k/pc532-mach.h
X		use_collect2=yes
X		;;
X	ns32k-pc532-minix*)
X		tm_file=ns32k/pc532-min.h
X		xm_file=ns32k/xm-pc532-min.h
X		use_collect2=yes
X		;;
X	m88k-*-luna*)
X		tm_file=m88k/luna.h
X		tmake_file=m88k/t-luna
X		;;
X	m88k-dg-dgux*)
X		tm_file=m88k/dgux.h
X		xmake_file=m88k/x-dgux
X		tmake_file=m88k/t-dgux
X		broken_install=yes
X		;;
X	m88k-*-sysv4*)
X		tm_file=m88k/sysv4.h
X		xmake_file=m88k/x-sysv4
X		tmake_file=m88k/t-sysv4
X		;;
X	m88k-dolphin-sysv3*)
X		tm_file=m88k/dolph.h
X		xm_file=m88k/xm-sysv3.h
X		xmake_file=m88k/x-dolph
X		;;
X
X	m88k-tektronix-sysv3)
X		tm_file=m88k/tekXD88.h
X		xm_file=m88k/xm-sysv3.h
X		xmake_file=m88k/x-tekXD88
X		;;
X
X	m88k-*-sysv3*)
X		tm_file=m88k/sysv3.h
X		xm_file=m88k/xm-sysv3.h
X		;;
# This hasn't been upgraded to GCC 2.
#	fx80-alliant-*)			# Alliant FX/80
#		;;
X	arm-*-*)			# Acorn RISC machine
X		;;
X	c1-convex-*)			# Convex C1
X		cpu_type=convex
X		tm_file=convex/convex1.h
X		use_collect2=yes
X		;;
X	c2-convex-*)			# Convex C2
X		cpu_type=convex
X		tm_file=convex/convex2.h
X		use_collect2=yes
X		;;
X	c32-convex-*)
X		cpu_type=convex
X		tm_file=convex/convex32.h	# Convex C32xx
X		use_collect2=yes
X		;;
X	c34-convex-*)
X		cpu_type=convex
X		tm_file=convex/convex34.h	# Convex C34xx
X		use_collect2=yes
X		;;
X	c38-convex-*)
X		cpu_type=convex
X		tm_file=convex/convex38.h	# Convex C38xx
X		use_collect2=yes
X		;;
X	mips-sgi-irix4loser*)		# Mostly like a MIPS.
X		if [ x$stabs = xyes ]; then
X		    tm_file=mips/iris4gl.h
X		else
X		    tm_file=mips/iris4loser.h
X		fi
X		xm_file=mips/xm-iris4.h
X		broken_install=yes
X		xmake_file=mips/x-iris
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X		;;
X	mips-sgi-irix4*)		# Mostly like a MIPS.
X		if [ x$stabs = xyes ]; then
X		    tm_file=mips/iris4-gdb.h
X		else
X		    tm_file=mips/iris4.h
X		fi
X		xm_file=mips/xm-iris4.h
X		broken_install=yes
X		xmake_file=mips/x-iris
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X		;;
X	mips-sgi-*)			# Mostly like a MIPS.
X		if [ x$stabs = xyes ]; then
X		    tm_file=mips/iris3-gdb.h
X		else
X		    tm_file=mips/iris3.h
X		fi
X		xm_file=mips/xm-iris3.h
X		broken_install=yes
X		xmake_file=mips/x-iris
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X		;;
X	mips-*-ultrix*)		# Decstation.
X		if [ x$stabs = xyes ]; then
X		    tm_file=mips/ultrix-gdb.h
X		else
X		    tm_file=mips/ultrix.h
X		fi
X		xmake_file=mips/x-ultrix
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		else
X		     tmake_file=mips/t-ultrix
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X	        ;;
X	mips-dec-osfrose*)		# Decstation running OSF/1 reference port with OSF/rose.
X		tm_file=mips/osfrose.h
X		xmake_file=mips/x-osfrose
X		tmake_file=mips/t-osfrose
X		use_collect2=yes
X		;;
X	mips-dec-osf*)			# Decstation running OSF/1 as shipped by DIGITAL
X		if [ x$stabs = xyes ]; then
X		    tm_file=mips/dec-gosf1.h
X		else
X		    tm_file=mips/dec-osf1.h
X		fi
X		xmake_file=mips/x-dec-osf1
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		else
X		     tmake_file=mips/t-ultrix
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X		;;
X	mips-sony-bsd* | mips-sony-newsos*)	# Sony NEWS 3600 or risc/news.
X		if [ x$stabs = xyes ]; then
X		    tm_file=mips/news4-gdb.h
X		else
X		    tm_file=mips/news4.h
X		fi
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X		xmake_file=mips/x-sony
X		;;
X	mips-sony-sysv*)		# Sony NEWS 3800 with NEWSOS5.0.
X					# That is based on svr4.
X		# t-svr4 is not right because this system doesn't use ELF.
X		if [ x$stabs = xyes ]; then
X		    tm_file=mips/news5-gdb.h
X		else
X		    tm_file=mips/news5.h
X		fi
X		xm_file=mips/xm-news.h
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X		;;
X	mips-*riscos[56789]bsd* | mips-*riscos[56789]-bsd*)
X		if [ x$stabs = xyes ]; then	# MIPS BSD 4.3, RISC-OS 5.0
X		    tm_file=mips/bsd-5-gdb.h
X		else
X		    tm_file=mips/bsd-5.h
X		fi
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X	        ;;
X	mips-*-bsd* | mips-*riscosbsd* | mips-*riscos[1234]bsd* \
X		| mips-*riscos-bsd* | mips-*riscos[1234]-bsd*)
X		if [ x$stabs = xyes ]; then	# MIPS BSD 4.3, RISC-OS 4.0
X		    tm_file=mips/bsd-4-gdb.h
X		else
X		    tm_file=mips/bsd-4.h
X		fi
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X	        ;;
X	mips-*riscos[56789]sysv4* | mips-*riscos[56789]-sysv4*)
X		if [ x$stabs = xyes ]; then	# MIPS System V.4., RISC-OS 5.0
X		    tm_file=mips/svr4-5-gdb.h
X		else
X		    tm_file=mips/svr4-5.h
X		fi
X		xm_file=mips/xm-sysv.h
X		xmake_file=mips/x-sysv
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X		;;
X	mips-*-sysv4* | mips-*riscos[1234]sysv4* | mips-*riscossysv4* \
X		| mips-*riscos[1234]-sysv4* | mips-*riscos-sysv4*)
X		if [ x$stabs = xyes ]; then	# MIPS System V.4. RISC-OS 4.0
X		    tm_file=mips/svr4-4-gdb.h
X		else
X		    tm_file=mips/svr4-4.h
X		fi
X		xm_file=mips/xm-sysv.h
X		xmake_file=mips/x-sysv
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X		;;
X	mips-*riscos[56789]sysv* | mips-*-riscos[56788]-sysv*)
X		if [ x$stabs = xyes ]; then	# MIPS System V.3, RISC-OS 5.0
X		    tm_file=mips/svr3-5-gdb.h
X		else
X		    tm_file=mips/svr3-5.h
X		fi
X		xm_file=mips/xm-sysv.h
X		xmake_file=mips/x-sysv
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X		;;
X	mips-*-sysv* | mips-*riscos*sysv*)
X		if [ x$stabs = xyes ]; then	# MIPS System V.3, RISC-OS 4.0
X		    tm_file=mips/svr3-4-gdb.h
X		else
X		    tm_file=mips/svr3-4.h
X		fi
X		xm_file=mips/xm-sysv.h
X		xmake_file=mips/x-sysv
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X		;;
X	mips-*riscos[56789]*)			# Default MIPS RISC-OS 5.0.
X		if [ x$stabs = xyes ]; then
X		    tm_file=mips/mips-5-gdb.h
X		else
X		    tm_file=mips/mips-5.h
X		fi
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X		;;
X	mips-*-*)				# Default MIPS RISC-OS 4.0.
X		if [ x$stabs = xyes ]; then
X		    tm_file=mips/mips-4-gdb.h
X		else
X		    tm_file=mips/mips.h
X		fi
X		if [ x$gas = xyes ]
X		then
X		     tmake_file=mips/t-mips-gas
X		fi
X		if [ x$gnu_ld != xyes ]
X		then
X		     use_collect2=yes
X		fi
X		;;
X	pyramid-*-*)
X		cpu_type=pyr
X		xmake_file=pyr/x-pyr
X		use_collect2=yes
X		;;
# This hasn't been upgraded to GCC 2.
#	tron-*-*)
#		cpu_type=gmicro
#		use_collect2=yes
#		;;
X	a29k-*-bsd*)
X		tm_file=a29k/unix.h
X		xm_file=a29k/xm-unix.h
X		xmake_file=a29k/x-unix
X		use_collect2=yes
X		;;
X	a29k-*-*)			# Default a29k environment.
X		use_collect2=yes
X		;;
X	romp-*-aos*)
X		use_collect2=yes
X		;;
X	romp-*-mach*)
X		xmake_file=romp/x-mach
X		use_collect2=yes
X		;;
X	rs6000-*-mach*)
X		xm_file=rs6000/xm-mach.h
X		tm_file=rs6000/mach.h
X		xmake_file=rs6000/x-mach
X		use_collect2=yes
X		;;
X	rs6000-ibm-aix3.[01]*)
X		use_collect2=yes
X		;;
X	rs6000-ibm-aix*)
X		tm_file=rs6000/aix32.h
X		use_collect2=yes
X		;;
X	hppa1.1-*-mach*)
X		cpu_type=pa
X		tm_file=pa/pa1-utahmach.h
X		use_collect2=no
X		;;
X	hppa1.0-*-mach*)
X		cpu_type=pa
X		tm_file=pa/pa-utahmach.h
X		use_collect2=no
X		;;
X	hppa1.1-*-bsd*)
X		cpu_type=pa
X		tm_file=pa/pa1.h
X		use_collect2=yes
X		;;
X	hppa1.0-*-bsd*)
X		cpu_type=pa
X		use_collect2=yes
X		;;
X	hppa1.0-*-hpux7*)
X		cpu_type=pa
X		xm_file=pa/xm-pahpux.h
X		xmake_file=pa/x-pa-hpux
X		tmake_file=t-libc-ok
X		if [ x$gas = xyes ]
X		then
X			tm_file=pa/pa-gux7.h
X		else
X			tm_file=pa/pa-hpux7.h
X		fi
X		broken_install=yes
X		install_headers_dir=install-headers-cpio
X		use_collect2=yes
X		;;
X	hppa1.1-*-hpux8.02*)
X		cpu_type=pa
X		xm_file=pa/xm-pahpux.h
X		xmake_file=pa/x-pa-hpux
X		tmake_file=t-libc-ok
X		if [ x$gas = xyes ]
X		then
X			echo "GAS accepts new syntax only."
X			exit 1
X		else
X			tm_file=pa/pa1-oldas.h
X		fi
X		broken_install=yes
X		install_headers_dir=install-headers-cpio
X		use_collect2=yes
X		;;
X	hppa1.1-*-hpux*)
X		cpu_type=pa
X		xm_file=pa/xm-pahpux.h
X		xmake_file=pa/x-pa-hpux
X		tmake_file=t-libc-ok
X		if [ x$gas = xyes ]
X		then
X			tm_file=pa/pa1-ghpux.h
X		else
X			tm_file=pa/pa1-hpux.h
X		fi
X		broken_install=yes
X		install_headers_dir=install-headers-cpio
X		use_collect2=yes
X		;;
X	hppa1.0-*-hpux*)
X		cpu_type=pa
X		xm_file=pa/xm-pahpux.h
X		xmake_file=pa/x-pa-hpux
X		tmake_file=t-libc-ok
X		if [ x$gas = xyes ]
X		then
X			tm_file=pa/pa-ghpux.h
X		else
X			tm_file=pa/pa-hpux.h
X		fi
X		broken_install=yes
X		install_headers_dir=install-headers-cpio
X		use_collect2=yes
X		;;
X	we32k-att-sysv*)
X		cpu_type=we32k
X		use_collect2=yes
X		;;
X	h8300-*-*)
X		cpu_type=h8300
X		;;
X	sh-*-*)
X		cpu_type=sh
X		;;
X	alpha-*-osf*)
X		broken_install=yes
X		use_collect2=yes
X		;;
X	i960-*-*)			# Default i960 environment.
X		use_collect2=yes
X		;;
X	clipper-intergraph-clix*)
X		broken_install=yes
X		cpu_type=clipper
X		xm_file=clipper/xm-clix.h
X		tm_file=clipper/clix.h
X		tmake_file=clipper/t-clix
X		xmake_file=clipper/x-clix
X		;;
X	*)
X		echo "Configuration $machine not supported" 1>&2
X		exit 1
X		;;
X	esac
X
X	case $machine in
X	*-*-sysv4*)
X		fixincludes=fixinc.svr4
X		xmake_try_sysv=x-sysv
X		broken_install=yes
X		install_headers_dir=install-headers-cpio
X		;;
X	*-*-sysv*)
X		broken_install=yes
X		install_headers_dir=install-headers-cpio
X		;;
X	esac
X
X	# Distinguish i386 from i486.
X	# Also, do not run mips-tfile on MIPS if using gas.
X	case $machine in
X	i486-*-*)
X		target_cpu_default=2
X		;;
X	mips-*-*)
X		if [ x$gas = xyes ]
X		then
X			target_cpu_default=16
X		fi
X		;;
X	esac
X
X	# No need for collect2 if we have the GNU linker.
X	case x$gnu_ld in 
X	xyes)
X		use_collect2=
X		;;
X	esac
X
# Default certain vars that apply to both host and target in turn.
X	if [ x$cpu_type = x ]
X	then cpu_type=`echo $machine | sed 's/-.*$//'`
X	fi
X
# Save data on machine being used to compile GCC in build_xm_file.
# Save data on host machine in vars host_xm_file and host_xmake_file.
X	if [ x$pass1done = x ]
X	then
X		if [ x$xm_file = x ]
X		then build_xm_file=$cpu_type/xm-$cpu_type.h
X		else build_xm_file=$xm_file
X		fi
X		pass1done=yes
X	else
X		if [ x$pass2done = x ]
X		then
X			if [ x$xm_file = x ]
X			then host_xm_file=$cpu_type/xm-$cpu_type.h
X			else host_xm_file=$xm_file
X			fi
X			if [ x$xmake_file = x ]
X			then xmake_file=$cpu_type/x-$cpu_type
X			fi
X			host_xmake_file=$xmake_file
X			host_broken_install=$broken_install
X			host_install_headers_dir=$install_headers_dir
X			pass2done=yes
X		fi
X	fi
done
X
# Default the target-machine variables that were not explicitly set.
if [ x$tm_file = x ]
then tm_file=$cpu_type/$cpu_type.h; fi
X
if [ x$header_files = x ]
then header_files=; fi
X
if [ x$xm_file = x ]
then xm_file=$cpu_type/xm-$cpu_type.h; fi
X
md_file=$cpu_type/$cpu_type.md
X
if [ x$out_file = x ]
then out_file=$cpu_type/$cpu_type.c; fi
X
if [ x$tmake_file = x ]
then tmake_file=$cpu_type/t-$cpu_type
fi
X
# Set up the list of links to be made.
# $links is the list of link names, and $files is the list of names to link to.
files="$host_xm_file $tm_file $md_file $out_file $xm_file $build_xm_file"
links="config.h tm.h md aux-output.c tconfig.h hconfig.h"
X
# Make the links.
while [ -n "$files" ]
do
X	# set file to car of files, files to cdr of files
X	set $files; file=$1; shift; files=$*
X	set $links; link=$1; shift; links=$*
X
X	if [ ! -r ${srcdir}/config/$file ]
X	then
X		echo "$progname: cannot create a link \`$link'," 1>&2
X		echo "since the file \`config/$file' does not exist" 1>&2
X		exit 1
X	fi
X
X	$remove -f $link
X	rm -f config.status
X	# Make a symlink if possible, otherwise try a hard link
X	$symbolic_link ${srcdir}/config/$file $link 2>/dev/null || $hard_link ${srcdir}/config/$file $link || $copy ${srcdir}/config/$file $link
X
X	if [ ! -r $link ]
X	then
X		echo "$progname: unable to link \`$link' to \`${srcdir}/config/$file'" 1>&2
X		exit 1
X	fi
X	echo "Linked \`$link' to \`${srcdir}/config/$file'"
done
X
# Create Makefile.tem from Makefile.in.
# Make it set VPATH if necessary so that the sources are found.
# Also change its value of srcdir.
# Also create a .gdbinit file which runs the one in srcdir
# and tells GDB to look there for source files.
case $srcdir in
.)
X	rm -f Makefile.tem
X	cp Makefile.in Makefile.tem
X	chmod +w Makefile.tem
X	;;
*)
X	rm -f Makefile.tem
X	echo "VPATH = ${srcdir}" \
X	  | cat - ${srcdir}/Makefile.in \
X	  | sed "s@^srcdir = \.@srcdir = ${srcdir}@" > Makefile.tem
X	rm -f .gdbinit
X	echo "dir ." > .gdbinit
X	echo "dir ${srcdir}" >> .gdbinit
X	echo "source ${srcdir}/.gdbinit" >> .gdbinit
X	;;
esac
X
# Conditionalize the makefile for this host machine.
if [ -f ${srcdir}/config/${host_xmake_file} ]
then
X	rm -f Makefile.xx
X	sed -e "/####host/  r ${srcdir}/config/${host_xmake_file}" Makefile.tem > Makefile.xx
X	echo "Merged ${host_xmake_file}."
X	rm -f Makefile.tem
X	mv Makefile.xx Makefile.tem
else
# Say in the makefile that there is no host_xmake_file,
# by using a name which (when interpreted relative to $srcdir/config)
# will duplicate another dependency: $srcdir/Makefile.in.
X	host_xmake_file=../Makefile.in
fi
X
# Add a definition for INSTALL if system wants one.
# This substitutes for lots of x-* files.
if [ x$host_broken_install = x ]
then true
else
X	rm -f Makefile.xx
X	abssrcdir=`cd ${srcdir}; pwd`
X	sed "s|^INSTALL = .*|INSTALL = ${abssrcdir}/install.sh -c|" Makefile.tem > Makefile.xx
X	rm -f Makefile.tem
X	mv Makefile.xx Makefile.tem
fi
X
# Set EXTRA_HEADERS according to header_files.
# This substitutes for lots of t-* files.
if [ x$header_files = x ]
then true
else
X	rm -f Makefile.xx
X	sed "s/^EXTRA_HEADERS =/EXTRA_HEADERS = $header_files/" Makefile.tem > Makefile.xx
X	rm -f Makefile.tem
X	mv Makefile.xx Makefile.tem
fi
X
# Add a definition of USE_COLLECT2 if system wants one.
# Also tell toplev.c what to do.
# This substitutes for lots of t-* files.
if [ x$use_collect2 = x ]
then true
else
X	rm -f Makefile.xx
X	(echo "USE_COLLECT2 = ld"; echo "MAYBE_USE_COLLECT2 = -DUSE_COLLECT2")\
X 	   | cat - Makefile.tem > Makefile.xx
X	rm -f Makefile.tem
X	mv Makefile.xx Makefile.tem
fi
X
# Add -DTARGET_CPU_DEFAULT for toplev.c if system wants one.
# This substitutes for lots of *.h files.
if [ x$target_cpu_default = x ]
then true
else
X	rm -f Makefile.xx
X	(echo "MAYBE_TARGET_DEFAULT = -DTARGET_CPU_DEFAULT=$target_cpu_default")\
X 	   | cat - Makefile.tem > Makefile.xx
X	rm -f Makefile.tem
X	mv Makefile.xx Makefile.tem
fi
X
# Conditionalize the makefile for this target machine.
if [ -f ${srcdir}/config/${tmake_file} ]
then
X	rm -f Makefile.xx
X	sed -e "/####target/  r ${srcdir}/config/${tmake_file}" Makefile.tem > Makefile.xx
X	echo "Merged ${tmake_file}."
X	rm -f Makefile.tem
X	mv Makefile.xx Makefile.tem
else
# Say in the makefile that there is no tmake_file,
# by using a name which (when interpreted relative to $srcdir/config)
# will duplicate another dependency: $srcdir/Makefile.in.
X	tmake_file=../Makefile.in
fi
X
# Get the version number.
version=`sed -e 's/.*\"\([^ \"]*\)[ \"].*/\1/' < ${srcdir}/version.c`
X
# Remove all formfeeds, since some Makes get confused by them.
# Also arrange to give the variables `target', `host_xmake_file',
# `tmake_file', `prefix', `local_prefix', `exec_prefix', `FIXINCLUDES'
# and `INSTALL_HEADERS_DIR' values in the Makefile from the values
# they have in this script.
rm -f Makefile.xx
sed -e "s///" -e "s/^target=.*$/target=${target}/" \
X    -e "s|^xmake_file=.*$|xmake_file=${host_xmake_file}|" \
X    -e "s|^tmake_file=.*$|tmake_file=${tmake_file}|" \
X    -e "s|^version=.*$|version=${version}|" \
X    -e "s|^prefix[ 	]*=.*|prefix = $prefix|" \
X    -e "s|^local_prefix[ 	]*=.*|local_prefix = $local_prefix|" \
X    -e "s|^exec_prefix[ 	]*=.*|exec_prefix = $exec_prefix|" \
X    -e "s|^FIXINCLUDES[ 	]*=.*|FIXINCLUDES = $fixincludes|" \
X    -e "s|^INSTALL_HEADERS_DIR[ 	]*=.*$|INSTALL_HEADERS_DIR = ${host_install_headers_dir}|" \
X    Makefile.tem > Makefile.xx
rm -f Makefile.tem
mv Makefile.xx Makefile.tem
X
# Install Makefile for real, after making final changes.
# Define macro CROSS_COMPILE in compilation if this is a cross-compiler.
# Also use all.cross instead of all.internal, and add cross-make to Makefile.
if [ x$host = x$target ]
then
X	rm -f Makefile
X  	if [ x$host = x$build ]
X	then
X		mv Makefile.tem Makefile
X	else
#		When build gcc with cross-compiler, we need to fix a
#		few things.
X		echo "build= $build" > Makefile
X		sed -e "/####build/  r ${srcdir}/build-make" Makefile.tem >> Makefile
X		rm -f Makefile.tem Makefile.xx
X	fi
else
X	rm -f Makefile
X	echo "CROSS=-DCROSS_COMPILE" > Makefile
X	sed -e "/####cross/  r ${srcdir}/cross-make" Makefile.tem >> Makefile
X	rm -f Makefile.tem Makefile.xx
fi
X
echo "Created \`Makefile'."
X
if [ xx${vint} != xx ]
then
X	vintmsg=" (vint)"
fi
X
# Describe the chosen configuration in config.status.
# Make that file a shellscript which will reestablish the same configuration.
echo "#!/bin/sh
# GCC was configured as follows:
${srcdir}/configure" $arguments > config.status
echo echo host=$canon_host target=$canon_target build=$canon_build >> config.status
chmod a+x config.status
X
if [ x$canon_host = x$canon_target ]
then
X	echo "Links are now set up for target $canon_target."
else
X	echo "Links are now set up for host $canon_host and target $canon_target."
fi
X
Xexit 0
SHAR_EOF
chmod 0755 configure ||
echo 'restore of configure failed'
Wc_c="`wc -c < 'configure'`"
test 36618 -eq "$Wc_c" ||
	echo 'configure: original size 36618, current size' "$Wc_c"
fi
# ============= config.sub ==============
if test -f 'config.sub' -a X"$1" != X"-c"; then
	echo 'x - skipping config.sub (File already exists)'
else
echo 'x - extracting config.sub (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'config.sub' &&
#!/bin/sh
# Configuration validation subroutine script, version 1.1.
#   Copyright (C) 1991, 1992 Free Software Foundation, Inc.
# This file is (in principle) common to ALL GNU software.
# The presence of a machine in this file suggests that SOME GNU software
# can handle that machine.  It does not imply ALL GNU software can. 
X
#This file is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.
X
#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
X
#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X
# Configuration subroutine to validate and canonicalize a configuration type.
# Supply the specified configuration type as an argument.
# If it is invalid, we print an error message on stderr and exit with code 1.
# Otherwise, we print the canonical config type on stdout and succeed.
X
# This file is supposed to be the same for all GNU packages
# and recognize all the CPU types, system types and aliases
# that are meaningful with *any* GNU software.
# Each package is responsible for reporting which valid configurations
# it does not support.  The user should be able to distinguish
# a failure to support a valid configuration from a meaningless
# configuration.
X
# The goal of this file is to map all the various variations of a given
# machine specification into a single specification in the form:
#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
# It is wrong to echo any other type of specification.
X
# First pass through any local machine types.
case $1 in
X	*local*)
X		echo $1
X		exit 0
X		;;
X	*)
X	;;
esac
X
# Separate what the user gave into CPU-COMPANY and OS (if any).
basic_machine=`echo $1 | sed 's/-[^-]*$//'`
if [ $basic_machine != $1 ]
then os=`echo $1 | sed 's/.*-/-/'`
else os=; fi
X
### Let's recognize common machines as not being operating systems so
### that things like config.sub decstation-3100 work.  We also
### recognize some manufacturers as not being operating systems, so we
### can provide default operating systems below.
case $os in
X	-sun*os*)
X		# Prevent following clause from handling this invalid input.
X		;;
X	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
X	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
X	-unicom* | -ibm* | -next* | -hp | -isi* | -apollo | -altos* | \
X	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi | \
X	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
X	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp )
X		os=
X		basic_machine=$1
X		;;
X	-sco3.2v[4-9]*)
X		# Don't forget version if it is 3.2v4 or newer.
X		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
X		;;
X	-sco*)
X		os=-sco3.2v2
X		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
X		;;
X	-isc)
X		os=-isc2.2
X		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
X		;;
X	-clix*)
X		basic_machine=clipper-intergraph
X		;;
X	-isc*)
X		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
X		;;
esac
X
# Decode aliases for certain CPU-COMPANY combinations.
case $basic_machine in
X	# Recognize the basic CPU types with without company name.
X	# Some are omitted here because they have special meanings below.
X	tahoe | i[34]86 | i860 | m68k | m68000 | m88k | ns32k | arm | pyramid \
X		| tron | a29k | 580 | i960 | h8300 | hppa1.0 | hppa1.1 \
X		| alpha | we32k | ns16k | clipper | sparclite | i370 | sh)
X		basic_machine=$basic_machine-unknown
X		;;
X	# Object if more than one company name word.
X	*-*-*)
X		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
X		exit 1
X		;;
X	# Recognize the basic CPU types with with company name.
X	vax-* | tahoe-* | i[34]86-* | i860-* | m68k-* | m68000-* | m88k-* \
X	      | sparc-* | ns32k-* | fx80-* | arm-* | c[123]* \
X	      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* \
X	      | none-* | 580-* | cray2-* | h8300-* | i960-* | xmp-* | ymp-* \
X	      | hppa1.0-* | hppa1.1-* | alpha-* | we32k-* | cydra-* | ns16k-* \
X	      | pn-* | np1-* | xps100-* | clipper-* | orion-* | sparclite-* \
X	      | pdp11-* | sh-*)
X		;;
X	# Recognize the various machine names and aliases which stand
X	# for a CPU type and a company and sometimes even an OS.
X	vaxv)
X		basic_machine=vax-dec
X		os=-sysv
X		;;
X	vms)
X		basic_machine=vax-dec
X		os=-vms
X		;;
X	i370-ibm* | ibm*)
X		basic_machine=i370-ibm
X		os=-mvs
X		;;
# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
X	i[34]86v32)
X		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
X		os=-sysv32
X		;;
X	i[34]86v4*)
X		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
X		os=-sysv4
X		;;
X	i[34]86v)
X		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
X		os=-sysv
X		;;
X	i[34]86sol2)
X		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
X		os=-solaris2
X		;;
X	spur)
X		basic_machine=spur-unknown
X		;;
X	alliant | fx80)
X		basic_machine=fx80-alliant
X		;;
X	convex-c1)
X		basic_machine=c1-convex
X		os=-bsd
X		;;
X	convex-c2)
X		basic_machine=c2-convex
X		os=-bsd
X		;;
X	convex-c32)
X		basic_machine=c32-convex
X		os=-bsd
X		;;
X	convex-c34)
X		basic_machine=c34-convex
X		os=-bsd
X		;;
X	convex-c38)
X		basic_machine=c38-convex
X		os=-bsd
X		;;
X	m88k-omron*)
X		basic_machine=m88k-omron
X		;;
X	merlin)
X		basic_machine=ns32k-utek
X		os=-sysv
X		;;
X	crds | unos)
X		basic_machine=m68k-crds
X		;;
X	elxsi)
X		basic_machine=elxsi-elxsi
X		os=-bsd
X		;;
X	encore | umax | mmax)
X		basic_machine=ns32k-encore
X		;;
X	genix)
X		basic_machine=ns32k-ns
X		;;
X	iris | iris4d)
X		basic_machine=mips-sgi
X		case $os in
X		    -irix*)
X			;;
X		    *)
X			os=-irix4
X			;;
X		esac
X		;;
X	news | news700 | news800 | news900)
X		basic_machine=m68k-sony
X		os=-newsos
X		;;
X	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
X		basic_machine=m68000-att
X		;;
X	3b*)
X		basic_machine=we32k-att
X		;;
X	delta | 3300 | motorola-3300 | motorola-delta \
X	      | 3300-motorola | delta-motorola)
X		basic_machine=m68k-motorola
X		;;
X	balance)
X		basic_machine=ns32k-sequent
X		os=-dynix
X		;;
X        pc532)
X		basic_machine=ns32k-pc532
X		;;
X	symmetry)
X		basic_machine=i386-sequent
X		os=-dynix
X		;;
X	sun2)
X		basic_machine=m68000-sun
X		;;
X	sun2os3)
X		basic_machine=m68000-sun
X		os=-sunos3
X		;;
X	sun2os4)
X		basic_machine=m68000-sun
X		os=-sunos4
X		;;
X	sun3os3)
X		basic_machine=m68k-sun
X		os=-sunos3
X		;;
X	sun3os4)
X		basic_machine=m68k-sun
X		os=-sunos4
X		;;
X	sun4os3)
X		basic_machine=sparc-sun
X		os=-sunos3
X		;;
X	sun4os4)
X		basic_machine=sparc-sun
X		os=-sunos4
X		;;
X	sun3)
X		basic_machine=m68k-sun
X		;;
X	sun4)
X		basic_machine=sparc-sun
X		;;
X	pbd)
X		basic_machine=sparc-tti
X		;;
X	pbb)
X		basic_machine=m68k-tti
X		;;
X	sun386 | sun386i | roadrunner)
X		basic_machine=i386-sun
X		;;
X	ps2)
X		basic_machine=i386-ibm
X		;;
X	fx2800)
X		basic_machine=i860-alliant
X		;;
X	next)
X		basic_machine=m68k-next
X		os=-bsd
X		;;
X	amiga)
X		basic_machine=m68k-cbm
X		;;
X	amigados)
X		basic_machine=m68k-cbm
X		os=-amigados
X		;;
X	amigaunix | amix)
X		basic_machine=m68k-cbm
X		os=-sysv4
X		;;
X	hp9k3[2-9][0-9])
X		basic_machine=m68k-hp
X		;;
X	hp9k31[0-9] | hp9k2[0-9][0-9])
X		basic_machine=m68000-hp
X		;;
X	hp9k7[0-9][0-9] | hp7[0-9][0-9] | hp9k8[0-9]7 | hp8[0-9]7)
X		basic_machine=hppa1.1-hp
X		;;
X	hp9k8[0-9][0-9] | hp8[0-9][0-9])
X		basic_machine=hppa1.0-hp
X		;;
X	isi68 | isi)
X		basic_machine=m68k-isi
X		os=-sysv
X		;;
X	apollo68)
X		basic_machine=m68k-apollo
X		os=-sysv
X		;;
X	altos | altos3068)
X		basic_machine=m68k-altos
X		;;
X	miniframe)
X		basic_machine=m68000-convergent
X		;;
X	tower | tower-32)
X		basic_machine=m68k-ncr
X		;;
X	news-3600 | risc-news)
X		basic_machine=mips-sony
X		os=-newsos
X		;;
X	decstation | decstation-3100 | pmax | pmin | dec3100 | decstatn)
X		basic_machine=mips-dec
X		;;
X	magnum | m3230)
X		basic_machine=mips-mips
X		os=-sysv
X		;;
X	gmicro)
X		basic_machine=tron-gmicro
X		os=-sysv
X		;;
X	rtpc | rtpc-*)
X		basic_machine=romp-ibm
X		;;
X	am29k)
X		basic_machine=a29k-none
X		os=-bsd
X		;;
X	amdahl)
X		basic_machine=580-amdahl
X		os=-sysv
X		;;
X	cray | ymp)
X		basic_machine=ymp-cray
X		os=-unicos
X		;;
X	cray2)
X		basic_machine=cray2-cray
X		os=-unicos
X		;;
X	xmp)
X		basic_machine=xmp-cray
X		os=-unicos
X		;;
X	delta88)
X		basic_machine=m88k-motorola
X		os=-sysv3
X		;;
X	dpx2)
X		basic_machine=m68k-bull
X		os=-sysv
X		;;
X	ebmon29k)
X		basic_machine=a29k-amd
X		os=-ebmon
X		;;
X	h8300hms)
X		basic_machine=h8300-hitachi
X		os=-hms
X		;;
X	sh)
X		basic_machine=sh-hitachi
X		os=-hms
X		;;
X	harris)
X		basic_machine=m88k-harris
X		os=-sysv3
X		;;
X	hp300bsd)
X		basic_machine=m68k-hp
X		os=-bsd
X		;;
X	hp300hpux)
X		basic_machine=m68k-hp
X		os=-hpux
X		;;
X	hp9k2[0-9][0-9] | hp9k31[0-9])
X		basic_machine=m68000-hp
X		os=-hpux
X		;;
X	hp9k3[2-9][0-9])
X		basic_machine=m68k-hp
X		os=-hpux
X		;;
X	ncr3000)
X		basic_machine=i486-ncr
X		os=-sysv4
X		;;
X	news1000)
X		basic_machine=m68030-sony
X		os=-newsos
X		;;
X	nindy960)
X		basic_machine=i960-intel
X		os=-nindy
X		;;
X	pn)
X		basic_machine=pn-gould
X		;;
X	np1)
X		basic_machine=np1-gould
X		;;
X	ultra3)
X		basic_machine=a29k-nyu
X		os=-sym1
X		;;
X	vxworks960)
X		basic_machine=i960-wrs
X		os=-vxworks
X		;;
X	vxworks68)
X		basic_machine=m68k-wrs
X		os=-vxworks
X		;;
X        xps | xps100)
X		basic_machine=xps100-honeywell
X		;;
X	none)
X		basic_machine=none-none
X		os=-none
X		;;
X
# Here we handle the default manufacturer of certain CPU types.  It is in
# some cases the only manufacturer, in others, it is the most popular.
X	mips)
X		basic_machine=mips-mips
X		;;
X	romp)
X		basic_machine=romp-ibm
X		;;
X	rs6000)
X		basic_machine=rs6000-ibm
X		;;
X	vax)
X		basic_machine=vax-dec
X		;;
X	pdp11)
X		basic_machine=pdp11-dec
X		;;
X	we32k)
X		basic_machine=we32k-att
X		;;
X	sparc)
X		basic_machine=sparc-sun
X		;;
X        cydra)
X		basic_machine=cydra-cydrome
X		;;
X	orion)
X		basic_machine=orion-highlevel
X		;;
X	orion105)
X		basic_machine=clipper-highlevel
X		;;
X	*)
X		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
X		exit 1
X		;;
esac
X
# Here we canonicalize certain aliases for manufacturers.
case $basic_machine in
X	*-digital*)
X		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
X		;;
X	*-commodore*)
X		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
X		;;
X	*)
X		;;
esac
X
# Decode manufacturer-specific aliases for certain operating systems.
X
if [ "$os" ]
then
case $os in
X	# -solaris* is a basic system type, with this one exception.
X	-solaris1 | -solaris1.*)
X		os=`echo $os | sed -e 's|solaris1|sunos4|'`
X		;;
X	# First accept the basic system types.
X	# The portable systems comes first.
X	# Each alternative must end in a *, to match a version number.
X	-bsd* | -sysv* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
X	      | -vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]* | -hpux* \
X	      | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
X	      | -amigados* | -msdos* | -newsos* | -unicos* | -aos* \
X	      | -nindy* | -vxworks* | -ebmon* | -hms* | -mvs* | -clix* \
X	      | -riscos* | -linux* | -uniplus* | -iris* | -rtu* | -xenix* )
X		;;
X	-sunos5*)
X		os=`echo $os | sed -e 's|sunos5|solaris2|'`
X		;;
X	-sunos6*)
X		os=`echo $os | sed -e 's|sunos6|solaris3|'`
X		;;
X	-osfrose*)
X		os=-osfrose
X		;;
X	-osf*)
X		os=-osf
X		;;
X	-utek*)
X		os=-bsd
X		;;
X	-dynix*)
X		os=-bsd
X		;;
X	-acis*)
X		os=-aos
X		;;
X	-ctix* | -uts*)
X		os=-sysv
X		;;
X	-triton*)
X		os=-sysv3
X		;;
X	-oss*)
X		os=-sysv3
X		;;
X	-svr4)
X		os=-sysv4
X		;;
X	-svr3)
X		os=-sysv3
X		;;
X	-xenix)
X		os=-xenix
X		;;
X	-none)
X		;;
X	*)
X		# Get rid of the `-' at the beginning of $os.
X		os=`echo $1 | sed 's/[^-]*-//'`
X		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
X		exit 1
X		;;
esac
else
X
# Here we handle the default operating systems that come with various machines.
# The value should be what the vendor currently ships out the door with their
# machine or put another way, the most popular os provided with the machine.
X
# Note that if you're going to try to match "-MANUFACTURER" here (say,
# "-sun"), then you have to tell the case statement up towards the top
# that MANUFACTURER isn't an operating system.  Otherwise, code above
# will signal an error saying that MANUFACTURER isn't an operating
# system, and we'll never get to this point.
X
case $basic_machine in
X	*-dec | vax-*)
X		os=-ultrix4.2
X		;;
X	i386-sun)
X		os=-sunos4.0.2
X		;;
X	m68000-sun)
X		os=-sunos3
X		# This also exists in the configure program, but was not the
X		# default.
X		# os=-sunos4
X		;;
X	*-tti)	# must be before sparc entry or we get the wrong os.
X		os=-sysv3
X		;;
X	sparc-* | *-sun)
X		os=-sunos4.1.1
X		;;
X	*-ibm)
X		os=-aix
X		;;
X	*-hp)
X		os=-hpux
X		;;
X	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
X		os=-sysv
X		;;
X	*-cbm)
X		os=-amigados
X		;;
X	*-dg)
X		os=-dgux
X		;;
X	*-dolphin)
X		os=-sysv3
X		;;
X	m88k-omron*)
X		os=-luna
X		;;
X	*-sequent)
X		os=-bsd
X		;;
X	*-crds)
X		os=-unos
X		;;
X	*-ns)
X		os=-genix
X		;;
X	i370-*)
X		os=-mvs
X		;;
X	*-next)
X		os=-bsd
X		;;
X	i[34]86-*)
X		os=-sco3.2v2
X		;;
X        *-gould)
X		os=-sysv
X		;;
X        *-highlevel)
X		os=-bsd
X		;;
X	*-encore)
X		os=-bsd
X		;;
X        *-sgi)
X		os=-irix
X		;;
X	*-masscomp)
X		os=-rtu
X		;;
X	*)
X		os=-none
X		;;
esac
fi
X
# Here we handle the case where we know the os, and the CPU type, but not the
# manufacturer.  We pick the logical manufacturer.
vendor=unknown
case $basic_machine in
X	*-unknown)
X		case $os in
X			-sunos*)
X				vendor=sun
X				;;
X			-aix*)
X				vendor=ibm
X				;;
X			-hpux*)
X				vendor=hp
X				;;
X			-unos*)
X				vendor=crds
X				;;
X			-dgux*)
X				vendor=dg
X				;;
X			-luna*)
X				vendor=omron
X				;;
X			-genix*)
X				vendor=ns
X				;;
X			-mvs*)
X				vendor=ibm
X				;;
X		esac
X		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
X		;;
esac
X
echo $basic_machine$os
SHAR_EOF
chmod 0755 config.sub ||
echo 'restore of config.sub failed'
Wc_c="`wc -c < 'config.sub'`"
test 13823 -eq "$Wc_c" ||
	echo 'config.sub: original size 13823, current size' "$Wc_c"
fi
# ============= config/pdp11/pdp11.c ==============
if test ! -d 'config'; then
    echo 'x - creating directory config'
    mkdir 'config'
fi
if test ! -d 'config/pdp11'; then
    echo 'x - creating directory config/pdp11'
    mkdir 'config/pdp11'
fi
if test -f 'config/pdp11/pdp11.c' -a X"$1" != X"-c"; then
	echo 'x - skipping config/pdp11/pdp11.c (File already exists)'
else
echo 'x - extracting config/pdp11/pdp11.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'config/pdp11/pdp11.c' &&
/* Subroutines for gcc2 for pdp11.
X   Copyright (C) 1991,1992,1993 Michael K. Gschwind (mike@vlsivie.tuwien.ac.at)
X
This file is part of GNU CC.
X
GNU CC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 1, or (at your option)
any later version.
X
GNU CC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
X
You should have received a copy of the GNU General Public License
along with GNU CC; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
#ifndef FILE
#include <stdio.h>
#endif
#include "config.h"
#include "rtl.h"
#include "regs.h"
#include "hard-reg-set.h"
#include "real.h"
#include "insn-config.h"
#include "conditions.h"
#include "insn-flags.h"
#include "output.h"
#include "insn-attr.h"
X
/*
#define FPU_REG_P(X)	((X)>=8 && (X)<14)
#define CPU_REG_P(X)	((X)>=0 && (X)<8)
*/
X
/* this is the current value returned by the macro FIRST_PARM_OFFSET 
X   defined in tm.h */
int current_first_parm_offset;
X
/* This is where the condition code register lives.  */
/* rtx cc0_reg_rtx; - no longer needed? */
X
static rtx find_addr_reg (); 
X
/* Nonzero if OP is a valid second operand for an arithmetic insn.  */
X
int
arith_operand (op, mode)
X     rtx op;
X     enum machine_mode mode;
{
X  return (register_operand (op, mode) || GET_CODE (op) == CONST_INT);
}
X
int
const_immediate_operand (op, mode)
X     rtx op;
X     enum machine_mode mode;
{
X  return (GET_CODE (op) == CONST_INT);
}
X
int 
immediate15_operand (op, mode)
X     rtx op;
X     enum machine_mode mode;
{
X    return (GET_CODE (op) == CONST_INT && ((INTVAL (op) & 0x8000) == 0x0000));
}
X
int
expand_shift_operand (op, mode)
X  rtx op;
X  enum machine_mode mode;
{
X    return (GET_CODE (op) == CONST_INT 
X	    && abs (INTVAL(op)) > 1 
X	    && abs (INTVAL(op)) <= 4);
}
X
/*
X   stream is a stdio stream to output the code to.
X   size is an int: how many units of temporary storage to allocate.
X   Refer to the array `regs_ever_live' to determine which registers
X   to save; `regs_ever_live[I]' is nonzero if register number I
X   is ever used in the function.  This macro is responsible for
X   knowing which registers should not be saved even if used.  
*/
X
void 
output_function_prologue(stream, size)
X  FILE *stream;
X  int size;
{							       
X    extern char call_used_regs[];					
X    extern int frame_pointer_needed;				
X
X    int fsize = ((size) + 1) & ~1;      				
X    int regno, nregs, i;						
X    int offset = 0;
X
X    int via_ac = -1;
X    
X    fprintf (stream, "\n\t;	/* function prologue %s*/\n", current_function_name);		
X
X    /* if we are outputting code for main, 
X       the switch FPU to right mode if TARGET_FPU */
X    if ( (strcmp ("main", current_function_name) == 0)
X	 && TARGET_FPU)
X    {
X	fprintf(stream, "\t;/* switch cpu to double float, single integer */\n");
X	fprintf(stream, "\tsetd\n");
X	fprintf(stream, "\tseti\n\n");
X    }
X    
X    if (frame_pointer_needed) 					
X    {								
X	fprintf(stream, "\tmov fp, -(sp)\n");			
X	fprintf(stream, "\tmov sp, fp\n");				
X    }								
X    else 								
X    {								
X	/* DON'T SAVE FP */
X    }								
X
X    /* make frame */
X    if (fsize)							
X	fprintf (stream, "\tsub $%d, sp\n", fsize);			
X
X    /* save CPU registers  */
X    for (regno = 0; regno < 8; regno++)				
X	if (regs_ever_live[regno] && ! call_used_regs[regno])	
X	    if (! ((regno == FRAME_POINTER_REGNUM)			
X		   && frame_pointer_needed))				
X		fprintf (stream, "\tmov %s, -(sp)\n", reg_names[regno]);	
X    /* fpu regs saving */
X    
X    /* via_ac specifies the ac to use for saving ac4, ac5 */
X    via_ac = -1;
X    
X    for (regno = 8; regno < FIRST_PSEUDO_REGISTER ; regno++) 
X    {
X	/* ac0 - ac3 */						
X	if (LOAD_FPU_REG_P(regno)
X	    && regs_ever_live[regno] 
X	    && ! call_used_regs[regno])
X	{
X	    fprintf (stream, "\tfstd %s, -(sp)\n", reg_names[regno]);
X	    via_ac = regno;
X	}
X	
X	/* maybe make ac4, ac5 call used regs?? */
X	/* ac4 - ac5 */
X	if (NO_LOAD_FPU_REG_P(regno)
X	    && regs_ever_live[regno]
X	    && ! call_used_regs[regno])
X	{
X	    if (via_ac == -1)
X		abort();
X	    
X	    fprintf (stream, "\tfldd %s, %s\n", reg_names[regno], reg_names[via_ac]);
X	    fprintf (stream, "\tfstd %s, -(sp)\n", reg_names[via_ac]);
X	}
X    }
X
X    fprintf (stream, "\t;/* end of prologue */\n\n");		
}
X
/*
X   The function epilogue should not depend on the current stack pointer!
X   It should use the frame pointer only.  This is mandatory because
X   of alloca; we also take advantage of it to omit stack adjustments
X   before returning.  */
X
/* maybe we can make leaf functions faster by switching to the
X   second register file - this way we don't have to save regs!
X   leaf functions are ~ 50% of all functions (dynamically!) 
X
X   set/clear bit 11 (dec. 2048) to status word for switching - 
X   but how can we do this? pdp11/45 says bit may only be set (p.24) 
X   switching to kernel is probably more expensive, so we'll leave it 
X   like this 
X
X   maybe as option if you want to generate code for kernel mode? */
X
X
void 
output_function_epilogue(stream, size)
X  FILE *stream;
X  int size;
{								
X    extern char call_used_regs[];					
X    extern int may_call_alloca;
X
X    int fsize = ((size) + 1) & ~1;      				
X    int nregs, regno, i, j, k, adjust_fp;				
X
X    int via_ac;
X    
X    fprintf (stream, "\n\t;	/*function epilogue */\n");		
X
X    if (frame_pointer_needed)					
X    {								
X	/* hope this is safe - m68k does it also .... */		
X	regs_ever_live[FRAME_POINTER_REGNUM] = 0;			
X								
X	for (i =7, j = 0 ; i >= 0 ; i--)				
X	    if (regs_ever_live[i] && ! call_used_regs[i])		
X		j++;
X	
X	/* remember # of pushed bytes for CPU regs */
X	k = 2*j;
X	
X	for (i =7 ; i >= 0 ; i--)					
X	    if (regs_ever_live[i] && ! call_used_regs[i])		
X		fprintf(stream, "\tmov %d(fp), %s\n",-fsize-2*j--, reg_names[i]);
X
X	/* get ACs */						
X	via_ac = FIRST_PSEUDO_REGISTER -1;
X	
X	for (i = FIRST_PSEUDO_REGISTER; i > 7; i--)
X	    if (regs_ever_live[i] && ! call_used_regs[i])
X	    {
X		via_ac = i;
X		k += 8;
X	    }
X	
X	for (i = FIRST_PSEUDO_REGISTER; i > 7; i--)
X	{
X	    if (LOAD_FPU_REG_P(i)
X		&& regs_ever_live[i]
X		&& ! call_used_regs[i])
X	    {
X		fprintf(stream, "\tfldd %d(fp), %s\n", -fsize-k, reg_names[i]);
X		k -= 8;
X	    }
X	    
X	    if (NO_LOAD_FPU_REG_P(i)
X		&& regs_ever_live[i]
X		&& ! call_used_regs[i])
X	    {
X		if (! LOAD_FPU_REG_P(via_ac))
X		    abort();
X		    
X		fprintf(stream, "\tfldd %d(fp), %s\n", -fsize-k, reg_names[via_ac]);
X		fprintf(stream, "\tfstd %s, %s\n", reg_names[via_ac], reg_names[i]);
X		k -= 8;
X	    }
X	}
X	
X	fprintf(stream, "\tmov fp, sp\n");				
X	fprintf (stream, "\tmov (sp)+, fp\n");     			
X    }								
X    else								
X    {		   
X	via_ac = FIRST_PSEUDO_REGISTER -1;
X	
X	/* get ACs */
X	for (i = FIRST_PSEUDO_REGISTER; i > 7; i--)
X	    if (regs_ever_live[i] && call_used_regs[i])
X		via_ac = i;
X	
X	for (i = FIRST_PSEUDO_REGISTER; i > 7; i--)
X	{
X	    if (LOAD_FPU_REG_P(i)
X		&& regs_ever_live[i]
X		&& ! call_used_regs[i])
X	      fprintf(stream, "\tfldd (sp)+, %s\n", reg_names[i]);
X	    
X	    if (NO_LOAD_FPU_REG_P(i)
X		&& regs_ever_live[i]
X		&& ! call_used_regs[i])
X	    {
X		if (! LOAD_FPU_REG_P(via_ac))
X		    abort();
X		    
X		fprintf(stream, "\tfldd (sp)+, %s\n", reg_names[via_ac]);
X		fprintf(stream, "\tfstd %s, %s\n", reg_names[via_ac], reg_names[i]);
X	    }
X	}
X
X	for (i=7; i >= 0; i--)					
X	    if (regs_ever_live[i] && !call_used_regs[i])		
X		fprintf(stream, "\tmov (sp)+, %s\n", reg_names[i]);	
X								
X	if (fsize)						
X	    fprintf((stream), "\tadd $%d, sp\n", fsize);      		
X    }			
X					
X    fprintf (stream, "\trts pc\n");					
X    fprintf (stream, "\t;/* end of epilogue*/\n\n\n");		
}
X	
/* Return the best assembler insn template
X   for moving operands[1] into operands[0] as a fullword.  */
static char *
singlemove_string (operands)
X     rtx *operands;
{
X  if (operands[1] != const0_rtx)
X    return "mov %1,%0";
X
X  return "clr %0";
}
X
X
/* Output assembler code to perform a doubleword move insn
X   with operands OPERANDS.  */
X
char *
output_move_double (operands)
X     rtx *operands;
{
X  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;
X  rtx latehalf[2];
X  rtx addreg0 = 0, addreg1 = 0;
X
X  /* First classify both operands.  */
X
X  if (REG_P (operands[0]))
X    optype0 = REGOP;
X  else if (offsettable_memref_p (operands[0]))
X    optype0 = OFFSOP;
X  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)
X    optype0 = POPOP;
X  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)
X    optype0 = PUSHOP;
X  else if (GET_CODE (operands[0]) == MEM)
X    optype0 = MEMOP;
X  else
X    optype0 = RNDOP;
X
X  if (REG_P (operands[1]))
X    optype1 = REGOP;
X  else if (CONSTANT_P (operands[1]))
#if 0
X	   || GET_CODE (operands[1]) == CONST_DOUBLE)
#endif
X    optype1 = CNSTOP;
X  else if (offsettable_memref_p (operands[1]))
X    optype1 = OFFSOP;
X  else if (GET_CODE (XEXP (operands[1], 0)) == POST_INC)
X    optype1 = POPOP;
X  else if (GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)
X    optype1 = PUSHOP;
X  else if (GET_CODE (operands[1]) == MEM)
X    optype1 = MEMOP;
X  else
X    optype1 = RNDOP;
X
X  /* Check for the cases that the operand constraints are not
X     supposed to allow to happen.  Abort if we get one,
X     because generating code for these cases is painful.  */
X
X  if (optype0 == RNDOP || optype1 == RNDOP)
X    abort ();
X
X  /* If one operand is decrementing and one is incrementing
X     decrement the former register explicitly
X     and change that operand into ordinary indexing.  */
X
X  if (optype0 == PUSHOP && optype1 == POPOP)
X    {
X      operands[0] = XEXP (XEXP (operands[0], 0), 0);
X      output_asm_insn ("sub $4,%0", operands);
X      operands[0] = gen_rtx (MEM, SImode, operands[0]);
X      optype0 = OFFSOP;
X    }
X  if (optype0 == POPOP && optype1 == PUSHOP)
X    {
X      operands[1] = XEXP (XEXP (operands[1], 0), 0);
X      output_asm_insn ("sub $4,%1", operands);
X      operands[1] = gen_rtx (MEM, SImode, operands[1]);
X      optype1 = OFFSOP;
X    }
X
X  /* If an operand is an unoffsettable memory ref, find a register
X     we can increment temporarily to make it refer to the second word.  */
X
X  if (optype0 == MEMOP)
X    addreg0 = find_addr_reg (XEXP (operands[0], 0));
X
X  if (optype1 == MEMOP)
X    addreg1 = find_addr_reg (XEXP (operands[1], 0));
X
X  /* Ok, we can do one word at a time.
X     Normally we do the low-numbered word first,
X     but if either operand is autodecrementing then we
X     do the high-numbered word first.
X
X     In either case, set up in LATEHALF the operands to use
X     for the high-numbered word and in some cases alter the
X     operands in OPERANDS to be suitable for the low-numbered word.  */
X
X  if (optype0 == REGOP)
X    latehalf[0] = gen_rtx (REG, HImode, REGNO (operands[0]) + 1);
X  else if (optype0 == OFFSOP)
X    latehalf[0] = adj_offsettable_operand (operands[0], 2);
X  else
X    latehalf[0] = operands[0];
X
X  if (optype1 == REGOP)
X    latehalf[1] = gen_rtx (REG, HImode, REGNO (operands[1]) + 1);
X  else if (optype1 == OFFSOP)
X    latehalf[1] = adj_offsettable_operand (operands[1], 2);
X  else if (optype1 == CNSTOP)
X    {
X	if (CONSTANT_P (operands[1]))
X	{
X	    /* now the mess begins, high word is in lower word??? 
X
X	       that's what ashc makes me think, but I don't remember :-( */
X	    latehalf[1] = gen_rtx(CONST_INT, VOIDmode, 
X				  INTVAL(operands[1])>>16);
X	    operands[1] = gen_rtx(CONST_INT, VOIDmode,
X				  INTVAL(operands[1])&0xff);
X	}
X      else if (GET_CODE (operands[1]) == CONST_DOUBLE)
X	{
X	    /* immediate 32 bit values not allowed */
X	    abort();
X	}
X    }
X  else
X    latehalf[1] = operands[1];
X
X  /* If insn is effectively movd N(sp),-(sp) then we will do the
X     high word first.  We should use the adjusted operand 1 (which is N+4(sp))
X     for the low word as well, to compensate for the first decrement of sp.  */
X  if (optype0 == PUSHOP
X      && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM
X      && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))
X    operands[1] = latehalf[1];
X
X  /* If one or both operands autodecrementing,
X     do the two words, high-numbered first.  */
X
X  /* Likewise,  the first move would clobber the source of the second one,
X     do them in the other order.  This happens only for registers;
X     such overlap can't happen in memory unless the user explicitly
X     sets it up, and that is an undefined circumstance.  */
X
X  if (optype0 == PUSHOP || optype1 == PUSHOP
X      || (optype0 == REGOP && optype1 == REGOP
X	  && REGNO (operands[0]) == REGNO (latehalf[1])))
X    {
X      /* Make any unoffsettable addresses point at high-numbered word.  */
X      if (addreg0)
X	output_asm_insn ("add $2,%0", &addreg0);
X      if (addreg1)
X	output_asm_insn ("add $2,%0", &addreg1);
X
X      /* Do that word.  */
X      output_asm_insn (singlemove_string (latehalf), latehalf);
X
X      /* Undo the adds we just did.  */
X      if (addreg0)
X	output_asm_insn ("sub $2,%0", &addreg0);
X      if (addreg1)
X	output_asm_insn ("sub $2,%0", &addreg1);
X
X      /* Do low-numbered word.  */
X      return singlemove_string (operands);
X    }
X
X  /* Normal case: do the two words, low-numbered first.  */
X
X  output_asm_insn (singlemove_string (operands), operands);
X
X  /* Make any unoffsettable addresses point at high-numbered word.  */
X  if (addreg0)
X    output_asm_insn ("add $2,%0", &addreg0);
X  if (addreg1)
X    output_asm_insn ("add $2,%0", &addreg1);
X
X  /* Do that word.  */
X  output_asm_insn (singlemove_string (latehalf), latehalf);
X
X  /* Undo the adds we just did.  */
X  if (addreg0)
X    output_asm_insn ("sub $2,%0", &addreg0);
X  if (addreg1)
X    output_asm_insn ("sub $2,%0", &addreg1);
X
X  return "";
}
/* Output assembler code to perform a quadword move insn
X   with operands OPERANDS.  */
X
char *
output_move_quad (operands)
X     rtx *operands;
{
X  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;
X  rtx latehalf[2];
X  rtx addreg0 = 0, addreg1 = 0;
X
X  output_asm_insn(";; movdi/df: %1 -> %0", operands);
X  
X  if (REG_P (operands[0]))
X    optype0 = REGOP;
X  else if (offsettable_memref_p (operands[0]))
X    optype0 = OFFSOP;
X  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)
X    optype0 = POPOP;
X  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)
X    optype0 = PUSHOP;
X  else if (GET_CODE (operands[0]) == MEM)
X    optype0 = MEMOP;
X  else
X    optype0 = RNDOP;
X
X  if (REG_P (operands[1]))
X    optype1 = REGOP;
X  else if (CONSTANT_P (operands[1])
X	   || GET_CODE (operands[1]) == CONST_DOUBLE)
X    optype1 = CNSTOP;
X  else if (offsettable_memref_p (operands[1]))
X    optype1 = OFFSOP;
X  else if (GET_CODE (XEXP (operands[1], 0)) == POST_INC)
X    optype1 = POPOP;
X  else if (GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)
X    optype1 = PUSHOP;
X  else if (GET_CODE (operands[1]) == MEM)
X    optype1 = MEMOP;
X  else
X    optype1 = RNDOP;
X
X  /* Check for the cases that the operand constraints are not
X     supposed to allow to happen.  Abort if we get one,
X     because generating code for these cases is painful.  */
X
X  if (optype0 == RNDOP || optype1 == RNDOP)
X    abort ();
X  
X  /* check if we move a CPU reg to an FPU reg, or vice versa! */
X  if (optype0 == REGOP && optype1 == REGOP)
X      /* bogus - 64 bit cannot reside in CPU! */
X      if (CPU_REG_P(REGNO(operands[0]))
X	  || CPU_REG_P (REGNO(operands[1])))
X	  abort();
X  
X  if (optype0 == REGOP || optype1 == REGOP)
X  {
X      /* check for use of clrd???? 
X         if you ever allow ac4 and ac5 (now we require secondary load) 
X	 you must check whether 
X	 you want to load into them or store from them - 
X	 then dump ac0 into $help$ movce ac4/5 to ac0, do the 
X	 store from ac0, and restore ac0 - if you can find 
X	 an unused ac[0-3], use that and you save a store and a load!*/
X
X      if (FPU_REG_P(REGNO(operands[0])))
X      {
X	  if (GET_CODE(operands[1]) == CONST_DOUBLE)
X	  {
X	      union { double d; int i[2]; } u;
X	      u.i[0] = CONST_DOUBLE_LOW (operands[1]); 
X	      u.i[1] = CONST_DOUBLE_HIGH (operands[1]); 
X	      
X	      if (u.d == 0.0)
X		  return "clrd %0";
X	  }
X	      
X	  return "ldd %1, %0";
X      }
X      
X      if (FPU_REG_P(REGNO(operands[1])))
X	  return "std %1, %0";
X  }
X      
X  /* If one operand is decrementing and one is incrementing
X     decrement the former register explicitly
X     and change that operand into ordinary indexing.  */
X
X  if (optype0 == PUSHOP && optype1 == POPOP)
X    {
X      operands[0] = XEXP (XEXP (operands[0], 0), 0);
X      output_asm_insn ("sub $8,%0", operands);
X      operands[0] = gen_rtx (MEM, DImode, operands[0]);
X      optype0 = OFFSOP;
X    }
X  if (optype0 == POPOP && optype1 == PUSHOP)
X    {
X      operands[1] = XEXP (XEXP (operands[1], 0), 0);
X      output_asm_insn ("sub $8,%1", operands);
X      operands[1] = gen_rtx (MEM, SImode, operands[1]);
X      optype1 = OFFSOP;
X    }
X
X  /* If an operand is an unoffsettable memory ref, find a register
X     we can increment temporarily to make it refer to the second word.  */
X
X  if (optype0 == MEMOP)
X    addreg0 = find_addr_reg (XEXP (operands[0], 0));
X
X  if (optype1 == MEMOP)
X    addreg1 = find_addr_reg (XEXP (operands[1], 0));
X
X  /* Ok, we can do one word at a time.
X     Normally we do the low-numbered word first,
X     but if either operand is autodecrementing then we
X     do the high-numbered word first.
X
X     In either case, set up in LATEHALF the operands to use
X     for the high-numbered word and in some cases alter the
X     operands in OPERANDS to be suitable for the low-numbered word.  */
X
X  if (optype0 == REGOP)
X    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 2);
X  else if (optype0 == OFFSOP)
X    latehalf[0] = adj_offsettable_operand (operands[0], 4);
X  else
X    latehalf[0] = operands[0];
X
X  if (optype1 == REGOP)
X    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 2);
X  else if (optype1 == OFFSOP)
X    latehalf[1] = adj_offsettable_operand (operands[1], 4);
X  else if (optype1 == CNSTOP)
X    {
X      if (GET_CODE (operands[1]) == CONST_DOUBLE)
X	{
X	    /* floats only. not yet supported!
X
X	     -- compute it into PDP float format, - internally,
X	     just use IEEE and ignore possible problems ;-)
X
X	     we might get away with it !!!! */
X
X	    abort();
X	    
#ifndef HOST_WORDS_BIG_ENDIAN
X	  latehalf[1] = gen_rtx (CONST_INT, VOIDmode,
X				 CONST_DOUBLE_LOW (operands[1]));
X	  operands[1] = gen_rtx (CONST_INT, VOIDmode,
X				 CONST_DOUBLE_HIGH (operands[1]));
#else /* HOST_WORDS_BIG_ENDIAN */
X	  latehalf[1] = gen_rtx (CONST_INT, VOIDmode,
X				 CONST_DOUBLE_HIGH (operands[1]));
X	  operands[1] = gen_rtx (CONST_INT, VOIDmode,
X				 CONST_DOUBLE_LOW (operands[1]));
#endif /* HOST_WORDS_BIG_ENDIAN */
X	}
X    }
X  else
X    latehalf[1] = operands[1];
X
X  /* If insn is effectively movd N(sp),-(sp) then we will do the
X     high word first.  We should use the adjusted operand 1 (which is N+4(sp))
X     for the low word as well, to compensate for the first decrement of sp.  */
X  if (optype0 == PUSHOP
X      && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM
X      && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))
X    operands[1] = latehalf[1];
X
X  /* If one or both operands autodecrementing,
X     do the two words, high-numbered first.  */
X
X  /* Likewise,  the first move would clobber the source of the second one,
X     do them in the other order.  This happens only for registers;
X     such overlap can't happen in memory unless the user explicitly
X     sets it up, and that is an undefined circumstance.  */
X
X  if (optype0 == PUSHOP || optype1 == PUSHOP
X      || (optype0 == REGOP && optype1 == REGOP
X	  && REGNO (operands[0]) == REGNO (latehalf[1])))
X    {
X      /* Make any unoffsettable addresses point at high-numbered word.  */
X      if (addreg0)
X	output_asm_insn ("add $4,%0", &addreg0);
X      if (addreg1)
X	output_asm_insn ("add $4,%0", &addreg1);
X
X      /* Do that word.  */
X      output_asm_insn(output_move_double(latehalf), latehalf);
X
X      /* Undo the adds we just did.  */
X      if (addreg0)
X	output_asm_insn ("sub $4,%0", &addreg0);
X      if (addreg1)
X	output_asm_insn ("sub $4,%0", &addreg1);
X
X      /* Do low-numbered word.  */
X      return output_move_double (operands);
X    }
X
X  /* Normal case: do the two words, low-numbered first.  */
X
X  output_asm_insn (output_move_double (operands), operands);
X
X  /* Make any unoffsettable addresses point at high-numbered word.  */
X  if (addreg0)
X    output_asm_insn ("add $4,%0", &addreg0);
X  if (addreg1)
X    output_asm_insn ("add $4,%0", &addreg1);
X
X  /* Do that word.  */
X  output_asm_insn (output_move_double (latehalf), latehalf);
X
X  /* Undo the adds we just did.  */
X  if (addreg0)
X    output_asm_insn ("sub $4,%0", &addreg0);
X  if (addreg1)
X    output_asm_insn ("sub $4,%0", &addreg1);
X
X  return "";
}
X
X
/* Return a REG that occurs in ADDR with coefficient 1.
X   ADDR can be effectively incremented by incrementing REG.  */
X
static rtx
find_addr_reg (addr)
X     rtx addr;
{
X  while (GET_CODE (addr) == PLUS)
X    {
X      if (GET_CODE (XEXP (addr, 0)) == REG)
X	addr = XEXP (addr, 0);
X      if (GET_CODE (XEXP (addr, 1)) == REG)
X	addr = XEXP (addr, 1);
X      if (CONSTANT_P (XEXP (addr, 0)))
X	addr = XEXP (addr, 1);
X      if (CONSTANT_P (XEXP (addr, 1)))
X	addr = XEXP (addr, 0);
X    }
X  if (GET_CODE (addr) == REG)
X    return addr;
X  return 0;
}
X
/* Output an ascii string.  */
output_ascii (file, p, size)
X     FILE *file;
X     char *p;
X     int size;
{
X  int i;
X
X  fprintf (file, "\t.byte \"");
X
X  for (i = 0; i < size; i++)
X    {
X      register int c = p[i];
X      if (c == '\"' || c == '\\')
X	putc ('\\', file);
X      if (c >= ' ' && c < 0177)
X	putc (c, file);
X      else
X	{
X	  fprintf (file, "\\%03o", c);
X	  /* After an octal-escape, if a digit follows,
X	     terminate one string constant and start another.
X	     The Vax assembler fails to stop reading the escape
X	     after three digits, so this is the only way we
X	     can get it to parse the data properly.  */
X	  if (i < size - 1 && p[i + 1] >= '0' && p[i + 1] <= '9')
X	    fprintf (file, "\"\n\tstring \"");
X	}
X    }
X  fprintf (file, "\"\n");
}
X
X
/* --- stole from out-vax, needs changes */
X
print_operand_address (file, addr)
X     FILE *file;
X     register rtx addr;
{
X  register rtx reg1, reg2, breg, ireg;
X  rtx offset;
X
X retry:
X
X  switch (GET_CODE (addr))
X    {
X    case MEM:
X      fprintf (file, "@");
X      addr = XEXP (addr, 0);
X      goto retry;
X
X    case REG:
X      fprintf (file, "(%s)", reg_names[REGNO (addr)]);
X      break;
X
X    case PRE_DEC:
X      fprintf (file, "-(%s)", reg_names[REGNO (XEXP (addr, 0))]);
X      break;
X
X    case POST_INC:
X      fprintf (file, "(%s)+", reg_names[REGNO (XEXP (addr, 0))]);
X      break;
X
X    case PLUS:
X      reg1 = 0;	reg2 = 0;
X      ireg = 0;	breg = 0;
X      offset = 0;
X      if (CONSTANT_ADDRESS_P (XEXP (addr, 0))
X	  || GET_CODE (XEXP (addr, 0)) == MEM)
X	{
X	  offset = XEXP (addr, 0);
X	  addr = XEXP (addr, 1);
X	}
X      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1))
X	       || GET_CODE (XEXP (addr, 1)) == MEM)
X	{
X	  offset = XEXP (addr, 1);
X	  addr = XEXP (addr, 0);
X	}
X      if (GET_CODE (addr) != PLUS)
X	;
X      else if (GET_CODE (XEXP (addr, 0)) == MULT)
X	{
X	  reg1 = XEXP (addr, 0);
X	  addr = XEXP (addr, 1);
X	}
X      else if (GET_CODE (XEXP (addr, 1)) == MULT)
X	{
X	  reg1 = XEXP (addr, 1);
X	  addr = XEXP (addr, 0);
X	}
X      else if (GET_CODE (XEXP (addr, 0)) == REG)
X	{
X	  reg1 = XEXP (addr, 0);
X	  addr = XEXP (addr, 1);
X	}
X      else if (GET_CODE (XEXP (addr, 1)) == REG)
X	{
X	  reg1 = XEXP (addr, 1);
X	  addr = XEXP (addr, 0);
X	}
X      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT)
X	{
X	  if (reg1 == 0)
X	    reg1 = addr;
X	  else
X	    reg2 = addr;
X	  addr = 0;
X	}
X      if (offset != 0)
X	{
X	  if (addr != 0) abort ();
X	  addr = offset;
X	}
X      if (reg1 != 0 && GET_CODE (reg1) == MULT)
X	{
X	  breg = reg2;
X	  ireg = reg1;
X	}
X      else if (reg2 != 0 && GET_CODE (reg2) == MULT)
X	{
X	  breg = reg1;
X	  ireg = reg2;
X	}
X      else if (reg2 != 0 || GET_CODE (addr) == MEM)
X	{
X	  breg = reg2;
X	  ireg = reg1;
X	}
X      else
X	{
X	  breg = reg1;
X	  ireg = reg2;
X	}
X      if (addr != 0)
X	output_address (addr);
X      if (breg != 0)
X	{
X	  if (GET_CODE (breg) != REG)
X	    abort ();
X	  fprintf (file, "(%s)", reg_names[REGNO (breg)]);
X	}
X      if (ireg != 0)
X	{
X	  if (GET_CODE (ireg) == MULT)
X	    ireg = XEXP (ireg, 0);
X	  if (GET_CODE (ireg) != REG)
X	    abort ();
X	  abort();
X	  fprintf (file, "[%s]", reg_names[REGNO (ireg)]);
X	}
X      break;
X
X    default:
X      output_addr_const (file, addr);
X    }
}
X
/* register move costs, indexed by regs */
X
static int move_costs[N_REG_CLASSES][N_REG_CLASSES] = 
{
X             /* NO  MUL  GEN  LFPU  NLFPU FPU ALL */
X
/* NO */     {  0,   0,   0,    0,    0,    0,   0},
/* MUL */    {  0,   2,   2,   10,   22,   22,  22},
/* GEN */    {  0,   2,   2,   10,   22,   22,  22},
/* LFPU */   {  0,  10,  10,    2,    2,    2,  10},
/* NLFPU */  {  0,  22,  22,    2,    2,    2,  22},
/* FPU */    {  0,  22,  22,    2,    2,    2,  22},
/* ALL */    {  0,  22,  22,   10,   22,   22,  22}
}  ;
X
X
/* -- note that some moves are tremendously expensive, 
X   because they require lots of tricks? do we have to 
X   charge the costs incurred by secondary reload class 
X   -- as we do here with 22 -- or not ? */
X
int 
register_move_cost(c1, c2)
X  enum reg_class c1, c2;
{
X    return move_costs[(int)c1][(int)c2];
}
X
char *
output_jump(pos, neg, length)
X  int length;
X  char *pos, *neg;
{
X    static int x = 0;
X    
X    static char buf[1000];
X
#if 0
/* currently we don't need this, because the tstdf and cmpdf 
X   copy the condition code immediately, and other float operations are not 
X   yet recognized as changing the FCC - if so, then the length-cost of all
X   jump insns increases by one, because we have to potentially copy the 
X   FCC! */
X    if (cc_status.flags & CC_IN_FPU)
X	output_asm_insn("cfcc", NULL);
#endif
X	
X    switch (length)
X    {
X      case 1:
X	
X	strcpy(buf, pos);
X	strcat(buf, " %l0");
X	
X	return buf;
X	
X      case 3:
X	
X	sprintf(buf, "%s JMP_%d\n\tjmp %%l0\nJMP_%d:", neg, x, x);
X	
X	x++;
X	
X	return buf;
X	
X      default:
X	
X	abort();
X    }
X    
}
X
void
notice_update_cc_on_set(exp, insn)
X  rtx exp;
X  rtx insn;
{
X    if (GET_CODE (SET_DEST (exp)) == CC0)
X    { 
X	cc_status.flags = 0;					
X	cc_status.value1 = SET_DEST (exp);			
X	cc_status.value2 = SET_SRC (exp);			
X
/*
X	if (GET_MODE(SET_SRC(exp)) == DFmode)
X	    cc_status.flags |= CC_IN_FPU;
*/	
X    }							
X    else if ((GET_CODE (SET_DEST (exp)) == REG		
X	      || GET_CODE (SET_DEST (exp)) == MEM)		
X	     && GET_CODE (SET_SRC (exp)) != PC		
X	     && (GET_MODE (SET_DEST(exp)) == HImode		
X		 || GET_MODE (SET_DEST(exp)) == QImode)	
X		&& (GET_CODE (SET_SRC(exp)) == PLUS		
X		    || GET_CODE (SET_SRC(exp)) == MINUS	
X		    || GET_CODE (SET_SRC(exp)) == AND	
X		    || GET_CODE (SET_SRC(exp)) == IOR	
X		    || GET_CODE (SET_SRC(exp)) == XOR	
X		    || GET_CODE (SET_SRC(exp)) == NOT	
X		    || GET_CODE (SET_SRC(exp)) == NEG	
X			|| GET_CODE (SET_SRC(exp)) == REG	
X		    || GET_CODE (SET_SRC(exp)) == MEM))	
X    { 
X	cc_status.flags = 0;					
X	cc_status.value1 = SET_SRC (exp);   			
X	cc_status.value2 = SET_DEST (exp);			
X	
X	if (cc_status.value1 && GET_CODE (cc_status.value1) == REG	
X	    && cc_status.value2					
X	    && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))
X    	    cc_status.value2 = 0;					
X	if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM	
X	    && cc_status.value2					
X	    && GET_CODE (cc_status.value2) == MEM)			
X	    cc_status.value2 = 0; 					
X    }							
X    else if (GET_CODE (SET_SRC (exp)) == CALL)		
X    { 
X	CC_STATUS_INIT; 
X    }
X    else if (GET_CODE (SET_DEST (exp)) == REG)       		
X	/* what's this ? */					
X    { 
X	if ((cc_status.value1					
X	     && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value1)))
X	    cc_status.value1 = 0;				
X	if ((cc_status.value2					
X	     && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value2)))
X	    cc_status.value2 = 0;				
X    }							
X    else if (SET_DEST(exp) == pc_rtx)
X    { 
X	/* jump */
X    }
X    else /* if (GET_CODE (SET_DEST (exp)) == MEM)	*/	
X    {  
X	/* the last else is a bit paranoic, but since nearly all instructions 
X	   play with condition codes, it's reasonable! */
X
X	CC_STATUS_INIT; /* paranoia*/ 
X    }		        
}
X
X
int simple_memory_operand(op, mode)
X  rtx op;
X  enum machine_mode mode;
{
X    rtx addr, plus0, plus1;
X    int offset = 0;
X
X    /* Eliminate non-memory operations */
X    if (GET_CODE (op) != MEM)
X	return FALSE;
X
#if 0
X    /* dword operations really put out 2 instructions, so eliminate them.  */
X    if (GET_MODE_SIZE (GET_MODE (op)) > (HAVE_64BIT_P () ? 8 : 4))
X	return FALSE;
#endif
X
X    /* Decode the address now.  */
X
X  indirection:
X    
X    addr = XEXP (op, 0);
X
X    switch (GET_CODE (addr))
X    {
X      case REG:
X	/* (R0) - no extra cost */
X	return 1;
X	
X      case PRE_DEC:
X      case POST_INC:
X	/* -(R0), (R0)+ - cheap! */
X	return 0;
X	
X      case MEM:
X	/* cheap - is encoded in addressing mode info! 
X
X	   -- except for @(R0), which has to be @0(R0) !!! */
X
X	if (GET_CODE (XEXP (addr, 0)) == REG)
X	    return 0;
X	
X	op=addr;
X	goto indirection;
X	
X      case CONST_INT:
X      case LABEL_REF:	       
X      case CONST:
X      case SYMBOL_REF:
X	/* @#address - extra cost */
X	return 0;
X
X      case PLUS:
X	/* X(R0) - extra cost */
X	return 0;
X    }
X    
X    return FALSE;
}
X
X
/*
X * output a block move:
X *
X * operands[0]	... to
X * operands[1]  ... from
X * operands[2]  ... length
X * operands[3]  ... alignment
X * operands[4]  ... scratch register
X */
X
X 
char *
output_block_move(operands)
X  rtx *operands;
{
X    static int count = 0;
X    char buf[200];
X    
X    if (GET_CODE(operands[2]) == CONST_INT
X	&& TARGET_TIME)
X    {
X	if (INTVAL(operands[2]) < 16
X	    && INTVAL(operands[3]) == 1)
X	{
X	    register int i;
X	    
X	    for (i = 1; i <= INTVAL(operands[2]); i++)
X		output_asm_insn("movb (%1)+, (%0)+", operands);
X
X	    return "";
X	}
X	else if (INTVAL(operands[2]) < 32)
X	{
X	    register int i;
X	    
X	    for (i = 1; i <= INTVAL(operands[2])/2; i++)
X		output_asm_insn("mov (%1)+, (%0)+", operands);
X	    
X	    /* may I assume that moved quantity is 
X	       multiple of alignment ???
X
X	       I HOPE SO !
X	    */
X
X	    return "";
X	}
X	
X
X	/* can do other clever things, maybe... */
X    }
X
X    if (CONSTANT_P(operands[2]) )
X    {
X	/* just move count to scratch */
X	output_asm_insn("mov %2, %4", operands);
X    }
X    else
X    {
X	/* just clobber the register */
X	operands[4] = operands[2];
X    }
X    
X
X    /* switch over alignment */
X    switch (INTVAL(operands[3]))
X    {
X      case 1:
X	
X	/* 
X	  x:
X	  movb (%1)+, (%0)+
X	  
X	  if (TARGET_45)
X	     sob %4,x
X	  else
X	     dec %4
X	     bgt x
X
X	*/
X
X	sprintf(buf, "\nmovestrhi%d:", count);
X	output_asm_insn(buf, NULL);
X	
X	output_asm_insn("movb (%1)+, (%0)+", operands);
X	
X	if (TARGET_45)
X	{
X	    sprintf(buf, "sob %%4, movestrhi%d", count);
X	    output_asm_insn(buf, operands);
X	}
X	else
X	{
X	    output_asm_insn("dec %4", operands);
X	    
X	    sprintf(buf, "bgt movestrhi%d", count);
X	    output_asm_insn(buf, NULL);
X	}
X	
X	count ++;
X	break;
X	
X      case 2:
X	
X	/* 
X	   asr %4
X
X	   x:
X
X	   mov (%1)+, (%0)+
X
X	   if (TARGET_45)
X	     sob %4, x
X	   else
X	     dec %4
X	     bgt x
X	*/
X
X      generate_compact_code:
X
X	output_asm_insn("asr %4", operands);
X
X	sprintf(buf, "\nmovestrhi%d:", count);
X	output_asm_insn(buf, NULL);
X	
X	output_asm_insn("mov (%1)+, (%0)+", operands);
X	
X	if (TARGET_45)
X	{
X	    sprintf(buf, "sob %%4, movestrhi%d", count);
X	    output_asm_insn(buf, operands);
X	}
X	else
X	{
X	    output_asm_insn("dec %4", operands);
X	    
X	    sprintf(buf, "bgt movestrhi%d", count);
X	    output_asm_insn(buf, NULL);
X	}
X	
X	count ++;
X	break;
X
X      case 4:
X	
X	/*
X
X	   asr %4
X	   asr %4
X
X	   x:
X
X	   mov (%1)+, (%0)+
X	   mov (%1)+, (%0)+
X
X	   if (TARGET_45)
X	     sob %4, x
X	   else
X	     dec %4
X	     bgt x
X	*/
X
X	if (TARGET_SPACE)
X	    goto generate_compact_code;
X	
X	output_asm_insn("asr %4", operands);
X	output_asm_insn("asr %4", operands);
X
X	sprintf(buf, "\nmovestrhi%d:", count);
X	output_asm_insn(buf, NULL);
X	
X	output_asm_insn("mov (%1)+, (%0)+", operands);
X	output_asm_insn("mov (%1)+, (%0)+", operands);
X	
X	if (TARGET_45)
X	{
X	    sprintf(buf, "sob %%4, movestrhi%d", count);
X	    output_asm_insn(buf, operands);
X	}
X	else
X	{
X	    output_asm_insn("dec %4", operands);
X	    
X	    sprintf(buf, "bgt movestrhi%d", count);
X	    output_asm_insn(buf, NULL);
X	}
X	
X	count ++;
X	break;
X       
X      default:
X	
X	/*
X	   
X	   asr %4
X	   asr %4
X	   asr %4
X
X	   x:
X
X	   mov (%1)+, (%0)+
X	   mov (%1)+, (%0)+
X	   mov (%1)+, (%0)+
X	   mov (%1)+, (%0)+
X	   
X	   if (TARGET_45)
X	     sob %4, x
X	   else
X	     dec %4
X	     bgt x
X	*/
X
X
X	if (TARGET_SPACE)
X	    goto generate_compact_code;
X	
X	output_asm_insn("asr %4", operands);
X	output_asm_insn("asr %4", operands);
X	output_asm_insn("asr %4", operands);
X
X	sprintf(buf, "\nmovestrhi%d:", count);
X	output_asm_insn(buf, NULL);
X	
X	output_asm_insn("mov (%1)+, (%0)+", operands);
X	output_asm_insn("mov (%1)+, (%0)+", operands);
X	output_asm_insn("mov (%1)+, (%0)+", operands);
X	output_asm_insn("mov (%1)+, (%0)+", operands);
X	
X	if (TARGET_45)
X	{
X	    sprintf(buf, "sob %%4, movestrhi%d", count);
X	    output_asm_insn(buf, operands);
X	}
X	else
X	{
X	    output_asm_insn("dec %4", operands);
X	    
X	    sprintf(buf, "bgt movestrhi%d", count);
X	    output_asm_insn(buf, NULL);
X	}
X	
X	count ++;
X	break;
X	
X	;
X	
X    }
X    
X    return "";
}
X
/* for future use */
int
comparison_operator_index(op)
X  rtx op;
{
X    switch (GET_CODE(op))
X    {
X      case NE:
X	return 0;
X	
X      case EQ:
X	return 1;
X	
X      case GE:
X	return 2;
X	
X      case GT:
X	return 3;
X	
X      case LE:
X	return 4;
X	
X      case LT:
X	return 5;
X	
X      case GEU:
X	return 6;
X	
X      case GTU:
X	return 7;
X
X      case LEU:
X	return 8;
X	
X      case LTU:
X	return 9;
X	
X      default:
X	return -1;
X    }
}    
X	
/* tests whether the rtx is a comparison operator */
int
comp_operator (op, mode)
X  rtx op;
X  enum machine_mode mode;
{
X    return comparison_operator_index(op) >= 0;
}
X
X    
int
legitimate_address_p (mode, address)
X  enum machine_mode mode;
X  rtx address;
{
/* #define REG_OK_STRICT */
X    GO_IF_LEGITIMATE_ADDRESS(mode, address, win);
X    
X    return 0;
X    
X  win:
X    return 1;
X
/* #undef REG_OK_STRICT */
}
SHAR_EOF
chmod 0600 config/pdp11/pdp11.c ||
echo 'restore of config/pdp11/pdp11.c failed'
Wc_c="`wc -c < 'config/pdp11/pdp11.c'`"
test 34256 -eq "$Wc_c" ||
	echo 'config/pdp11/pdp11.c: original size 34256, current size' "$Wc_c"
fi
# ============= config/pdp11/pdp11.h ==============
if test -f 'config/pdp11/pdp11.h' -a X"$1" != X"-c"; then
	echo 'x - skipping config/pdp11/pdp11.h (File already exists)'
else
echo 'x - extracting config/pdp11/pdp11.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'config/pdp11/pdp11.h' &&
/* Definitions of target machine for GNU compiler, for the pdp-11
X   Copyright (C) 1991,1992,1993 Michael K. Gschwind (mike@vlsivie.tuwien.ac.at)
X
This file is part of GNU CC.
X
GNU CC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 1, or (at your option)
any later version.
X
GNU CC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
X
You should have received a copy of the GNU General Public License
along with GNU CC; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
X
/* declarations */
char *output_jump();
char *output_move_double();
char *output_move_quad();
char *output_block_move();
X
/* check whther load_fpu_reg or not */
#define LOAD_FPU_REG_P(x) ((x)>=8 && (x)<=11)
#define NO_LOAD_FPU_REG_P(x) ((x)==12 || (x)==13)
#define FPU_REG_P(x)	(LOAD_FPU_REG_P(x) || NO_LOAD_FPU_REG_P(x))
#define CPU_REG_P(x)	((x)<8)
X
/* Names to predefine in the preprocessor for this target machine.  */
X
#define CPP_PREDEFINES "-Dpdp11"
X
/* Print subsidiary information on the compiler version in use.  */
#define TARGET_VERSION fprintf (stderr, " (pdp11)");
X
X
/* Generate DBX debugging information.  */
X
/* #define DBX_DEBUGGING_INFO */
X
/* Run-time compilation parameters selecting different hardware subsets.
*/
X
extern int target_flags;
X
/* Macro to define tables used to set the flags.
X   This is a list in braces of pairs in braces,
X   each pair being { "NAME", VALUE }
X   where VALUE is the bits to set or minus the bits to clear.
X   An empty string NAME is used to identify the default VALUE.  */
X
#define TARGET_SWITCHES  \
{   { "fpu", 1},		\
X    { "soft-float", -1},       	\
/* return float result in ac0 */\
X    { "ac0", 2},		\
X    { "no-ac0", -2},		\
/* is 11/40 */			\
X    { "40", 4},			\
X    { "no-40", -4},		\
/* is 11/45 */			\
X    { "45", 8},			\
X    { "no-45", -8},		\
/* is 11/10 */			\
X    { "10", -12},		\
/* use movstrhi for bcopy */	\
X    { "bcopy", 16},		\
X    { "bcopy-builtin", -16},	\
/* use 32 bit for int */	\
X    { "int32", 32},		\
X    { "no-int16", 32},		\
X    { "int16", -32},		\
X    { "no-int32", -32},		\
/* use 32 bit for float */	\
X    { "float32", 64},		\
X    { "no-float64", 64},	\
X    { "float64", -64},		\
X    { "no-float32", -64},	\
/* allow abshi pattern? - can trigger "optimizations" which make code SLOW! */\
X    { "abshi", 128},		\
X    { "no-abshi", -128},	\
/* is branching expensive - on a PDP, it's actually really cheap */ \
/* this is just to play aroound and check what code gcc generates */ \
X    { "branch-expensive", 256}, \
X    { "branch-cheap", -256},	\
/* optimize for space instead of time - just in a couple of places */ \
X    { "space", 512 },		\
X    { "time", -512 },		\
/* default */			\
X    { "", TARGET_DEFAULT}	\
}
X
#define TARGET_DEFAULT (1 | 8 | 128)
X
#define TARGET_FPU 		(target_flags & 1)
#define TARGET_SOFT_FLOAT 	(!TARGET_FPU)
X
#define TARGET_AC0		((target_flags & 2) && TARGET_FPU)
#define TARGET_NO_AC0		(! TARGET_AC0)
X
#define TARGET_45		(target_flags & 8)
#define TARGET_40_PLUS		((target_flags & 4) || (target_flags))
#define TARGET_10		(! TARGET_40_PLUS)
X
#define TARGET_BCOPY_BUILTIN	(! (target_flags & 16))
X
#define TARGET_INT16		(! TARGET_INT32)
#define TARGET_INT32		(target_flags & 32)
X
#define TARGET_FLOAT32		(target_flags & 64)
#define TARGET_FLOAT64		(! TARGET_FLOAT32)
X
#define TARGET_ABSHI_BUILTIN	(target_flags & 128)
X
#define TARGET_BRANCH_EXPENSIVE	(target_flags & 256)
#define TARGET_BRANCH_CHEAP 	(!TARGET_BRANCH_EXPENSIVE)
X
#define TARGET_SPACE 		(target_flags & 512)
#define TARGET_TIME		(! TARGET_SPACE)
X
X
/* TYPE SIZES */
#define CHAR_TYPE_SIZE		8
#define SHORT_TYPE_SIZE		16
#define INT_TYPE_SIZE		(TARGET_INT16 ? 16 : 32)
#define LONG_TYPE_SIZE		32
#define LONG_LONG_TYPE_SIZE	64     
X
/* if we set FLOAT_TYPE_SIZE to 32, we could have the benefit 
X   of saving core for huge arrays - the definitions are 
X   already in md - but floats can never reside in 
X   an FPU register - we keep the FPU in double float mode 
X   all the time !! */
#define FLOAT_TYPE_SIZE		(TARGET_FLOAT32 ? 32 : 64)
#define DOUBLE_TYPE_SIZE	64
#define LONG_DOUBLE_TYPE_SIZE	64
X
/* machine types from ansi */
#define SIZE_TYPE "unsigned int" 	/* definition of size_t */
X
/* is used in cexp.y - we don't have target_flags there, 
X   so just give default definition 
X
X   hope it does not come back to haunt us! */
#define WCHAR_TYPE "int" 		/* or long int???? */
#define WCHAR_TYPE_SIZE 16
X
#define PTRDIFF_TYPE "int"
X
/* target machine storage layout */
X
/* Define this if most significant bit is lowest numbered
X   in instructions that operate on numbered bit-fields.  */
#define BITS_BIG_ENDIAN 0
X
/* Define this if most significant byte of a word is the lowest numbered.  */
#define BYTES_BIG_ENDIAN 0
X
/* Define this if most significant word of a multiword number is numbered.  */
#define WORDS_BIG_ENDIAN 1
X
/* number of bits in an addressible storage unit */
#define BITS_PER_UNIT 8
X
/* Width in bits of a "word", which is the contents of a machine register.
X   Note that this is not necessarily the width of data type `int';
X   if using 16-bit ints on a 68000, this would still be 32.
X   But on a machine with 16-bit registers, this would be 16.  */
/*  This is a machine with 16-bit registers */
#define BITS_PER_WORD 16
X
/* Width of a word, in units (bytes). 
X
X   UNITS OR BYTES - seems like units */
#define UNITS_PER_WORD 2
X
/* Maximum sized of reasonable data type 
X   DImode or Dfmode ...*/
#define MAX_FIXED_MODE_SIZE 64	
X
/* Width in bits of a pointer.
X   See also the macro `Pmode' defined below.  */
#define POINTER_SIZE 16
X
/* Allocation boundary (in *bits*) for storing pointers in memory.  */
#define POINTER_BOUNDARY 16
X
/* Allocation boundary (in *bits*) for storing arguments in argument list.  */
#define PARM_BOUNDARY 16
X
/* Allocation boundary (in *bits*) for the code of a function.  */
#define FUNCTION_BOUNDARY 16
X
/* Alignment of field after `int : 0' in a structure.  */
#define EMPTY_FIELD_BOUNDARY 16
X
/* No data type wants to be aligned rounder than this.  */
#define BIGGEST_ALIGNMENT 16
X
/* Define this if move instructions will actually fail to work
X   when given unaligned data.  */
#define STRICT_ALIGNMENT 1
X
/* Standard register usage.  */
X
/* Number of actual hardware registers.
X   The hardware registers are assigned numbers for the compiler
X   from 0 to just below FIRST_PSEUDO_REGISTER.
X   All registers that the compiler knows about must be given numbers,
X   even those that are not normally considered general registers.
X
X   we have 8 integer registers, plus 6 float 
X   (don't use scratch float !) */
X
#define FIRST_PSEUDO_REGISTER 14
X
/* 1 for registers that have pervasive standard uses
X   and are not available for the register allocator.
X
X   On the pdp, these are:
X   Reg 7	= pc;
X   reg 6	= sp;
X   reg 5	= fp;  not necessarily! 
*/
X
/* don't let them touch fp regs for the time being !*/
X
#define FIXED_REGISTERS  \
{0, 0, 0, 0, 0, 0, 1, 1, \
X 0, 0, 0, 0, 0, 0     }
X
X
X
/* 1 for registers not available across function calls.
X   These must include the FIXED_REGISTERS and also any
X   registers that can be used without being saved.
X   The latter must include the registers where values are returned
X   and the register where structure-value addresses are passed.
X   Aside from that, you can include as many other registers as you like.  */
X
/* don't know about fp */
#define CALL_USED_REGISTERS  \
{1, 1, 0, 0, 0, 0, 1, 1, \
X 0, 0, 0, 0, 0, 0 }
X
X
/* Make sure everything's fine if we *don't* have an FPU.
X   This assumes that putting a register in fixed_regs will keep the
X   compiler's mitts completely off it.  We don't bother to zero it out
X   of register classes.  
*/
#define CONDITIONAL_REGISTER_USAGE \
{ 						\
X  int i; 					\
X  HARD_REG_SET x; 				\
X  if (!TARGET_FPU)				\
X    { 						\
X      COPY_HARD_REG_SET (x, reg_class_contents[(int)FPU_REGS]); \
X      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \
X       if (TEST_HARD_REG_BIT (x, i)) 		\
X	fixed_regs[i] = call_used_regs[i] = 1; 	\
X    } 						\
X						\
X  if (TARGET_AC0)				\
X      call_used_regs[8] = 1;			\
}
X
/* Return number of consecutive hard regs needed starting at reg REGNO
X   to hold something of mode MODE.
X   This is ordinarily the length in words of a value of mode MODE
X   but can be less for certain modes in special long registers.
*/
X
#define HARD_REGNO_NREGS(REGNO, MODE)   \
((REGNO < 8)?								\
X    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)	\
X    :1)
X    
X
/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.
X   On the pdp, the cpu registers can hold any mode - check alignment
X
X   FPU can only hold DF - simplifies life!
*/
#define HARD_REGNO_MODE_OK(REGNO, MODE) \
((REGNO < 8)?						\
X  ((GET_MODE_BITSIZE(MODE) <= 16) 			\
X   || (GET_MODE_BITSIZE(MODE) == 32 && !(REGNO & 1)))	\
X  :(MODE) == DFmode)
X    
X
/* Value is 1 if it is a good idea to tie two pseudo registers
X   when one has mode MODE1 and one has mode MODE2.
X   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,
X   for any hard reg, then this must be 0 for correct output.  */
#define MODES_TIEABLE_P(MODE1, MODE2) 0
X
/* Specify the registers used for certain standard purposes.
X   The values of these macros are register numbers.  */
X
/* the pdp11 pc overloaded on a register that the compiler knows about.  */
#define PC_REGNUM  7
X
/* Register to use for pushing function arguments.  */
#define STACK_POINTER_REGNUM 6
X
/* Base register for access to local variables of the function.  */
#define FRAME_POINTER_REGNUM 5
X
/* Value should be nonzero if functions must have frame pointers.
X   Zero means the frame pointer need not be set up (and parms
X   may be accessed via the stack pointer) in functions that seem suitable.
X   This is computed in `reload', in reload1.c.
X  */
X
#define FRAME_POINTER_REQUIRED 0
X
/* Base register for access to arguments of the function.  */
#define ARG_POINTER_REGNUM 5
X
/* Register in which static-chain is passed to a function.  */
/* ??? - i don't want to give up a reg for this! */
#define STATIC_CHAIN_REGNUM 4
X
/* Register in which address to store a structure value
X   is passed to a function.  
X   let's make it an invisible first argument!!! */
X
#define STRUCT_VALUE 0
X
X
/* Define the classes of registers for register constraints in the
X   machine description.  Also define ranges of constants.
X
X   One of the classes must always be named ALL_REGS and include all hard regs.
X   If there is more than one class, another class must be named NO_REGS
X   and contain no registers.
X
X   The name GENERAL_REGS must be the name of a class (or an alias for
X   another name such as ALL_REGS).  This is the class of registers
X   that is allowed by "g" or "r" in a register constraint.
X   Also, registers outside this class are allocated only when
X   instructions express preferences for them.
X
X   The classes must be numbered in nondecreasing order; that is,
X   a larger-numbered class must never be contained completely
X   in a smaller-numbered class.
X
X   For any two classes, it is very desirable that there be another
X   class that represents their union.  */
X   
/* The pdp has a couple of classes:
X
MUL_REGS are used for odd numbered regs, to use in 16 bit multiplication
X         (even numbered do 32 bit multiply)
LMUL_REGS long multiply registers (even numbered regs )
X	  (don't need them, all 32 bit regs are even numbered!)
GENERAL_REGS is all cpu
LOAD_FPU_REGS is the first four cpu regs, they are easier to load
NO_LOAD_FPU_REGS is ac4 and ac5, currently - difficult to load them
FPU_REGS is all fpu regs 
*/
X
enum reg_class { NO_REGS, MUL_REGS, GENERAL_REGS, LOAD_FPU_REGS, NO_LOAD_FPU_REGS, FPU_REGS, ALL_REGS, LIM_REG_CLASSES };
X
#define N_REG_CLASSES (int) LIM_REG_CLASSES
X
/* have to allow this till cmpsi/tstsi are fixed in a better way !! */
#define SMALL_REGISTER_CLASSES 
X
/* Since GENERAL_REGS is the same class as ALL_REGS,
X   don't give it a different class number; just make it an alias.  */
X
/* #define GENERAL_REGS ALL_REGS */
X
/* Give names of register classes as strings for dump file.   */
X
#define REG_CLASS_NAMES {"NO_REGS", "MUL_REGS", "GENERAL_REGS", "LOAD_FPU_REGS", "NO_LOAD_FPU_REGS", "FPU_REGS", "ALL_REGS" }
X
/* Define which registers fit in which classes.
X   This is an initializer for a vector of HARD_REG_SET
X   of length N_REG_CLASSES.  */
X
#define REG_CLASS_CONTENTS {0, 0x00aa, 0x00ff, 0x0f00, 0x3000, 0x3f00, 0x3fff}
X
/* The same information, inverted:
X   Return the class number of the smallest class containing
X   reg number REGNO.  This could be a conditional expression
X   or could index an array.  */
X
#define REGNO_REG_CLASS(REGNO) 		\
((REGNO)>=8?((REGNO)<=11?LOAD_FPU_REGS:NO_LOAD_FPU_REGS):((REGNO&1)?MUL_REGS:GENERAL_REGS))
X
X
/* The class value for index registers, and the one for base regs.  */
#define INDEX_REG_CLASS GENERAL_REGS
#define BASE_REG_CLASS GENERAL_REGS
X
/* Get reg_class from a letter such as appears in the machine description.  */
X
#define REG_CLASS_FROM_LETTER(C)	\
((C) == 'f' ? FPU_REGS :			\
X  ((C) == 'd' ? MUL_REGS : 			\
X   ((C) == 'a' ? LOAD_FPU_REGS : NO_REGS)))
X    
X
/* The letters I, J, K, L and M in a register constraint string
X   can be used to stand for particular ranges of immediate operands.
X   This macro defines what the ranges are.
X   C is the letter, and VALUE is a constant value.
X   Return 1 if VALUE is in the range specified by C.
X
X   I		bits 31-16 0000
X   J		bits 15-00 0000
X   K		completely random 32 bit
X   L,M,N	-1,1,0 respectively
X   O 		where doing shifts in sequence is faster than 
X                one big shift 
*/
X
#define CONST_OK_FOR_LETTER_P(VALUE, C)  \
X  ((C) == 'I' ? ((VALUE) & 0xffff0000) == 0		\
X   : (C) == 'J' ? ((VALUE) & 0x0000ffff) == 0  	       	\
X   : (C) == 'K' ? (((VALUE) & 0xffff0000) != 0		\
X		   && ((VALUE) & 0x0000ffff) != 0)	\
X   : (C) == 'L' ? ((VALUE) == 1)			\
X   : (C) == 'M' ? ((VALUE) == -1)			\
X   : (C) == 'N' ? ((VALUE) == 0)			\
X   : (C) == 'O' ? (abs(VALUE) >1 && abs(VALUE) <= 4)		\
X   : 0)
X
/* Similar, but for floating constants, and defining letters G and H.
X   Here VALUE is the CONST_DOUBLE rtx itself.  */
X
#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \
X  ((C) == 'G' && XINT (VALUE, 0) == 0 && XINT (VALUE, 1) == 0)
X
X
/* Letters in the range `Q' through `U' may be defined in a
X   machine-dependent fashion to stand for arbitrary operand types. 
X   The machine description macro `EXTRA_CONSTRAINT' is passed the
X   operand as its first argument and the constraint letter as its
X   second operand.
X
X   `Q'	is for memory refereces using take more than 1 instruction.
X   `R'	is for memory refereces which take 1 word for the instruction.  */
X
#define EXTRA_CONSTRAINT(OP,CODE)					\
X  ((GET_CODE (OP) != MEM) ? 0						\
X   : !legitimate_address_p (GET_MODE (OP), XEXP (OP, 0)) ? 0		\
X   : ((CODE) == 'Q')	  ? !simple_memory_operand (OP, GET_MODE (OP))	\
X   : ((CODE) == 'R')	  ? simple_memory_operand (OP, GET_MODE (OP))	\
X   : 0)
X
/* Given an rtx X being reloaded into a reg required to be
X   in class CLASS, return the class of reg to actually use.
X   In general this is just CLASS; but on some machines
X   in some cases it is preferable to use a more restrictive class.  
X
loading is easier into LOAD_FPU_REGS than FPU_REGS! */
X
#define PREFERRED_RELOAD_CLASS(X,CLASS) 	\
(((CLASS) != FPU_REGS)?(CLASS):LOAD_FPU_REGS)
X
#define SECONDARY_RELOAD_CLASS(CLASS,MODE,x)	\
(((CLASS) == NO_LOAD_FPU_REGS && !(REG_P(x) && LOAD_FPU_REG_P(REGNO(x))))?LOAD_FPU_REGS:NO_REGS)
X
/* Return the maximum number of consecutive registers
X   needed to represent mode MODE in a register of class CLASS.  */
#define CLASS_MAX_NREGS(CLASS, MODE)	\
((CLASS == GENERAL_REGS || CLASS == MUL_REGS)?				\
X  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD):	\
X  1									\
)
X
X
/* Stack layout; function entry, exit and calling.  */
X
/* Define this if pushing a word on the stack
X   makes the stack pointer a smaller address.  */
#define STACK_GROWS_DOWNWARD
X
/* Define this if the nominal address of the stack frame
X   is at the high-address end of the local variables;
X   that is, each additional local variable allocated
X   goes at a more negative offset in the frame.
*/
#define FRAME_GROWS_DOWNWARD
X
/* Offset within stack frame to start allocating local variables at.
X   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the
X   first local allocated.  Otherwise, it is the offset to the BEGINNING
X   of the first local allocated.  */
#define STARTING_FRAME_OFFSET 0
X
/* If we generate an insn to push BYTES bytes,
X   this says how many the stack pointer really advances by.
X   On the pdp11, the stack is on an even boundary */
#define PUSH_ROUNDING(BYTES) ((BYTES + 1) & ~1)
X
/* current_first_parm_offset stores the # of registers pushed on the 
X   stack */
extern int current_first_parm_offset;
X
/* Offset of first parameter from the argument pointer register value.  
X   For the pdp11, this is non-zero to account for the return address.
X	1 - return address
X	2 - frame pointer (always saved, even when not used!!!!)
X		-- chnage some day !!!:q!
X
*/
#define FIRST_PARM_OFFSET(FNDECL) 4
X
/* Value is 1 if returning from a function call automatically
X   pops the arguments described by the number-of-args field in the call.
X   FUNTYPE is the data type of the function (as a tree),
X   or for a library call it is an identifier node for the subroutine name.  */
X
#define RETURN_POPS_ARGS(FUNTYPE,SIZE) 0
X
/* Define how to find the value returned by a function.
X   VALTYPE is the data type of the value (as a tree).
X   If the precise function being called is known, FUNC is its FUNCTION_DECL;
X   otherwise, FUNC is 0.  */
#define BASE_RETURN_VALUE_REG(MODE) \
X ((MODE) == DFmode ? 8 : 0) 
X
/* On the pdp11 the value is found in R0 (or ac0??? 
not without FPU!!!! ) */
X
#define FUNCTION_VALUE(VALTYPE, FUNC)  \
X  gen_rtx (REG, TYPE_MODE (VALTYPE), BASE_RETURN_VALUE_REG(TYPE_MODE(VALTYPE)))
X
/* and the called function leaves it in the first register.
X   Difference only on machines with register windows.  */
X
#define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)  \
X  gen_rtx (REG, TYPE_MODE (VALTYPE), BASE_RETURN_VALUE_REG(TYPE_MODE(VALTYPE)))
X
/* Define how to find the value returned by a library function
X   assuming the value has mode MODE.  */
X
#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, BASE_RETURN_VALUE_REG(MODE))
X
/* 1 if N is a possible register number for a function value
X   as seen by the caller.
X   On the pdp, the first "output" reg is the only register thus used. 
X
maybe ac0 ? - as option someday! */
X
#define FUNCTION_VALUE_REGNO_P(N) (((N) == 0) || (TARGET_AC0 && (N) == 8))
X
/* should probably return DImode and DFmode in memory,lest
X   we fill up all regs!
X
X have to, else we crash - exceptio: maybe return result in 
X ac0 if DFmode and FPU present - compatibility problem with
X libraries for non-floating point ...
*/
X
#define RETURN_IN_MEMORY(TYPE)	\
X  (TYPE_MODE(TYPE) == DImode || (TYPE_MODE(TYPE) == DFmode && ! TARGET_AC0))
X
X
/* 1 if N is a possible register number for function argument passing.
X   - not used on pdp */
X
#define FUNCTION_ARG_REGNO_P(N) 0
X
/* Define a data type for recording info about an argument list
X   during the scan of that argument list.  This data type should
X   hold all necessary information about the function itself
X   and about the args processed so far, enough to enable macros
X   such as FUNCTION_ARG to determine where the next arg should go.
X
*/
X
#define CUMULATIVE_ARGS int
X
/* Initialize a variable CUM of type CUMULATIVE_ARGS
X   for a call to a function whose data type is FNTYPE.
X   For a library call, FNTYPE is 0.
X
X   ...., the offset normally starts at 0, but starts at 1 word
X   when the function gets a structure-value-address as an
X   invisible first argument.  */
X
#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)	\
X ((CUM) = 0)
X
/* Update the data in CUM to advance over an argument
X   of mode MODE and data type TYPE.
X   (TYPE is null for libcalls where that information may not be available.)  
X
*/
X
X
#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)	\
X ((CUM) += ((MODE) != BLKmode			\
X	    ? (GET_MODE_SIZE (MODE))		\
X	    : (int_size_in_bytes (TYPE))))	
X
/* Determine where to put an argument to a function.
X   Value is zero to push the argument on the stack,
X   or a hard register in which to store the argument.
X
X   MODE is the argument's machine mode.
X   TYPE is the data type of the argument (as a tree).
X    This is null for libcalls where that information may
X    not be available.
X   CUM is a variable of type CUMULATIVE_ARGS which gives info about
X    the preceding args and about the function being called.
X   NAMED is nonzero if this argument is a named parameter
X    (otherwise it is an extra parameter matching an ellipsis).  */
X
#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)  0
X
/* Define where a function finds its arguments.
X   This would be different from FUNCTION_ARG if we had register windows.  */
/*
#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)	\
X  FUNCTION_ARG (CUM, MODE, TYPE, NAMED)
*/
X
/* For an arg passed partly in registers and partly in memory,
X   this is the number of registers used.
X   For args passed entirely in registers or entirely in memory, zero.  */
X
#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0
X
/* This macro generates the assembly code for function entry. */
#define FUNCTION_PROLOGUE(FILE, SIZE) \
X    output_function_prologue(FILE, SIZE);
X
/* Output assembler code to FILE to increment profiler label # LABELNO
X   for profiling a function entry.  */
X
#define FUNCTION_PROFILER(FILE, LABELNO)  \
X   abort ();
X
/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
X   the stack pointer does not matter.  The value is tested only in
X   functions that have frame pointers.
X   No definition is equivalent to always zero.  */
X
extern int may_call_alloca;
extern int current_function_pretend_args_size;
X
#define EXIT_IGNORE_STACK	1
X
/* This macro generates the assembly code for function exit,
X   on machines that need it.  If FUNCTION_EPILOGUE is not defined
X   then individual return instructions are generated for each
X   return statement.  Args are same as for FUNCTION_PROLOGUE.
*/
X
#define FUNCTION_EPILOGUE(FILE, SIZE) \
X    output_function_epilogue(FILE, SIZE);
X  
#define INITIAL_FRAME_POINTER_OFFSET(DEPTH_VAR)	\
{								\
X  int offset, regno;		      				\
X  offset = get_frame_size();					\
X  for (regno = 0; regno < 8; regno++)				\
X    if (regs_ever_live[regno] && ! call_used_regs[regno])	\
X      offset += 2;						\
X  for (regno = 8; regno < 14; regno++)				\
X    if (regs_ever_live[regno] && ! call_used_regs[regno])	\
X      offset += 8;						\
X  /* offset -= 2;   no fp on stack frame */			\
X  (DEPTH_VAR) = offset;						\
}   
X    
X
/* Addressing modes, and classification of registers for them.  */
X
#define HAVE_POST_INCREMENT
/* #define HAVE_POST_DECREMENT */
X
#define HAVE_PRE_DECREMENT
/* #define HAVE_PRE_INCREMENT */
X
/* Macros to check register numbers against specific register classes.  */
X
/* These assume that REGNO is a hard or pseudo reg number.
X   They give nonzero only if REGNO is a hard reg of the suitable class
X   or a pseudo reg currently allocated to a suitable hard reg.
X   Since they use reg_renumber, they are safe only once reg_renumber
X   has been allocated, which happens in local-alloc.c.  */
X
#define REGNO_OK_FOR_INDEX_P(REGNO) \
X  ((REGNO) < 8 || (unsigned) reg_renumber[REGNO] < 8)
#define REGNO_OK_FOR_BASE_P(REGNO)  \
X  ((REGNO) < 8 || (unsigned) reg_renumber[REGNO] < 8)
X
/* Now macros that check whether X is a register and also,
X   strictly, whether it is in a specified class.
*/
X
X
X
/* Maximum number of registers that can appear in a valid memory address.  */
X
#define MAX_REGS_PER_ADDRESS 2
X
/* Recognize any constant value that is a valid address.  */
X
#define CONSTANT_ADDRESS_P(X)  CONSTANT_P (X)
X
/* Nonzero if the constant value X is a legitimate general operand.
X   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */
X
#define LEGITIMATE_CONSTANT_P(X) (1)
X
/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx
X   and check its validity for a certain class.
X   We have two alternate definitions for each of them.
X   The usual definition accepts all pseudo regs; the other rejects
X   them unless they have been allocated suitable hard regs.
X   The symbol REG_OK_STRICT causes the latter definition to be used.
X
X   Most source files want to accept pseudo regs in the hope that
X   they will get allocated to the class that the insn wants them to be in.
X   Source files for reload pass need to be strict.
X   After reload, it makes no difference, since pseudo regs have
X   been eliminated by then.  */
X
#ifndef REG_OK_STRICT
X
/* Nonzero if X is a hard reg that can be used as an index
X   or if it is a pseudo reg.  */
#define REG_OK_FOR_INDEX_P(X) (1)
/* Nonzero if X is a hard reg that can be used as a base reg
X   or if it is a pseudo reg.  */
#define REG_OK_FOR_BASE_P(X) (1)
X
#else
X
/* Nonzero if X is a hard reg that can be used as an index.  */
#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))
/* Nonzero if X is a hard reg that can be used as a base reg.  */
#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))
X
#endif
X
/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression
X   that is a valid memory address for an instruction.
X   The MODE argument is the machine mode for the MEM expression
X   that wants to use this address.
X
*/
X
#define GO_IF_LEGITIMATE_ADDRESS(mode, operand, ADDR) \
{						      \
X    rtx xfoob;								\
X									\
X    /* accept (R0) */							\
X    if (GET_CODE (operand) == REG					\
X	&& REG_OK_FOR_BASE_P(operand))					\
X      goto ADDR;							\
X									\
X    /* accept @#address */						\
X    if (CONSTANT_ADDRESS_P (operand))					\
X      goto ADDR;							\
X    									\
X    /* accept X(R0) */							\
X    if (GET_CODE (operand) == PLUS       				\
X	&& GET_CODE (XEXP (operand, 0)) == REG				\
X	&& REG_OK_FOR_BASE_P (XEXP (operand, 0))			\
X	&& CONSTANT_ADDRESS_P (XEXP (operand, 1)))			\
X      goto ADDR;							\
X    									\
X    /* accept -(R0) */							\
X    if (GET_CODE (operand) == PRE_DEC					\
X	&& GET_CODE (XEXP (operand, 0)) == REG				\
X	&& REG_OK_FOR_BASE_P (XEXP (operand, 0)))			\
X      goto ADDR;							\
X									\
X    /* accept (R0)+ */							\
X    if (GET_CODE (operand) == POST_INC					\
X	&& GET_CODE (XEXP (operand, 0)) == REG				\
X	&& REG_OK_FOR_BASE_P (XEXP (operand, 0)))			\
X      goto ADDR;							\
X    									\
X    /* handle another level of indirection ! */				\
X    if (GET_CODE(operand) != MEM)					\
X      goto fail;							\
X									\
X    xfoob = XEXP (operand, 0);						\
X									\
X    /* (MEM:xx (MEM:xx ())) is not valid for SI, DI and currently */    \
X    /* also forbidden for float, because we have to handle this */  	\
X    /* in output_move_double and/or output_move_quad() - we could */   	\
X    /* do it, but currently it's not worth it!!! */			\
X    /* now that DFmode cannot go into CPU register file, */		\
X    /* maybe I should allow float ... */				\
X    /*  but then I have to handle memory-to-memory moves in movdf ?? */ \
X									\
X    if (GET_MODE_BITSIZE(mode) > 16)					\
X      goto fail;							\
X									\
X    /* accept @(R0) - which is @0(R0) */				\
X    if (GET_CODE (xfoob) == REG						\
X	&& REG_OK_FOR_BASE_P(xfoob))					\
X      goto ADDR;							\
X									\
X    /* accept @address */						\
X    if (CONSTANT_ADDRESS_P (xfoob))					\
X      goto ADDR;							\
X    									\
X    /* accept @X(R0) */							\
X    if (GET_CODE (xfoob) == PLUS       					\
X	&& GET_CODE (XEXP (xfoob, 0)) == REG				\
X	&& REG_OK_FOR_BASE_P (XEXP (xfoob, 0))				\
X	&& CONSTANT_ADDRESS_P (XEXP (xfoob, 1)))			\
X      goto ADDR;							\
X									\
X    /* accept @-(R0) */							\
X    if (GET_CODE (xfoob) == PRE_DEC					\
X	&& GET_CODE (XEXP (xfoob, 0)) == REG				\
X	&& REG_OK_FOR_BASE_P (XEXP (xfoob, 0)))				\
X      goto ADDR;							\
X									\
X    /* accept @(R0)+ */							\
X    if (GET_CODE (xfoob) == POST_INC					\
X	&& GET_CODE (XEXP (xfoob, 0)) == REG				\
X	&& REG_OK_FOR_BASE_P (XEXP (xfoob, 0)))				\
X      goto ADDR;							\
X									\
X  /* anything else is illegal */					\
X  fail: ;								\
}
X
X
/* Try machine-dependent ways of modifying an illegitimate address
X   to be legitimate.  If we find one, return the new, valid address.
X   This macro is used in only one place: `memory_address' in explow.c.
X
X   OLDX is the address as it was before break_out_memory_refs was called.
X   In some cases it is useful to look at this to decide what needs to be done.
X
X   MODE and WIN are passed so that this macro can use
X   GO_IF_LEGITIMATE_ADDRESS.
X
X   It is always safe for this macro to do nothing.  It exists to recognize
X   opportunities to optimize the output.  */
X
#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)	{}
X
X
/* Go to LABEL if ADDR (a legitimate address expression)
X   has an effect that depends on the machine mode it is used for.
X   On the the pdp this is for predec/postinc */
X
#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)	\
X { if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC)	\
X     goto LABEL; 							\
X }
X
X
/* Specify the machine mode that this machine uses
X   for the index in the tablejump instruction.  */
#define CASE_VECTOR_MODE HImode
X
/* Define this if a raw index is all that is needed for a
X   `tablejump' insn.  */
#define CASE_TAKES_INDEX_RAW
X
/* Define this if the tablejump instruction expects the table
X   to contain offsets from the address of the table.
X   Do not define this if the table should contain absolute addresses.  */
/* #define CASE_VECTOR_PC_RELATIVE */
X
/* Specify the tree operation to be used to convert reals to integers.  */
#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR
X
/* This is the kind of divide that is easiest to do in the general case.  */
#define EASY_DIV_EXPR TRUNC_DIV_EXPR
X
/* Define this as 1 if `char' should by default be signed; else as 0.  */
#define DEFAULT_SIGNED_CHAR 1
X
/* Max number of bytes we can move from memory to memory
X   in one reasonably fast instruction.  
*/
X
#define MOVE_MAX 2
X
/* Zero extension is faster if the target is known to be zero */
/* #define SLOW_ZERO_EXTEND */
X
/* Nonzero if access to memory by byte is slow and undesirable. -
*/
#define SLOW_BYTE_ACCESS 0
X
/* Do not break .stabs pseudos into continuations.  */
#define DBX_CONTIN_LENGTH 0
X
/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits
X   is done just by pretending it is already truncated.  */
#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1
X
X
/* Add any extra modes needed to represent the condition code.
X
X   CCFPmode is used for FPU, but should we use a separate reg? */
#define EXTRA_CC_MODES CCFPmode
X
/* the name for the mode above */
#define EXTRA_CC_NAMES "CCFPmode"
X
/* Give a comparison code (EQ, NE etc) and the first operand of a COMPARE,
X   return the mode to be used for the comparison.  For floating-point, CCFPmode
X   should be used. */
X
#define SELECT_CC_MODE(OP,X)	\
(GET_MODE_CLASS(GET_MODE(X)) == MODE_FLOAT? CCFPmode : CCmode)
X
/* We assume that the store-condition-codes instructions store 0 for false
X   and some other value for true.  This is the value stored for true.  */
X
/* #define STORE_FLAG_VALUE 1 */
X
/* Specify the machine mode that pointers have.
X   After generation of rtl, the compiler makes no further distinction
X   between pointers and any other objects of this machine mode.  */
#define Pmode HImode
X
/* A function address in a call instruction
X   is a word address (for indexing purposes)
X   so give the MEM rtx a word's mode.  */
#define FUNCTION_MODE HImode
X
/* Define this if addresses of constant functions
X   shouldn't be put through pseudo regs where they can be cse'd.
X   Desirable on machines where ordinary constants are expensive
X   but a CALL with constant address is cheap.  */
/* #define NO_FUNCTION_CSE */
X
/* Compute the cost of computing a constant rtl expression RTX
X   whose rtx-code is CODE.  The body of this macro is a portion
X   of a switch statement.  If the code is computed here,
X   return it with a return statement.  Otherwise, break from the switch. 
X
X   -1, 0, 1 are cheaper for add, sub ... 
*/
X
#define CONST_COSTS(RTX,CODE,OUTER_CODE) \
X  case CONST_INT:						\
X    if (INTVAL(RTX) == 0					\
X	|| INTVAL(RTX) == -1					\
X	|| INTVAL(RTX) == 1)					\
X      return 0;							\
X  case CONST:							\
X  case LABEL_REF:						\
X  case SYMBOL_REF:						\
X    /* twice as expensive as REG */				\
X    return 2;							\
X  case CONST_DOUBLE:						\
X    /* twice (or 4 times) as expensive as 16 bit */		\
X    return 4;
X
/* cost of moving one register class to another */
#define REGISTER_MOVE_COST(CLASS1, CLASS2) register_move_cost(CLASS1, CLASS2)
X
/* Tell emit-rtl.c how to initialize special values on a per-function base.  */
extern int optimize;
extern struct rtx_def *cc0_reg_rtx;
X
#define CC_STATUS_MDEP rtx
X
#define CC_STATUS_MDEP_INIT (cc_status.mdep = 0)
X
/* Tell final.c how to eliminate redundant test instructions.  */
X
/* Here we define machine-dependent flags and fields in cc_status
X   (see `conditions.h').  */
X
#define CC_IN_FPU 04000 
X
/* Do UPDATE_CC if EXP is a set, used in
X   NOTICE_UPDATE_CC 
X
X   floats only do compare correctly, else nullify ...
X
X   get cc0 out soon ...
*/
X
/* Store in cc_status the expressions
X   that the condition codes will describe
X   after execution of an instruction whose pattern is EXP.
X   Do not alter them if the instruction would not alter the cc's.  */
X
#define NOTICE_UPDATE_CC(EXP, INSN) \
{ if (GET_CODE (EXP) == SET)					\
X    {								\
X      notice_update_cc_on_set(EXP, INSN);			\
X    }								\
X  else if (GET_CODE (EXP) == PARALLEL				\
X	   && GET_CODE (XVECEXP (EXP, 0, 0)) == SET)		\
X    {								\
X      notice_update_cc_on_set(XVECEXP (EXP, 0, 0), INSN);	\
X    }								\
X  else if (GET_CODE (EXP) == CALL)				\
X    { /* all bets are off */ CC_STATUS_INIT; }			\
X  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG	\
X      && cc_status.value2					\
X      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))	\
X    printf ("here!\n", cc_status.value2 = 0);			\
}
X
/* Control the assembler format that we output.  */
X
/* Output at beginning of assembler file.  */
X
#if 0
#define ASM_FILE_START(FILE) \
(								\
fprintf (FILE, "\t.data\n"),					\
fprintf (FILE, "$help$: . = .+8 ; space for tmp moves!\n")	\
/* do we need reg def's R0 = %0 etc ??? */			\
)
#else
#define ASM_FILE_START(FILE)	(0)
#endif
X
X
/* Output to assembler file text saying following lines
X   may contain character constants, extra white space, comments, etc.  */
X
#define ASM_APP_ON ""
X
/* Output to assembler file text saying following lines
X   no longer contain unusual constructs.  */
X
#define ASM_APP_OFF ""
X
/* Output before read-only data.  */
X
#define TEXT_SECTION_ASM_OP "\t.text\n"
X
/* Output before writable data.  */
X
#define DATA_SECTION_ASM_OP "\t.data\n"
X
/* How to refer to registers in assembler output.
X   This sequence is indexed by compiler's hard-register-number (see above).  */
X
#define REGISTER_NAMES \
{"r0", "r1", "r2", "r3", "r4", "fp", "sp", "pc",     \
X "ac0", "ac1", "ac2", "ac3", "ac4", "ac5" }
X
/* How to renumber registers for dbx and gdb.  */
X
#define DBX_REGISTER_NUMBER(REGNO) (REGNO)
X
/* This is how to output the definition of a user-level label named NAME,
X   such as the label on a static function or variable NAME.  */
X
#define ASM_OUTPUT_LABEL(FILE,NAME)	\
X  do { assemble_name (FILE, NAME); fputs (":\n", FILE); } while (0)
X
/* This is how to output a command to make the user-level label named NAME
X   defined for reference from other files.  */
X
#define ASM_GLOBALIZE_LABEL(FILE,NAME)	\
X  do { fputs ("\t.globl ", FILE); assemble_name (FILE, NAME); fputs("\n", FILE); } while (0)
X
/* This is how to output a reference to a user-level label named NAME.
X   `assemble_name' uses this.  */
X
#define ASM_OUTPUT_LABELREF(FILE,NAME)	\
X  fprintf (FILE, "_%s", NAME)
X
/* This is how to output an internal numbered label where
X   PREFIX is the class of label and NUM is the number within the class.  */
X
#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)	\
X  fprintf (FILE, "%s_%d:\n", PREFIX, NUM)
X
/* This is how to store into the string LABEL
X   the symbol_ref name of an internal numbered label where
X   PREFIX is the class of label and NUM is the number within the class.
X   This is suitable for output with `assemble_name'.  */
X
#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)	\
X  sprintf (LABEL, "*%s_%d", PREFIX, NUM)
X
/* This is how to output an assembler line defining a `double' constant.  */
X
#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \
X  fprintf (FILE, "\tdouble %.20e\n", (VALUE))
X
/* This is how to output an assembler line defining a `float' constant.  */
X
#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \
X  fprintf (FILE, "\tfloat %.12e\n", (VALUE))
X
/* This is how to output an assembler line defining an `int' constant.  */
X
#define ASM_OUTPUT_INT(FILE,VALUE)  \
( fprintf (FILE, "\t.word "),			\
X  output_addr_const (FILE, (VALUE)),		\
X  fprintf (FILE, "\n"))
X
/* Likewise for `short' and `char' constants.  */
X
#define ASM_OUTPUT_SHORT(FILE,VALUE)  \
( fprintf (FILE, "\t.word "),			\
X  output_addr_const (FILE, (VALUE)),		\
X  fprintf (FILE, " /*short*/\n"))
X
#define ASM_OUTPUT_CHAR(FILE,VALUE)  \
( fprintf (FILE, "\t.byte "),			\
X  output_addr_const (FILE, (VALUE)),		\
X  fprintf (FILE, " /* char */\n"))
X
/* This is how to output an assembler line for a numeric constant byte.-
X
X   do we really NEED it ? let's output it with a comment and grep the 
X   assembly source ;-)
*/
X
#define ASM_OUTPUT_BYTE(FILE,VALUE)  \
X  fprintf (FILE, "\t.byte 0x%x\n", (VALUE))
X
#define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \
X  output_ascii (FILE, P, SIZE)
X
#define ASM_OUTPUT_ADDR_VEC_PROLOGUE(FILE, MODE, LEN)	\
X  fprintf (FILE, "\t/* HELP! */\n");
X
/* This is how to output an element of a case-vector that is absolute.  */
X
#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \
X  fprintf (FILE, "\t.word L_%d\n", VALUE)
X
/* This is how to output an element of a case-vector that is relative.
X   (the pdp does not use such vectors,
X   but we must define this macro anyway.)  */
X
#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \
X  fprintf (FILE, "\tERROR @L%d-@L%d ! error should not be used\n", VALUE, REL)
X
/* This is how to output an assembler line
X   that says to advance the location counter
X   to a multiple of 2**LOG bytes. 
X
X   who needs this????
*/
X
#define ASM_OUTPUT_ALIGN(FILE,LOG)	\
X  if ((LOG) != 0)			\
X    fprintf (FILE, "\t.align %d\n", 1<<(LOG))
X
#define ASM_OUTPUT_SKIP(FILE,SIZE)  \
X  fprintf (FILE, "\t.=.+ %d\n", (SIZE))
X
/* This says how to output an assembler line
X   to define a global common symbol.  */
X
#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \
( fprintf ((FILE), ".globl "),			\
X  assemble_name ((FILE), (NAME)),		\
X  fprintf ((FILE), "\n"),			\
X  assemble_name ((FILE), (NAME)),		\
X  fprintf ((FILE), ": .=.+ %d\n", (ROUNDED))		\
)
X
/* This says how to output an assembler line
X   to define a local common symbol.  */
X
#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \
( assemble_name ((FILE), (NAME)),				\
X  fprintf ((FILE), ":\t.=.+ %d\n", (ROUNDED)))
X
/* Store in OUTPUT a string (made with alloca) containing
X   an assembler-name for a local static variable named NAME.
X   LABELNO is an integer which is different for each call.  */
X
#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)	\
( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),	\
X  sprintf ((OUTPUT), "%s.%d", (NAME), (LABELNO)))
X
/* Define the parentheses used to group arithmetic operations
X   in assembler code.  */
X
#define ASM_OPEN_PAREN "("
#define ASM_CLOSE_PAREN ")"
X
/* Define results of standard character escape sequences.  */
#define TARGET_BELL 007
#define TARGET_BS 010
#define TARGET_TAB 011
#define TARGET_NEWLINE 012
#define TARGET_VT 013
#define TARGET_FF 014
#define TARGET_CR 015
X
/* Print operand X (an rtx) in assembler syntax to file FILE.
X   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.
X   For `%' followed by punctuation, CODE is the punctuation and X is null.
X
*/
X
X
#define PRINT_OPERAND(FILE, X, CODE)  \
{ if (CODE == '#') fprintf (FILE, "#");					\
X  else if (GET_CODE (X) == REG)						\
X    fprintf (FILE, "%s", reg_names[REGNO (X)]);				\
X  else if (GET_CODE (X) == MEM)						\
X    output_address (XEXP (X, 0));					\
X  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != SImode)	\
X    { union { double d; int i[2]; } u;					\
X      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);	\
X      fprintf (FILE, "#%.20e", u.d); }					\
X  else { putc ('$', FILE); output_addr_const (FILE, X); }}
X
/* Print a memory address as an operand to reference that memory location.  */
X
#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \
X print_operand_address (FILE, ADDR)
X
#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)			\
(							\
X  fprintf (FILE, "\tmov %s, -(sp)\n", reg_names[REGNO])	\
)
X
#define ASM_OUTPUT_REG_POP(FILE,REGNO)                 		\
(                                                       	\
X  fprintf (FILE, "\tmov (sp)+, %s\n", reg_names[REGNO])     	\
)
X
X
#define ASM_IDENTIFY_GCC(FILE)			\
X    fprintf(FILE, "gcc_compiled:\n")
X
#define ASM_OUTPUT_DOUBLE_INT(a,b)	fprintf(a,"%d", b)
X
/* trampoline - how should i do it in separate i+d ? */
#define TRAMPOLINE_SIZE 0
X
#define INITIALIZE_TRAMPOLINE(x,y,z)	\
{					\
abort();				\
}
X
#define TRAMPOLINE_TEMPLATE(FILE)	\
{					\
abort();				\
}
X
/* Some machines may desire to change what optimizations are
X   performed for various optimization levels.   This macro, if
X   defined, is executed once just after the optimization level is
X   determined and before the remainder of the command options have
X   been parsed.  Values set in this macro are used as the default
X   values for the other command line options.
X
X   LEVEL is the optimization level specified; 2 if -O2 is
X   specified, 1 if -O is specified, and 0 if neither is specified.  */
X
#define OPTIMIZATION_OPTIONS(LEVEL)					\
{									\
X  if (LEVEL >= 3)							\
X    {									\
X      flag_inline_functions		= 1;				\
X      flag_omit_frame_pointer		= 1;				\
X      /* flag_unroll_loops			= 1; */			\
X    }									\
}
X
X
/* Provide the costs of a rtl expression.  This is in the body of a
X   switch on CODE. 
X
X   we don't say how expensive SImode is - pretty expensive!!!
X
X   there is something wrong in MULT because MULT is not 
X   as cheap as total = 2 even if we can shift!
X
X   if TARGET_SPACE make mult etc cheap, but not 1, so when 
X   in doubt the faster insn is chosen.
*/
X
#define RTX_COSTS(X,CODE,OUTER_CODE) \
X  case MULT:								\
X    if (TARGET_SPACE)							\
X      total = COSTS_N_INSNS(2);						\
X    else								\
X      total = COSTS_N_INSNS (11);					\
X    break;								\
X  case DIV:								\
X    if (TARGET_SPACE)							\
X      total = COSTS_N_INSNS(2);						\
X    else								\
X      total = COSTS_N_INSNS (25);					\
X    break;								\
X  case MOD:								\
X    if (TARGET_SPACE)							\
X      total = COSTS_N_INSNS(2);						\
X    else								\
X      total = COSTS_N_INSNS (26);					\
X    break;								\
X  case ABS:								\
X    /* equivalent to length, so same for TARGET_SPACE */		\
X    total = COSTS_N_INSNS (3);						\
X    break;								\
X  case ZERO_EXTEND:							\
X    /* only used for: qi->hi */						\
X    total = COSTS_N_INSNS(1);						\
X    break;								\
X  case SIGN_EXTEND:							\
X    if (GET_MODE(X) == HImode)						\
X      	total = COSTS_N_INSNS(1);					\
X    else if (GET_MODE(X) == SImode)					\
X	total = COSTS_N_INSNS(6);					\
X    else								\
X	abort();							\
X    break;								\
X  case LSHIFT:								\
X  case ASHIFT:								\
X  case LSHIFTRT:							\
X  case ASHIFTRT:							\
X    if (TARGET_SPACE)							\
X      total = COSTS_N_INSNS(1);						\
X    else if (GET_MODE(X) ==  QImode)					\
X    {									\
X      if (GET_CODE(XEXP (X,1)) != CONST_INT)				\
X   	  abort();							\
X	total = COSTS_N_INSNS(INTVAL(XEXP (X,1)));			\
X    }									\
X    else if (GET_MODE(X) == HImode)					\
X    {									\
X      if (GET_CODE(XEXP (X,1)) == CONST_INT)				\
X      {									\
X	if (abs (INTVAL (XEXP (X, 1))) == 1)				\
X          total = COSTS_N_INSNS(1);					\
X        else								\
X	  total = COSTS_N_INSNS(2.5 + 0.5 *INTVAL(XEXP(X,1)));		\
X      }									\
X      else /* worst case */						\
X        total = COSTS_N_INSNS (10);					\
X    }									\
X    else if (GET_MODE(X) == SImode)					\
X    {									\
X      if (GET_CODE(XEXP (X,1)) == CONST_INT)				\
X	  total = COSTS_N_INSNS(2.5 + 0.5 *INTVAL(XEXP(X,1)));		\
X      else /* worst case */						\
X        total = COSTS_N_INSNS(18);					\
X    }									\
X    break;
X
X
/* there is no point in avoiding branches on a pdp, 
X   since branches are really cheap - I just want to find out
X   how much difference the BRANCH_COST macro makes in code */
#define BRANCH_COST (TARGET_BRANCH_CHEAP ? 0 : 1)
X
X
#define COMPARE_FLAG_MODE HImode
X
SHAR_EOF
chmod 0600 config/pdp11/pdp11.h ||
echo 'restore of config/pdp11/pdp11.h failed'
Wc_c="`wc -c < 'config/pdp11/pdp11.h'`"
test 45121 -eq "$Wc_c" ||
	echo 'config/pdp11/pdp11.h: original size 45121, current size' "$Wc_c"
fi
# ============= config/pdp11/pdp11.md ==============
if test -f 'config/pdp11/pdp11.md' -a X"$1" != X"-c"; then
	echo 'x - skipping config/pdp11/pdp11.md (File already exists)'
else
echo 'x - extracting config/pdp11/pdp11.md (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'config/pdp11/pdp11.md' &&
;;- Machine description for the pdp11 for GNU C compiler
;; Copyright (C) 1991,1992,1993 Michael K. Gschwind (mike@vlsivie.tuwien.ac.at)
X
;; This file is part of GNU CC.
X
;; GNU CC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 1, or (at your option)
;; any later version.
X
;; GNU CC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
X
;; You should have received a copy of the GNU General Public License
;; along with GNU CC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
X
;; HI is 16 bit
;; QI is 8 bit 
X
;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.
X
;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code
;;- updates for most instructions.
X
;;- Operand classes for the register allocator:
X
;; Compare instructions.
X
;; currently we only support df floats, which saves us quite some
;; hassle switching the FP mode! 
;; we assume that CPU is always in long float mode, and 
;; 16 bit integer mode - currently, the prologue for main does this,
;; but maybe we should just set up a NEW crt0 properly, 
;; -- and what about signal handling code?
;; (we don't even let sf floats in the register file, so
;; we only should have to worry about truncating and widening 
;; when going to memory)
X
;; abort() call by g++ - must define libfunc for cmp_optab
;; and ucmp_optab for mode SImode, because we don't have that!!!
;; - yet since no libfunc is there, we abort ()
X
;; The only thing that remains to be done then is output 
;; the floats in a way the assembler can handle it (and 
;; if you're really into it, use a PDP11 float emulation
;; libary to do floating point constant folding - but 
;; I guess you'll get reasonable results even when not
;; doing this)
;; the last thing to do is fix the UPDATE_CC macro to check
;; for floating point condition codes, and set cc_status
;; properly, also setting the CC_IN_FCCR flag. 
X
;; define attributes
;; currently type is only fpu or arith or unknown, maybe branch later ?
;; default is arith
(define_attr "type" "unknown,arith,fp" (const_string "arith"))
X
;; length default is 1 word each
(define_attr "length" "" (const_int 1))
X
;; a users asm staement 
(define_asm_attributes
X  [(set_attr "type" "unknown")
; all bets are off how long it is - make it 256, forces long jumps 
; whenever jumping around it !!!
X   (set_attr "length" "256")])
X
;; define function units
X
;; arithmetic - values here immediately when next insn issued
;; or does it mean the number of cycles after this insn was issued?
;; how do I say that fpu insns use cpu also? (pre-interaction phase)
X
;(define_function_unit "cpu" 1 1 (eq_attr "type" "arith") 0 0)
;(define_function_unit "fpu" 1 1 (eq_attr "type" "fp") 0 0)
X
;; compare
(define_insn "cmpdf"
X  [(set (cc0)
X	(compare (match_operand:DF 0 "general_operand" "fR,Q,F")
X		 (match_operand:DF 1 "register_operand" "a,a,a")))]
X  "TARGET_FPU"
X  "*
{
X  cc_status.flags = CC_IN_FPU;
X  return \"cmpd %0, %1\;cfcc\";
}"
X  [(set_attr "length" "2,3,6")])
X
;; a bit of brain damage, maybe inline later - 
;; problem is - gcc seems to NEED SImode because 
;; of the cmp weirdness - maybe change gcc to handle this?
X
(define_expand "cmpsi"
X  [(set (reg:SI 0)
X	(match_operand:SI 0 "general_operand" "g"))
X   (set (reg:SI 2)
X	(match_operand:SI 1 "general_operand" "g"))
X   (parallel [(set (cc0)
X		   (compare (reg:SI 0)
X			    (reg:SI 2)))
X	      (clobber (reg:SI 0))])]
X  "0" ;; disable for test
X  "")
X
;; check for next insn for branch code - does this still
;; work in gcc 2.* ?
X
(define_insn ""
X  [(set (cc0)
X	(compare (reg:SI 0)
X		 (reg:SI 2)))
X   (clobber (reg:SI 0))]
X  ""
X  "*
{
X  rtx br_insn = NEXT_INSN (insn);
X  RTX_CODE br_code;
X
X  if (GET_CODE (br_insn) != JUMP_INSN)
X    abort();
X  br_code =  GET_CODE (XEXP (XEXP (PATTERN (br_insn), 1), 0));
X  
X  switch(br_code)
X  {
X    case GEU:
X    case LTU:
X    case GTU:
X    case LEU:
X      
X      return \"jsr pc, ___ucmpsi\;cmp $1,r0\";
X
X    case GE:
X    case LT:
X    case GT:
X    case LE:
X    case EQ:
X    case NE:
X
X      return \"jsr pc, ___cmpsi\;tst r0\";
X
X    default:
X
X      abort();
X  }
}"
X  [(set_attr "length" "4")])
X
X
(define_insn "cmphi"
X  [(set (cc0)
X	(compare (match_operand:HI 0 "general_operand" "rR,rR,Qi,Qi")
X		 (match_operand:HI 1 "general_operand" "rR,Qi,rR,Qi")))]
X  ""
X  "cmp %0,%1"
X  [(set_attr "length" "1,2,2,3")])
X
(define_insn "cmpqi"
X  [(set (cc0)
X	(compare (match_operand:QI 0 "general_operand" "rR,rR,Qi,Qi")
X		 (match_operand:QI 1 "general_operand" "rR,Qi,rR,Qi")))]
X  ""
X  "cmpb %0,%1"
X  [(set_attr "length" "1,2,2,3")])
X			   
X
;; We have to have this because cse can optimize the previous pattern
;; into this one.
X
(define_insn "tstdf"
X  [(set (cc0)
X	(match_operand:DF 0 "general_operand" "fR,Q"))]
X  "TARGET_FPU"
X  "*
{
X  cc_status.flags = CC_IN_FPU;
X  return \"tstd %0\;cfcc\";
}"
X  [(set_attr "length" "2,3")])
X
X
(define_expand "tstsi"
X  [(set (reg:SI 0)
X	(match_operand:SI 0 "general_operand" "g"))
X   (parallel [(set (cc0)
X		   (reg:SI 0))
X	      (clobber (reg:SI 0))])]
X  "0" ;; disable for test
X  "")
X
(define_insn ""
X  [(set (cc0)
X	(reg:SI 0))
X   (clobber (reg:SI 0))]
X  ""
X  "jsr pc, ___tstsi\;tst r0"
X  [(set_attr "length" "3")])
X
X
(define_insn "tsthi"
X  [(set (cc0)
X	(match_operand:HI 0 "general_operand" "rR,Q"))]
X  ""
X  "tst %0"
X  [(set_attr "length" "1,2")])
X
(define_insn "tstqi"
X  [(set (cc0)
X	(match_operand:QI 0 "general_operand" "rR,Q"))]
X  ""
X  "tstb %0"
X  [(set_attr "length" "1,2")])
X
;; sob instruction - we need an assembler which can make this instruction
;; valid under _all_ circumstances!
X
(define_insn ""
X  [(set (pc)
X	(if_then_else
X	 (ne (plus:HI (match_operand:HI 0 "register_operand" "r")
X		      (const_int -1))
X	     (const_int 0))
X	 (label_ref (match_operand 1 "" ""))
X	 (pc)))
X   (set (match_dup 0)
X	(plus:HI (match_dup 0)
X		 (const_int -1)))]
X  "TARGET_40_PLUS"
X  "*
{
X static int labelcount = 0;
X static char buf[1000];
X
X if (get_attr_length (insn) == 1)
X    return \"sob %0, %l1\";
X
X /* emulate sob */
X output_asm_insn (\"dec %0\", operands);
X 
X sprintf (buf, \"bge LONG_SOB%d\", labelcount);
X output_asm_insn (buf, NULL);
X
X output_asm_insn (\"jmp %l1\", operands);
X 
X sprintf (buf, \"LONG_SOB%d:\", labelcount++);
X output_asm_insn (buf, NULL);
X
X return \"\";
}"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						       (pc))
X						(const_int -256))
X					   (ge (minus (match_dup 0)
X						       (pc))
X						(const_int 0)))
X				      (const_int 4)
X				      (const_int 1)))])
X
;; These control RTL generation for conditional jump insns
;; and match them for register allocation.
X
;; problem with too short jump distance! we need an assembler which can 
;; make this legal for all jump distances!
;; e.g. gas!
X
;; these must be changed to check for CC_IN_FCCR if float is to be 
;; enabled
X
(define_insn "beq"
X  [(set (pc)
X	(if_then_else (eq (cc0)
X			  (const_int 0))
X		      (label_ref (match_operand 0 "" ""))
X		      (pc)))]
X  ""
X  "* return output_jump(\"beq\", \"bne\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
X
(define_insn "bne"
X  [(set (pc)
X	(if_then_else (ne (cc0)
X			  (const_int 0))
X		      (label_ref (match_operand 0 "" ""))
X		      (pc)))]
X  ""
X  "* return output_jump(\"bne\", \"beq\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn "bgt"
X  [(set (pc)
X	(if_then_else (gt (cc0)
X			  (const_int 0))
X		      (label_ref (match_operand 0 "" ""))
X		      (pc)))]
X  ""
X  "* return output_jump(\"bgt\", \"ble\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn "bgtu"
X  [(set (pc)
X	(if_then_else (gtu (cc0)
X			   (const_int 0))
X		      (label_ref (match_operand 0 "" ""))
X		      (pc)))]
X  ""
X  "* return output_jump(\"bhi\", \"blos\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn "blt"
X  [(set (pc)
X	(if_then_else (lt (cc0)
X			  (const_int 0))
X		      (label_ref (match_operand 0 "" ""))
X		      (pc)))]
X  ""
X  "* return output_jump(\"blt\", \"bge\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
X
(define_insn "bltu"
X  [(set (pc)
X	(if_then_else (ltu (cc0)
X			   (const_int 0))
X		      (label_ref (match_operand 0 "" ""))
X		      (pc)))]
X  ""
X  "* return output_jump(\"blo\", \"bhos\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn "bge"
X  [(set (pc)
X	(if_then_else (ge (cc0)
X			  (const_int 0))
X		      (label_ref (match_operand 0 "" ""))
X		      (pc)))]
X  ""
X  "* return output_jump(\"bge\", \"blt\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn "bgeu"
X  [(set (pc)
X	(if_then_else (geu (cc0)
X			   (const_int 0))
X		      (label_ref (match_operand 0 "" ""))
X		      (pc)))]
X  ""
X  "* return output_jump(\"bhis\", \"blo\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn "ble"
X  [(set (pc)
X	(if_then_else (le (cc0)
X			  (const_int 0))
X		      (label_ref (match_operand 0 "" ""))
X		      (pc)))]
X  ""
X  "* return output_jump(\"ble\", \"bgt\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn "bleu"
X  [(set (pc)
X	(if_then_else (leu (cc0)
X			   (const_int 0))
X		      (label_ref (match_operand 0 "" ""))
X		      (pc)))]
X  ""
X  "* return output_jump(\"blos\", \"bhi\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
X
;; These match inverted jump insns for register allocation.
X
(define_insn ""
X  [(set (pc)
X	(if_then_else (eq (cc0)
X			  (const_int 0))
X		      (pc)
X		      (label_ref (match_operand 0 "" ""))))]
X  ""
X  "* return output_jump(\"bne\", \"beq\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn ""
X  [(set (pc)
X	(if_then_else (ne (cc0)
X			  (const_int 0))
X		      (pc)
X		      (label_ref (match_operand 0 "" ""))))]
X  ""
X  "* return output_jump(\"beq\", \"bne\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn ""
X  [(set (pc)
X	(if_then_else (gt (cc0)
X			  (const_int 0))
X		      (pc)
X		      (label_ref (match_operand 0 "" ""))))]
X  ""
X  "* return output_jump(\"ble\", \"bgt\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn ""
X  [(set (pc)
X	(if_then_else (gtu (cc0)
X			   (const_int 0))
X		      (pc)
X		      (label_ref (match_operand 0 "" ""))))]
X  ""
X  "* return output_jump(\"blos\", \"bhi\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn ""
X  [(set (pc)
X	(if_then_else (lt (cc0)
X			  (const_int 0))
X		      (pc)
X		      (label_ref (match_operand 0 "" ""))))]
X  ""
X  "* return output_jump(\"bge\", \"blt\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn ""
X  [(set (pc)
X	(if_then_else (ltu (cc0)
X			   (const_int 0))
X		      (pc)
X		      (label_ref (match_operand 0 "" ""))))]
X  ""
X  "* return output_jump(\"bhos\", \"blo\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn ""
X  [(set (pc)
X	(if_then_else (ge (cc0)
X			  (const_int 0))
X		      (pc)
X		      (label_ref (match_operand 0 "" ""))))]
X  ""  
X  "* return output_jump(\"blt\", \"bge\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn ""
X  [(set (pc)
X	(if_then_else (geu (cc0)
X			   (const_int 0))
X		      (pc)
X		      (label_ref (match_operand 0 "" ""))))]
X  ""
X  "* return output_jump(\"blo\", \"bhos\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn ""
X  [(set (pc)
X	(if_then_else (le (cc0)
X			  (const_int 0))
X		      (pc)
X		      (label_ref (match_operand 0 "" ""))))]
X  ""
X  "* return output_jump(\"bgt\", \"ble\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
(define_insn ""
X  [(set (pc)
X	(if_then_else (leu (cc0)
X			   (const_int 0))
X		      (pc)
X		      (label_ref (match_operand 0 "" ""))))]
X  ""
X  "* return output_jump(\"bhi\", \"blos\", get_attr_length(insn));"
X  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
X						      (pc))
X					       (const_int -128))
X					   (ge (minus (match_dup 0)
X						      (pc))
X					       (const_int 128)))
X				      (const_int 3)
X				      (const_int 1)))])
X
;; Move instructions
X
(define_insn "movdi"
X  [(set (match_operand:DI 0 "general_operand" "=g")
X	(match_operand:DI 1 "general_operand" "g"))]
X  ""
X  "* return output_move_quad (operands);"
;; what's the mose expensive code - say twice movsi = 16
X  [(set_attr "length" "16")])
X
(define_insn "movsi"
X  [(set (match_operand:SI 0 "general_operand" "=r,r,r,rm,m")
X	(match_operand:SI 1 "general_operand" "rN,IJ,K,m,r"))]
X  ""
X  "* return output_move_double (operands);"
;; what's the most expensive code ? - I think 8!
;; we could split it up and make several sub-cases...
X  [(set_attr "length" "2,3,4,8,8")])
X
(define_insn "movhi"
X  [(set (match_operand:HI 0 "general_operand" "=rR,rR,Q,Q")
X	(match_operand:HI 1 "general_operand" "rRN,Qi,rRN,Qi"))]
X  ""
X  "*
{
X  if (operands[1] == const0_rtx)
X    return \"clr %0\";
X
X  return \"mov %1, %0\";
}"
X  [(set_attr "length" "1,2,2,3")])
X
(define_insn "movqi"
X  [(set (match_operand:QI 0 "general_operand" "=rR,rR,Q,Q")
X	(match_operand:QI 1 "general_operand" "rRN,Qi,rRN,Qi"))]
X  ""
X  "*
{
X  if (operands[1] == const0_rtx)
X    return \"clrb %0\";
X
X  return \"movb %1, %0\";
}"
X  [(set_attr "length" "1,2,2,3")])
X
;; do we have to supply all these moves? e.g. to 
;; NO_LOAD_FPU_REGs ? 
(define_insn "movdf"
X  [(set (match_operand:DF 0 "general_operand" "=f,R,f,Q,f,m")
X        (match_operand:DF 1 "general_operand" "fR,f,Q,f,F,m"))]
X  ""
X  "* return output_move_quad (operands);"
;; just a guess..
X  [(set_attr "length" "1,1,2,2,5,16")])
X
(define_insn "movsf"
X  [(set (match_operand:SF 0 "general_operand" "=g,r,g")
X        (match_operand:SF 1 "general_operand" "r,rmF,g"))]
X  "TARGET_FPU"
X  "* return output_move_double (operands);"
X  [(set_attr "length" "8,8,8")])
X
;; maybe fiddle a bit with move_ratio, then 
;; let contraints only accept a register ...
X
(define_expand "movstrhi"
X  [(parallel [(set (mem:BLK (match_operand:BLK 0 "general_operand" "=g,g"))
X		   (mem:BLK (match_operand:BLK 1 "general_operand" "g,g")))
X	      (use (match_operand:HI 2 "arith_operand" "n,&mr"))
X	      (use (match_operand:HI 3 "immediate_operand" "i,i"))
X	      (clobber (match_scratch:HI 4 "=&r,X"))
X	      (clobber (match_dup 0))
X	      (clobber (match_dup 1))
X	      (clobber (match_dup 2))])]
X  "(TARGET_BCOPY_BUILTIN)"
X  "
{
X  operands[0] = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));
X  operands[1] = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));
X  operands[2] = force_not_mem (operands[2]);
}")
X
X
(define_insn "" ; "movstrhi"
X  [(set (mem:BLK (match_operand:HI 0 "general_operand" "=r,r"))
X	(mem:BLK (match_operand:HI 1 "general_operand" "r,r")))
X   (use (match_operand:HI 2 "arith_operand" "n,&r"))
X   (use (match_operand:HI 3 "immediate_operand" "i,i"))
X   (clobber (match_scratch:HI 4 "=&r,X"))
X   (clobber (match_dup 0))
X   (clobber (match_dup 1))
X   (clobber (match_dup 2))]
X  "(TARGET_BCOPY_BUILTIN)"
X  "* return output_block_move (operands);"
;;; just a guess
X  [(set_attr "length" "40")])
X   
X
X
;;- truncation instructions
X
(define_insn  "truncdfsf2"
X  [(set (match_operand:SF 0 "memory_operand" "=R,Q")
X	(float_truncate:SF (match_operand:DF 1 "register_operand" "a,a")))]
X  "TARGET_FPU"
X  "stcdf %1, %0"
X  [(set_attr "length" "1,2")])
X
(define_expand "truncsihi2"
X  [(set (match_operand:HI 0 "general_operand" "=g")
X	(subreg:HI 
X	  (match_operand:SI 1 "general_operand" "or")
X          0))]
X  ""
X  "")
X
X
;;- zero extension instructions
X
(define_insn "zero_extendqihi2"
X  [(set (match_operand:HI 0 "general_operand" "=r")
X	(zero_extend:HI (match_operand:QI 1 "general_operand" "0")))]
X  ""
X  "bic $(256*255), %0"
X  [(set_attr "length" "2")])
X			 
(define_expand "zero_extendhisi2"
X  [(set (subreg:HI 
X          (match_dup 0)
X          1)
X        (match_operand:HI 1 "register_operand" "r"))
X   (set (subreg:HI 
X          (match_operand:SI 0 "register_operand" "=r")
X          0)
X        (const_int 0))]
X  ""
X  "/* operands[1] = make_safe_from (operands[1], operands[0]); */")
X
X
;;- sign extension instructions
X
(define_insn "extendsfdf2"
X  [(set (match_operand:DF 0 "register_operand" "=a,a")
X	(float_extend:SF (match_operand:SF 1 "memory_operand" "R,Q")))]
X  "TARGET_FPU"
X  "ldcfd %1, %0"
X  [(set_attr "length" "1,2")])
X
;; does movb sign extend in register-to-register move?
(define_insn "extendqihi2"
X  [(set (match_operand:HI 0 "register_operand" "=r,r")
X	(sign_extend:HI (match_operand:QI 1 "general_operand" "rR,Q")))]
X  ""
X  "movb %1, %0"
X  [(set_attr "length" "1,2")])
X
(define_insn "extendqisi2"
X  [(set (match_operand:SI 0 "register_operand" "=r,r")
X	(sign_extend:SI (match_operand:QI 1 "general_operand" "rR,Q")))]
X  "TARGET_40_PLUS"
X  "*
{
X  rtx latehalf[2];
X
X  /* make register pair available */
X  latehalf[0] = operands[0];
X  operands[0] = gen_rtx(REG, HImode, REGNO (operands[0])+1);
X    
X  output_asm_insn(\"movb %1, %0\", operands);
X  output_asm_insn(\"sxt %0\", latehalf);
X    
X  return \"\";
}"
X  [(set_attr "length" "2,3")])
X
;; maybe we have to use define_expand to say that we have the instruction,
;; unconditionally, and then match dependent on CPU type:
X
(define_expand "extendhisi2"
X  [(set (match_operand:SI 0 "general_operand" "=g")
X	(sign_extend:SI (match_operand:HI 1 "general_operand" "g")))]
X  ""
X  "")
X  
(define_insn "" ; "extendhisi2"
X  [(set (match_operand:SI 0 "general_operand" "=o,<,r")
X	(sign_extend:SI (match_operand:HI 1 "general_operand" "g,g,g")))]
X  "TARGET_40_PLUS"
X  "*
{
X  rtx latehalf[2];
X
X  /* we don't want to mess with auto increment */
X  
X  switch(which_alternative)
X  {
X    case 0:
X
X      latehalf[0] = operands[0];
X      operands[0] = adj_offsettable_operand(operands[0], 2);
X  
X      output_asm_insn(\"mov %1, %0\", operands);
X      output_asm_insn(\"sxt %0\", latehalf);
X
X      return \"\";
X
X    case 1:
X
X      /* - auto-decrement - right direction ;-) */
X      output_asm_insn(\"mov %1, %0\", operands);
X      output_asm_insn(\"sxt %0\", operands);
X
X      return \"\";
X
X    case 2:
X
X      /* make register pair available */
X      latehalf[0] = operands[0];
X      operands[0] = gen_rtx(REG, HImode, REGNO (operands[0])+1);
X
X      output_asm_insn(\"mov %1, %0\", operands);
X      output_asm_insn(\"sxt %0\", latehalf);
X
X      return \"\";
X
X    default:
X
X      abort();
X  }
}"
X  [(set_attr "length" "5,3,3")])
X
X
(define_insn ""
X  [(set (match_operand:SI 0 "register_operand" "=r")
X	(sign_extend:SI (match_operand:HI 1 "general_operand" "0")))]
X  "(! TARGET_40_PLUS)"
X  "*
{
X  static count = 0;
X  char buf[100];
X  rtx lateoperands[2];
X
X  lateoperands[0] = operands[0];
X  operands[0] = gen_rtx(REG, HImode, REGNO (operands[0])+1);
X
X  output_asm_insn(\"tst %0\", operands);
X  sprintf(buf, \"bge extendhisi%d\", count);
X  output_asm_insn(buf, NULL);
X  output_asm_insn(\"mov -1, %0\", lateoperands);
X  sprintf(buf, \"bne extendhisi%d\", count+1);
X  output_asm_insn(buf, NULL);
X  sprintf(buf, \"\\nextendhisi%d:\", count);
X  output_asm_insn(buf, NULL);
X  output_asm_insn(\"clr %0\", lateoperands);
X  sprintf(buf, \"\\nextendhisi%d:\", count+1);
X  output_asm_insn(buf, NULL);
X
X  count += 2;
X
X  return \"\";
}"
X  [(set_attr "length" "6")])
X
;; make float to int and vice versa 
;; using the cc_status.flag field we coulf probably cut down
;; on seti and setl
;; assume that we are normally in double and integer mode -
;; what do pdp library routines do to fpu mode ?
X
(define_insn "floatsidf2"
X  [(set (match_operand:DF 0 "register_operand" "=a,a")
X	(float:DF (match_operand:SI 1 "memory_operand" "R,Q")))]
X  "TARGET_FPU"
X  "setl\;ldcld %1, %0\;seti"
X  [(set_attr "length" "3,4")])
X
(define_insn "floathidf2"
X  [(set (match_operand:DF 0 "register_operand" "=a,a")
X	(float:DF (match_operand:HI 1 "general_operand" "rR,Qi")))]
X  "TARGET_FPU"
X  "ldcid %1, %0"
X  [(set_attr "length" "1,2")])
X	
;; cut float to int
(define_insn "fix_truncdfsi2"
X  [(set (match_operand:SI 0 "memory_operand" "=R,Q")
X	(fix:SI (fix:DF (match_operand:DF 1 "register_operand" "a,a"))))]
X  "TARGET_FPU"
X  "setl\;stcdl %1, %0\;seti"
X  [(set_attr "length" "3,4")])
X
(define_insn "fix_truncdfhi2"
X  [(set (match_operand:HI 0 "general_operand" "=rR,Q")
X	(fix:HI (fix:DF (match_operand:DF 1 "register_operand" "a,a"))))]
X  "TARGET_FPU"
X  "stcdi %1, %0"
X  [(set_attr "length" "1,2")])
X
X
;;- arithmetic instructions
;;- add instructions
X
(define_insn "adddf3"
X  [(set (match_operand:DF 0 "register_operand" "=a,a,a")
X	(plus:DF (match_operand:DF 1 "register_operand" "%0,0,0")
X		 (match_operand:DF 2 "general_operand" "fR,Q,F")))]
X  "TARGET_FPU"
X  "addd %2, %0"
X  [(set_attr "length" "1,2,5")])
X
(define_insn "addsi3"
X  [(set (match_operand:SI 0 "general_operand" "=r,r,o,o,r,r,r,o,o,o")
X	(plus:SI (match_operand:SI 1 "general_operand" "%0,0,0,0,0,0,0,0,0,0")
X		 (match_operand:SI 2 "general_operand" "r,o,r,o,I,J,K,I,J,K")))]
X  ""
X  "*
{ /* Here we trust that operands don't overlap 
X
X     or is lateoperands the low word?? - looks like it! */
X
X  unsigned int i;
X  rtx lateoperands[3];
X  
X  lateoperands[0] = operands[0];
X
X  if (REG_P (operands[0]))
X    operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);
X  else
X    operands[0] = adj_offsettable_operand (operands[0], 2);
X  
X  if (! CONSTANT_P(operands[2]))
X  {
X    lateoperands[2] = operands[2];
X
X    if (REG_P (operands[2]))
X      operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);
X    else
X      operands[2] = adj_offsettable_operand(operands[2], 2);
X
X    output_asm_insn (\"add %2, %0\", operands);
X    output_asm_insn (\"adc %0\", lateoperands);
X    output_asm_insn (\"add %2, %0\", lateoperands);
X    return \"\";
X  }
X
X  lateoperands[2] = gen_rtx(CONST_INT, VOIDmode, (INTVAL(operands[2]) >> 16) & 0xffff);
X  operands[2] = gen_rtx(CONST_INT, VOIDmode, INTVAL(operands[2]) & 0xffff);
X  
X  if (INTVAL(operands[2]))
X  { 
X    output_asm_insn (\"add %2, %0\", operands);
X    output_asm_insn (\"adc %0\", lateoperands);
X  }
X
X  if (INTVAL(lateoperands[2]))
X    output_asm_insn (\"add %2, %0\", lateoperands);
X
X  return \"\";
}"
X  [(set_attr "length" "3,5,6,8,3,1,5,5,3,8")])
X
(define_insn "addhi3"
X  [(set (match_operand:HI 0 "general_operand" "=rR,rR,Q,Q")
X	(plus:HI (match_operand:HI 1 "general_operand" "%0,0,0,0")
X		 (match_operand:HI 2 "general_operand" "rRLM,Qi,rRLM,Qi")))]
X  ""
X  "*
{
X  if (GET_CODE (operands[2]) == CONST_INT)
X    if (INTVAL(operands[2]) == 1)
X      return \"inc %0\";
X    else if (INTVAL(operands[2]) == -1)
X      return \"dec %0\";
X
X  return \"add %2, %0\";
}"
X  [(set_attr "length" "1,2,2,3")])
X
(define_insn "addqi3"
X  [(set (match_operand:QI 0 "general_operand" "=rR,rR,Q,Q")
X	(plus:QI (match_operand:QI 1 "general_operand" "%0,0,0,0")
X		 (match_operand:QI 2 "general_operand" "rRLM,Qi,rRLM,Qi")))]
X  ""
X  "*
{
X  if (GET_CODE (operands[2]) == CONST_INT)
X    if (INTVAL(operands[2]) == 1)
X      return \"incb %0\";
X    else if (INTVAL(operands[2]) == -1)
X      return \"decb %0\";
X
X  return \"addb %2, %0\";
}"
X  [(set_attr "length" "1,2,2,3")])
X
X
;;- subtract instructions
;; we don't have to care for constant second 
;; args, since they are cononical plus:xx now!
;; also for minus:DF ??
X
(define_insn "subdf3"
X  [(set (match_operand:DF 0 "register_operand" "=a,a")
X	(minus:DF (match_operand:DF 1 "register_operand" "0,0")
X		  (match_operand:DF 2 "general_operand" "fR,Q")))]
X  "TARGET_FPU"
X  "subd %2, %0"
X  [(set_attr "length" "1,2")])
X
(define_insn "subsi3"
X  [(set (match_operand:SI 0 "general_operand" "=r,r,o,o")
X        (minus:SI (match_operand:SI 1 "general_operand" "0,0,0,0")
X                  (match_operand:SI 2 "general_operand" "r,o,r,o")))]
X  ""
X  "*
{ /* Here we trust that operands don't overlap 
X
X     or is lateoperands the low word?? - looks like it! */
X
X  unsigned int i;
X  rtx lateoperands[3];
X  
X  lateoperands[0] = operands[0];
X
X  if (REG_P (operands[0]))
X    operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);
X  else
X    operands[0] = adj_offsettable_operand (operands[0], 2);
X  
X  lateoperands[2] = operands[2];
X
X  if (REG_P (operands[2]))
X    operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);
X  else
X    operands[2] = adj_offsettable_operand(operands[2], 2);
X
X  output_asm_insn (\"sub %2, %0\", operands);
X  output_asm_insn (\"sbc %0\", lateoperands);
X  output_asm_insn (\"sub %2, %0\", lateoperands);
X  return \"\";
}"
;; offsetable memory addresses always are expensive!!!
X  [(set_attr "length" "3,5,6,8")])
X
(define_insn "subhi3"
X  [(set (match_operand:HI 0 "general_operand" "=rR,rR,Q,Q")
X	(minus:HI (match_operand:HI 1 "general_operand" "0,0,0,0")
X		  (match_operand:HI 2 "general_operand" "rR,Qi,rR,Qi")))]
X  ""
X  "*
{
X  if (GET_CODE (operands[2]) == CONST_INT)
X    abort();
X
X  return \"sub %2, %0\";
}"
X  [(set_attr "length" "1,2,2,3")])
X
(define_insn "subqi3"
X  [(set (match_operand:QI 0 "general_operand" "=rR,rR,Q,Q")
X	(minus:QI (match_operand:QI 1 "general_operand" "0,0,0,0")
X		  (match_operand:QI 2 "general_operand" "rR,Qi,rR,Qi")))]
X  ""
X  "*
{
X  if (GET_CODE (operands[2]) == CONST_INT)
X    abort();
X
X  return \"subb %2, %0\";
}"
X  [(set_attr "length" "1,2,2,3")])
X
;;;;- and instructions
;; Bit-and on the pdp (like on the vax) is done with a clear-bits insn.
(define_expand "andsi3"
X  [(set (match_operand:SI 0 "general_operand" "=g")
X	(and:SI (match_operand:SI 1 "general_operand" "0")
X		(not:SI (match_operand:SI 2 "general_operand" "g"))))]
X  ""
X  "
{
X  extern rtx expand_unop ();
X  if (GET_CODE (operands[2]) == CONST_INT)
X    operands[2] = gen_rtx (CONST_INT, VOIDmode, ~INTVAL (operands[2]));
X  else
X    operands[2] = expand_unop (SImode, one_cmpl_optab, operands[2], 0, 1);
}")
X
(define_expand "andhi3"
X  [(set (match_operand:HI 0 "general_operand" "=g")
X	(and:HI (match_operand:HI 1 "general_operand" "0")
X		(not:HI (match_operand:HI 2 "general_operand" "g"))))]
X  ""
X  "
{
X  extern rtx expand_unop ();
X  if (GET_CODE (operands[2]) == CONST_INT)
X    operands[2] = gen_rtx (CONST_INT, VOIDmode, ~INTVAL (operands[2]));
X  else
X    operands[2] = expand_unop (HImode, one_cmpl_optab, operands[2], 0, 1);
}")
X
(define_expand "andqi3"
X  [(set (match_operand:QI 0 "general_operand" "=g")
X	(and:QI (match_operand:QI 1 "general_operand" "0")
X		(not:QI (match_operand:QI 2 "general_operand" "g"))))]
X  ""
X  "
{
X  extern rtx expand_unop ();
X  rtx op = operands[2];
X  if (GET_CODE (op) == CONST_INT)
X    operands[2] = gen_rtx (CONST_INT, VOIDmode,
X			   ((1 << 8) - 1) & ~INTVAL (op));
X  else
X    operands[2] = expand_unop (QImode, one_cmpl_optab, op, 0, 1);
}")
X
(define_insn "andcbsi3"
X  [(set (match_operand:SI 0 "general_operand" "=r,r,o,o,r,r,r,o,o,o")
X        (and:SI (match_operand:SI 1 "general_operand" "%0,0,0,0,0,0,0,0,0,0")
X                (not:SI (match_operand:SI 2 "general_operand" "r,o,r,o,I,J,K,I,J,K"))))]
X  ""
X  "*
{ /* Here we trust that operands don't overlap 
X
X     or is lateoperands the low word?? - looks like it! */
X
X  unsigned int i;
X  rtx lateoperands[3];
X  
X  lateoperands[0] = operands[0];
X
X  if (REG_P (operands[0]))
X    operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);
X  else
X    operands[0] = adj_offsettable_operand (operands[0], 2);
X  
X  if (! CONSTANT_P(operands[2]))
X  {
X    lateoperands[2] = operands[2];
X
X    if (REG_P (operands[2]))
X      operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);
X    else
X      operands[2] = adj_offsettable_operand(operands[2], 2);
X
X    output_asm_insn (\"bic %2, %0\", operands);
X    output_asm_insn (\"bic %2, %0\", lateoperands);
X    return \"\";
X  }
X
X  lateoperands[2] = gen_rtx(CONST_INT, VOIDmode, (INTVAL(operands[2]) >> 16) & 0xffff);
X  operands[2] = gen_rtx(CONST_INT, VOIDmode, INTVAL(operands[2]) & 0xffff);
X  
X  /* these have different lengths, so we should have 
X     different constraints! */
X  if (INTVAL(operands[2]))
X    output_asm_insn (\"bic %2, %0\", operands);
X
X  if (INTVAL(lateoperands[2]))
X    output_asm_insn (\"bic %2, %0\", lateoperands);
X
X  return \"\";
}"
X  [(set_attr "length" "2,4,4,6,2,2,4,3,3,6")])
X
(define_insn "andcbhi3"
X  [(set (match_operand:HI 0 "general_operand" "=rR,rR,Q,Q")
X	(and:HI (match_operand:HI 1 "general_operand" "0,0,0,0")
X		(not:HI (match_operand:HI 2 "general_operand" "rR,Qi,rR,Qi"))))]
X  ""
X  "bic %2, %0"
X  [(set_attr "length" "1,2,2,3")])
X
(define_insn "andcbqi3"
X  [(set (match_operand:QI 0 "general_operand" "=rR,rR,Q,Q")
X	(and:QI (match_operand:QI 1 "general_operand" "0,0,0,0")
X		(not:QI (match_operand:QI 2 "general_operand" "rR,Qi,rR,Qi"))))]
X  ""
X  "bicb %2, %0"
X  [(set_attr "length" "1,2,2,3")])
X
;;- Bit set (inclusive or) instructions
(define_insn "iorsi3"
X  [(set (match_operand:SI 0 "general_operand" "=r,r,o,o,r,r,r,o,o,o")
X        (ior:SI (match_operand:SI 1 "general_operand" "%0,0,0,0,0,0,0,0,0,0")
X                  (match_operand:SI 2 "general_operand" "r,o,r,o,I,J,K,I,J,K")))]
X  ""
X  "*
{ /* Here we trust that operands don't overlap 
X
X     or is lateoperands the low word?? - looks like it! */
X
X  unsigned int i;
X  rtx lateoperands[3];
X  
X  lateoperands[0] = operands[0];
X
X  if (REG_P (operands[0]))
X    operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);
X  else
X    operands[0] = adj_offsettable_operand (operands[0], 2);
X  
X  if (! CONSTANT_P(operands[2]))
X  {
X    lateoperands[2] = operands[2];
X
X    if (REG_P (operands[2]))
X      operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);
X    else
X      operands[2] = adj_offsettable_operand(operands[2], 2);
X
X    output_asm_insn (\"bis %2, %0\", operands);
X    output_asm_insn (\"bis %2, %0\", lateoperands);
X    return \"\";
X  }
X
X  lateoperands[2] = gen_rtx(CONST_INT, VOIDmode, (INTVAL(operands[2]) >> 16) & 0xffff);
X  operands[2] = gen_rtx(CONST_INT, VOIDmode, INTVAL(operands[2]) & 0xffff);
X  
X  /* these have different lengths, so we should have 
X     different constraints! */
X  if (INTVAL(operands[2]))
X    output_asm_insn (\"bis %2, %0\", operands);
X
X  if (INTVAL(lateoperands[2]))
X    output_asm_insn (\"bis %2, %0\", lateoperands);
X
X  return \"\";
}"
X  [(set_attr "length" "2,4,4,6,2,2,4,3,3,6")])
X
(define_insn "iorhi3"
X  [(set (match_operand:HI 0 "general_operand" "=rR,rR,Q,Q")
X	(ior:HI (match_operand:HI 1 "general_operand" "%0,0,0,0")
X		(match_operand:HI 2 "general_operand" "rR,Qi,rR,Qi")))]
X  ""
X  "bis %2, %0"
X  [(set_attr "length" "1,2,2,3")])
X
(define_insn "iorqi3"
X  [(set (match_operand:QI 0 "general_operand" "=rR,rR,Q,Q")
X	(ior:QI (match_operand:QI 1 "general_operand" "%0,0,0,0")
X		(match_operand:QI 2 "general_operand" "rR,Qi,rR,Qi")))]
X  ""
X  "bisb %2, %0")
X
;;- xor instructions
(define_insn "xorsi3"
X  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
X        (xor:SI (match_operand:SI 1 "register_operand" "%0,0,0,0")
X                  (match_operand:SI 2 "arith_operand" "r,I,J,K")))]
X  "TARGET_40_PLUS"
X  "*
{ /* Here we trust that operands don't overlap */
X
X  unsigned int i;
X  rtx lateoperands[3];
X
X  lateoperands[0] = operands[0];
X  operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);
X
X  if (REG_P(operands[2]))
X  {
X    lateoperands[2] = operands[2];
X    operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);
X    
X    output_asm_insn (\"xor %2, %0\", operands);
X    output_asm_insn (\"xor %2, %0\", lateoperands);
X
X    return \"\";
X  }
X
X  lateoperands[2] = gen_rtx(CONST_INT, VOIDmode, (INTVAL(operands[2]) >> 16) & 0xffff);
X  operands[2] = gen_rtx(CONST_INT, VOIDmode, INTVAL(operands[2]) & 0xffff);
X  
X  if (INTVAL(operands[2]))
X    output_asm_insn (\"xor %2, %0\", operands);
X
X  if (INTVAL(lateoperands[2]))
X    output_asm_insn (\"xor %2, %0\", lateoperands);
X
X  return \"\";
}"
X  [(set_attr "length" "2,1,1,2")])
X
(define_insn "xorhi3"
X  [(set (match_operand:HI 0 "general_operand" "=rR,Q")
X	(xor:HI (match_operand:HI 1 "general_operand" "%0,0")
X		(match_operand:HI 2 "register_operand" "r,r")))]
X  "TARGET_40_PLUS"
X  "xor %2, %0"
X  [(set_attr "length" "1,2")])
X
;;- one complement instructions
X
(define_insn "one_cmplhi2"
X  [(set (match_operand:HI 0 "general_operand" "=rR,Q")
X        (not:HI (match_operand:HI 1 "general_operand" "0,0")))]
X  ""
X  "com %0"
X  [(set_attr "length" "1,2")])
X
(define_insn "one_cmplqi2"
X  [(set (match_operand:QI 0 "general_operand" "=rR,Q")
X        (not:QI (match_operand:QI 1 "general_operand" "0,0")))]
X  ""
X  "comb %0"
X  [(set_attr "length" "1,2")])
X
;;- arithmetic shift instructions
(define_insn "ashlsi3"
X  [(set (match_operand:SI 0 "register_operand" "=r,r")
X	(ashift:SI (match_operand:SI 1 "register_operand" "0,0")
X		   (match_operand:HI 2 "general_operand" "rR,Qi")))]
X  "TARGET_45"
X  "ashc %2,%0"
X  [(set_attr "length" "1,2")])
X
;; Arithmetic right shift on the pdp works by negating the shift count.
(define_expand "ashrsi3"
X  [(set (match_operand:SI 0 "register_operand" "=r")
X	(ashift:SI (match_operand:SI 1 "register_operand" "0")
X		   (match_operand:HI 2 "general_operand" "g")))]
X  ""
X  "
{
X  operands[2] = negate_rtx (HImode, operands[2]);
}")
X
;; define asl aslb asr asrb - ashc missing!
X
;; asl 
(define_insn "" 
X  [(set (match_operand:HI 0 "general_operand" "=rR,Q")
X	(ashift:HI (match_operand:HI 1 "general_operand" "0,0")
X		   (const_int 1)))]
X  ""
X  "asl %0"
X  [(set_attr "length" "1,2")])
X
;; and another possibility for asr is << -1
;; might cause problems since -1 can also be encoded as 65535!
;; not in gcc2 ??? 
X
;; asr
(define_insn "" 
X  [(set (match_operand:HI 0 "general_operand" "=rR,Q")
X	(ashift:HI (match_operand:HI 1 "general_operand" "0,0")
X		   (const_int -1)))]
X  ""
X  "asr %0"
X  [(set_attr "length" "1,2")])
X
;; shift is by arbitrary count is expensive, 
;; shift by one cheap - so let's do that, if
;; space doesn't matter
(define_insn "" 
X  [(set (match_operand:HI 0 "general_operand" "=r")
X	(ashift:HI (match_operand:HI 1 "general_operand" "0")
X		   (match_operand:HI 2 "expand_shift_operand" "O")))]
X  "TARGET_TIME"
X  "*
{
X  register int i;
X
X  for (i = 1; i <= abs(INTVAL(operands[2])); i++)
X    if (INTVAL(operands[2]) < 0)
X      output_asm_insn(\"asr %0\", operands);
X    else
X      output_asm_insn(\"asl %0\", operands);
X      
X  return \"\";
}"
;; longest is 4
X  [(set (attr "length") (const_int 4))])
X
;; aslb
(define_insn "" 
X  [(set (match_operand:QI 0 "general_operand" "=r,o")
X	(ashift:QI (match_operand:QI 1 "general_operand" "0,0")
X		   (match_operand:HI 2 "const_immediate_operand" "n,n")))]
X  ""
X  "*
{ /* allowing predec or post_inc is possible, but hairy! */
X  int i, cnt;
X
X  cnt = INTVAL(operands[2]) & 0x0007;
X
X  for (i=0 ; i < cnt ; i++)
X       output_asm_insn(\"aslb %0\", operands);
X
X  return \"\";
}"
;; set attribute length ( match_dup 2 & 7 ) *(1 or 2) !!!
X  [(set_attr_alternative "length" 
X                         [(const_int 7)
X                          (const_int 14)])])
X
;;; asr 
;(define_insn "" 
;  [(set (match_operand:HI 0 "general_operand" "=rR,Q")
;	(ashiftrt:HI (match_operand:HI 1 "general_operand" "0,0")
;		     (const_int 1)))]
;  ""
;  "asr %0"
;  [(set_attr "length" "1,2")])
X
;; asrb
(define_insn "" 
X  [(set (match_operand:QI 0 "general_operand" "=r,o")
X	(ashiftrt:QI (match_operand:QI 1 "general_operand" "0,0")
X		     (match_operand:HI 2 "const_immediate_operand" "n,n")))]
X  ""
X  "*
{ /* allowing predec or post_inc is possible, but hairy! */
X  int i, cnt;
X
X  cnt = INTVAL(operands[2]) & 0x0007;
X
X  for (i=0 ; i < cnt ; i++)
X       output_asm_insn(\"asrb %0\", operands);
X
X  return \"\";
}"
X  [(set_attr_alternative "length" 
X                         [(const_int 7)
X                          (const_int 14)])])
X
;; the following is illegal - too complex!!! - just say 14 !!!
;  [(set (attr "length") (plus (and (match_dup 2)
;                                   (const_int 7))
;                              (and (match_dup 2)
;                                   (const_int 7))))])
X
X
X
;; can we get +-1 in the next pattern? should 
;; have been caught by previous patterns!
X
(define_insn "ashlhi3"
X  [(set (match_operand:HI 0 "register_operand" "=r,r")
X	(ashift:HI (match_operand:HI 1 "register_operand" "0,0")
X		   (match_operand:HI 2 "general_operand" "rR,Qi")))]
X  ""
X  "*
{
X  if (GET_CODE(operands[2]) == CONST_INT)
X    if (INTVAL(operands[2]) == 1)
X      return \"asl %0\";
X    else if (INTVAL(operands[2]) == -1)
X      return \"asr %0\";
X
X  return \"ash %2,%0\";
}"
X  [(set_attr "length" "1,2")])
X
;; Arithmetic right shift on the pdp works by negating the shift count.
(define_expand "ashrhi3"
X  [(set (match_operand:HI 0 "register_operand" "=r")
X	(ashift:HI (match_operand:HI 1 "register_operand" "0")
X		   (match_operand:HI 2 "general_operand" "g")))]
X  ""
X  "
{
X  operands[2] = negate_rtx (HImode, operands[2]);
}")
X
;;;;- logical shift instructions
;;(define_insn "lshrsi3"
;;  [(set (match_operand:HI 0 "register_operand" "=r")
;;	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
;;		     (match_operand:HI 2 "arith_operand" "rI")))]
;;  ""
;;  "srl %0,%2")
X
;; absolute 
X
(define_insn "absdf2"
X  [(set (match_operand:DF 0 "general_operand" "=fR,Q")
X	(abs:DF (match_operand:DF 1 "general_operand" "0,0")))]
X  "TARGET_FPU"
X  "absd %0"
X  [(set_attr "length" "1,2")])
X
(define_insn "abshi2"
X  [(set (match_operand:HI 0 "general_operand" "=r,o")
X	(abs:HI (match_operand:HI 1 "general_operand" "0,0")))]
X  "TARGET_ABSHI_BUILTIN"
X  "*
{
X  static count = 0;
X  char buf[200];
X	
X  output_asm_insn(\"tst %0\", operands);
X  sprintf(buf, \"bge abshi%d\", count);
X  output_asm_insn(buf, NULL);
X  output_asm_insn(\"neg %0\", operands);
X  sprintf(buf, \"\\nabshi%d:\", count++);
X  output_asm_insn(buf, NULL);
X
X  return \"\";
}"
X  [(set_attr "length" "3,5")])
X
X
;; define expand abshi - is much better !!! - but
;; will it be optimized into an abshi2 ?
;; it will leave better code, because the tsthi might be 
;; optimized away!!
; -- just a thought - don't have time to check 
;
;(define_expand "abshi2"
;  [(match_operand:HI 0 "general_operand" "")
;   (match_operand:HI 1 "general_operand" "")]
;  ""
;  "
;{
;  rtx label = gen_label_rtx ();
;
;  /* do I need this? */
;  do_pending_stack_adjust ();
;
;  emit_move_insn (operands[0], operands[1]);
;
;  emit_insn (gen_tsthi (operands[0]));
;  emit_insn (gen_bge (label1));
;
;  emit_insn (gen_neghi(operands[0], operands[0])
;  
;  emit_barrier ();
;
;  emit_label (label);
;
;  /* allow REG_NOTES to be set on last insn (labels don't have enough
;     fields, and can't be used for REG_NOTES anyway).  */
;  emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));
;  DONE;
;}")
X
;; negate insns
X
(define_insn "negdf2"
X  [(set (match_operand:DF 0 "general_operand" "=fR,Q")
X	(neg:DF (match_operand:DF 1 "register_operand" "0,0")))]
X  "TARGET_FPU"
X  "negd %0"
X  [(set_attr "length" "1,2")])
X
(define_insn "neghi2"
X  [(set (match_operand:HI 0 "general_operand" "=rR,Q")
X	(neg:HI (match_operand:HI 1 "general_operand" "0,0")))]
X  ""
X  "neg %0"
X  [(set_attr "length" "1,2")])
X
(define_insn "negqi2"
X  [(set (match_operand:QI 0 "general_operand" "=rR,Q")
X	(neg:QI (match_operand:QI 1 "general_operand" "0,0")))]
X  ""
X  "negb %0"
X  [(set_attr "length" "1,2")])
X
X
;; Unconditional and other jump instructions
(define_insn "jump"
X  [(set (pc)
X	(label_ref (match_operand 0 "" "")))]
X  ""
X  "jmp %l0"
X  [(set_attr "length" "2")])
X
(define_insn ""
X  [(set (pc)
X    (label_ref (match_operand 0 "" "")))
X   (clobber (const_int 1))]
X  ""
X  "jmp %l0"
X  [(set_attr "length" "2")])
X
(define_insn "tablejump"
X  [(set (pc) (match_operand:HI 0 "general_operand" "rR,Q"))
X   (use (label_ref (match_operand 1 "" "")))]
X  ""
X  "jmp %0"
X  [(set_attr "length" "1,2")])
X
;; indirect jump - let's be conservative!
;; allow only register_operand, even though we could also 
;; allow labels etc.
X
(define_insn "indirect_jump"
X  [(set (pc) (match_operand:HI 0 "register_operand" "r"))]
X  ""
X  "jmp (%0)")
X
;;- jump to subroutine
X
(define_insn "call"
X  [(call (match_operand:HI 0 "general_operand" "R,Q")
X	 (match_operand:HI 1 "general_operand" "g,g"))
;;   (use (reg:HI 0)) what was that ???
X  ]
X  ;;- Don't use operand 1 for most machines.
X  ""
X  "jsr pc, %0"
X  [(set_attr "length" "1,2")])
X
;;- jump to subroutine
(define_insn "call_value"
X  [(set (match_operand 0 "" "")
X	(call (match_operand:HI 1 "general_operand" "R,Q")
X	      (match_operand:HI 2 "general_operand" "g,g")))
;;   (use (reg:HI 0)) - what was that ????
X  ]
X  ;;- Don't use operand 2 for most machines.
X  ""
X  "jsr pc, %1"
X  [(set_attr "length" "1,2")])
X
;;- nop instruction
(define_insn "nop"
X  [(const_int 0)]
X  ""
X  "nop")
X
X
;;- multiply 
X
(define_insn "muldf3"
X  [(set (match_operand:DF 0 "register_operand" "=a,a,a")
X	(mult:DF (match_operand:DF 1 "register_operand" "%0,0,0")
X		 (match_operand:DF 2 "general_operand" "fR,Q,F")))]
X  "TARGET_FPU"
X  "muld %2, %0"
X  [(set_attr "length" "1,2,5")])
X
;; 16 bit result multiply:
;; currently we multiply only into odd registers, so we don't use two 
;; registers - but this is a bit inefficient at times. If we define 
;; a register class for each register, then we can specify properly 
;; which register need which scratch register ....
X
(define_insn "mulhi3"
X  [(set (match_operand:HI 0 "register_operand" "=d,d") ; multiply regs
X	(mult:HI (match_operand:HI 1 "register_operand" "%0,0")
X		 (match_operand:HI 2 "general_operand" "rR,Qi")))]
X  "TARGET_45"
X  "mul %2, %0"
X  [(set_attr "length" "1,2")])
X
;; 32 bit result
(define_insn "mulhisi3"
X  [(set (match_operand:SI 0 "register_operand" "=r,r") ; even numbered!
X	(mult:SI (match_operand:HI 1 "register_operand" "%0,0")
X		 (match_operand:HI 2 "general_operand" "rR,Qi")))]
X  "TARGET_45"
X  "mul %2, %0"
X  [(set_attr "length" "1,2")])
X
;;- divide
;; how can I use the remainder ? - 
;; modsidi and move upper register to lower ????
X
(define_insn "divdf3"
X  [(set (match_operand:DF 0 "register_operand" "=a,a,a")
X	(div:DF (match_operand:DF 1 "register_operand" "0,0,0")
X		(match_operand:DF 2 "general_operand" "fR,Q,F")))]
X  "TARGET_FPU"
X  "divd %2, %0"
X  [(set_attr "length" "1,2,5")])
X
(define_insn ""
X  [(set (match_operand:HI 0 "general_operand" "=r,r")
X	(truncate:HI 
X	 (div:SI
X	  (match_operand:SI 1 "general_operand" "0,0")
X	  (sign_extend:SI (match_operand:HI 2 "general_operand" "rR,Q")))))]
X  "TARGET_45"
X  "div %2,%0"
X  [(set_attr "length" "1,2")])
X
;; - problem matching the (sign_extend:SI (const_int ...))
; used without -O 
(define_insn ""
X  [(set (match_operand:HI 0 "general_operand" "=r")
X	(truncate:HI 
X	 (div:SI
X	  (match_operand:SI 1 "general_operand" "0")
X	  (sign_extend:SI (match_operand 2 "immediate_operand" "n")))))]
X  "TARGET_45"
X  "div %2,%0"
X  [(set_attr "length" "2")])
X
; used with -O
(define_insn ""
X  [(set (match_operand:HI 0 "general_operand" "=r")
X	(truncate:HI 
X	 (div:SI
X	  (match_operand:SI 1 "general_operand" "0")
X	  (match_operand:SI 2 "immediate_operand" "i"))))]
X  "TARGET_45"
X  "div %2,%0"
X  [(set_attr "length" "2")])
X
(define_expand "divhi3"
X  [(set (match_dup 3)
X	(sign_extend:SI (match_operand:HI 1 "general_operand" "g")))
X   (set (match_operand:HI 0 "general_operand" "g")
X	(truncate:HI 
X	 (div:SI
X	  (match_dup 3)
X	  (sign_extend:SI (match_operand:HI 2 "general_operand" "g")))))]
X  "TARGET_45"
X  "operands[3] = gen_reg_rtx (SImode);")
X
(define_expand "udivqi"
X  [(set (subreg:HI (match_dup 3) 1)
X	(zero_extend:HI (match_operand:QI 1 "general_operand" "g")))
X   (set (subreg:HI (match_dup 3) 0)
X	(const_int 0))
X   (set (match_dup 4)
X	(sign_extend:HI (match_operand:QI 2 "general_operand" "g")))
X   (set (match_dup 5)
X	(and:HI (match_dup 4)
X		(const_int 255)))
X   (set (match_dup 6)
X	(truncate:HI 
X	 (div:SI
X	  (match_dup 3)
X	  (sign_extend:SI (match_dup 5)))))
X   (set (match_operand:QI 0 "general_operand" "g")
X	(truncate:QI (match_dup 6)))]
X  "TARGET_45"
X  "
{
X  operands[3] = gen_reg_rtx (SImode);
X  operands[4] = gen_reg_rtx (HImode);
X  operands[5] = gen_reg_rtx (HImode);
X  operands[6] = gen_reg_rtx (HImode);
}")
X   
;; we must restrict it to divide by 15-bit constant...
(define_expand "udivhi3"
X  [(set (subreg:HI (match_dup 3) 1)
X	(match_operand:HI 1 "general_operand" "g"))
X   (set (subreg:HI (match_dup 3) 0)
X	(const_int 0))
X   (set (match_operand:HI 0 "general_operand" "g")
X	(truncate:HI 
X	 (div:SI
X	  (match_dup 3)
X	  (sign_extend:SI (match_operand:HI 2 "immediate15_operand" "n")))))]
X  "TARGET_45"
X  "
{
X  operands[3] = gen_reg_rtx (SImode);
X  
X  if (GET_CODE (operands[2]) != CONST_INT
X      || ((INTVAL (operands[2]) & 0x8000) != 0x0000))
X    FAIL;
}")
X
(define_insn ""
X  [(set (subreg:HI (match_operand:SI 0 "general_operand" "=r,r") 1)
X	(truncate:HI 
X	 (mod:SI
X	  (match_operand:SI 1 "general_operand" "0,0")
X	  (sign_extend:SI (match_operand:HI 2 "nonimmediate_operand" "rR,Q")))))]
X  "TARGET_45"
X  "div %2,%0"
X  [(set_attr "length" "1,2")])
X
;; (sign_extend:SI (const_int ))
; w/o -O
(define_insn ""
X  [(set (subreg:HI (match_operand:SI 0 "general_operand" "=r") 1)
X	(truncate:HI 
X	 (mod:SI
X	  (match_operand:SI 1 "general_operand" "0")
X	  (sign_extend:SI (match_operand 2 "immediate_operand" "i")))))]
X  "TARGET_45"
X  "div %2,%0"
X  [(set_attr "length" "2")])
; w/ -O
(define_insn ""
X  [(set (subreg:HI (match_operand:SI 0 "general_operand" "=r") 1)
X	(truncate:HI 
X	 (mod:SI
X	  (match_operand:SI 1 "general_operand" "0")
X	  (match_operand:SI 2 "immediate_operand" "i"))))]
X  "TARGET_45"
X  "div %2,%0"
X  [(set_attr "length" "2")])
X
(define_expand "modhi3"
X  [(set (match_dup 3)
X	(sign_extend:SI (match_operand:HI 1 "general_operand" "g")))
X   (set (subreg:HI (match_dup 3) 1)
X	(truncate:HI 
X	 (mod:SI
X	  (match_dup 3)
X	  (sign_extend:SI (match_operand:HI 2 "general_operand" "g")))))
X   (set (match_operand:HI 0 "general_operand" "g")
X	(subreg:HI (match_dup 3) 1))]
X  "TARGET_45"
X  "operands[3] = gen_reg_rtx (SImode);")
X
;; we must restrict it to mod by 15 bit constant
(define_expand "umodhi3"
X  [(set (subreg:HI (match_dup 3) 0)
X	(match_operand:HI 1 "general_operand" "g"))
X   (set (subreg:HI (match_dup 3) 1)
X	(const_int 0))
X   (set (subreg:HI (match_dup 3) 1)
X	(truncate:HI 
X	 (mod:SI
X	  (match_dup 3)
X	  (sign_extend:SI (match_operand:HI 2 "immediate15_operand" "n")))))
X   (set (match_operand:HI 0 "general_operand" "g")
X	(subreg:HI (match_dup 3) 1))]
X  "TARGET_45"
X  "
{
X  operands[3] = gen_reg_rtx (SImode);
X  
X  if (GET_CODE (operands[2]) != CONST_INT
X      || ((INTVAL (operands[2]) & 0x8000) != 0x0000))
X    FAIL;
}")
X
(define_insn ""
X  [(set (subreg:HI (match_operand:SI 0 "general_operand" "=r,r") 0)
X	(truncate:HI 
X	 (div:SI
X	  (match_operand:SI 1 "general_operand" "0,0")
X	  (sign_extend:SI (match_operand:HI 2 "nonimmediate_operand" "rR,Q")))))
X   (set (subreg:HI (match_dup 0) 1)
X	(truncate:HI 
X	 (mod:SI
X	  (match_dup 1)
X	  (sign_extend:SI (match_dup 2)))))]
X  "TARGET_45"
X  "div %2, %0"
X  [(set_attr "length" "1,2")])
X
;; (sign_extend:SI (const_int))
; w/o -O 
(define_insn ""
X  [(set (subreg:HI (match_operand:SI 0 "general_operand" "=r") 0)
X	(truncate:HI 
X	 (div:SI
X	  (match_operand:SI 1 "general_operand" "0")
X	  (sign_extend:SI (match_operand 2 "immediate_operand" "i")))))
X   (set (subreg:HI (match_dup 0) 1)
X	(truncate:HI 
X	 (mod:SI
X	  (match_dup 1)
X	  (sign_extend:SI (match_dup 2)))))]
X  "TARGET_45"
X  "div %2, %0"
X  [(set_attr "length" "2")])
; w/ -O
(define_insn ""
X  [(set (subreg:HI (match_operand:SI 0 "general_operand" "=r") 0)
X	(truncate:HI 
X	 (div:SI
X	  (match_operand:SI 1 "general_operand" "0")
X	  (match_operand:SI 2 "immediate_operand" "i"))))
X   (set (subreg:HI (match_dup 0) 1)
X	(truncate:HI 
X	 (mod:SI
X	  (match_dup 1)
X	  (match_dup 2))))]
X  "TARGET_45"
X  "div %2, %0"
X  [(set_attr "length" "2")])
X
(define_expand "divmodhi4"
X  [(set (match_dup 4)
X	(sign_extend:SI (match_operand:HI 1 "general_operand" "g")))
X   (set (subreg:HI (match_dup 4) 0)
X	(truncate:HI 
X	 (div:SI
X	  (match_dup 4)
X	  (sign_extend:SI (match_operand:HI 2 "general_operand" "g")))))
X   (set (subreg:HI (match_dup 4) 1)
X	(truncate:HI 
X	 (mod:SI
X	  (match_dup 4)
X	  (sign_extend:SI (match_dup 2)))))
X   (set (match_operand:HI 0 "general_operand" "g")
X	(subreg:HI (match_dup 4) 0))
X   (set (match_operand:HI 3 "general_operand" "g")
X	(subreg:HI (match_dup 4) 1))]
X  "TARGET_45"
X  "operands[4] = gen_reg_rtx(SImode);")
X
(define_expand "udivmodhi4"
X  [(set (subreg:HI (match_dup 3) 1)
X	(match_operand:HI 1 "general_operand" "g"))
X   (set (subreg:HI (match_dup 3) 0)
X	(const_int 0))
X   (set (subreg:HI (match_dup 4) 0)
X	(truncate:HI 
X	 (div:SI
X	  (match_dup 4)
X	  (sign_extend:SI (match_operand:HI 2 "immediate15_operand" "n")))))
X   (set (subreg:HI (match_dup 4) 1)
X	(truncate:HI 
X	 (mod:SI
X	  (match_dup 4)
X	  (sign_extend:SI (match_dup 2)))))
X   (set (match_operand:HI 0 "general_operand" "g")
X	(subreg:HI (match_dup 4) 0))
X   (set (match_operand:HI 3 "general_operand" "g")
X	(subreg:HI (match_dup 4) 1))]
X  "TARGET_45"
X  "
{
X  operands[3] = gen_reg_rtx (SImode);
X  
X  if (GET_CODE (operands[2]) != CONST_INT
X      || ((INTVAL (operands[2]) & 0x8000) != 0x0000))
X    FAIL;
}")
X
;; truncate used in div/mod patterns
(define_insn ""
X  [(set (match_operand:QI 0 "general_operand" "=r,r")
X	(truncate:QI (match_operand:HI 1 "general_operand" "0,r")))]
X  "TARGET_45"
X  "@
X   ; nop
X   movb %1, %0"
X  [(set_attr "length" "0,1")])
X   
;; is rotate doing the right thing to be included here ????
X
;;- Local variables:
;;- mode:emacs-lisp
;;- comment-start: ";;- "
;;- eval: (set-syntax-table (copy-sequence (syntax-table)))
;;- eval: (modify-syntax-entry ?[ "(]")
;;- eval: (modify-syntax-entry ?] ")[")
;;- eval: (modify-syntax-entry ?{ "(}")
;;- eval: (modify-syntax-entry ?} "){")
;;- End:
SHAR_EOF
chmod 0600 config/pdp11/pdp11.md ||
echo 'restore of config/pdp11/pdp11.md failed'
Wc_c="`wc -c < 'config/pdp11/pdp11.md'`"
test 53378 -eq "$Wc_c" ||
	echo 'config/pdp11/pdp11.md: original size 53378, current size' "$Wc_c"
fi
# ============= config/pdp11/xm-pdp11.h ==============
if test -f 'config/pdp11/xm-pdp11.h' -a X"$1" != X"-c"; then
	echo 'x - skipping config/pdp11/xm-pdp11.h (File already exists)'
else
echo 'x - extracting config/pdp11/xm-pdp11.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'config/pdp11/xm-pdp11.h' &&
/* Configuration for GNU C-compiler for pdp-11 family.
X   Copyright (C) 1991,1992,1993 Michael K. Gschwind (mike@vlsivie.tuwien.ac.at)
X
X This file is part of GNU CC.
X
X GNU CC is free software; you can redistribute it and/or modify
X it under the terms of the GNU General Public License as published by
X the Free Software Foundation; either version 1, or (at your option)
X any later version.
X
X GNU CC is distributed in the hope that it will be useful,
X but WITHOUT ANY WARRANTY; without even the implied warranty of
X MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X GNU General Public License for more details.
X
X You should have received a copy of the GNU General Public License
X along with GNU CC; see the file COPYING.  If not, write to
X the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
*/
X
/* ???? */
/* xm is if you want to run gcc here ??? */
/* too big !!! */
X
#error YOU LOSE! Gcc cannot run on a pdp-11 due to size problems!
X
X
SHAR_EOF
chmod 0644 config/pdp11/xm-pdp11.h ||
echo 'restore of config/pdp11/xm-pdp11.h failed'
Wc_c="`wc -c < 'config/pdp11/xm-pdp11.h'`"
test 969 -eq "$Wc_c" ||
	echo 'config/pdp11/xm-pdp11.h: original size 969, current size' "$Wc_c"
fi
exit 0
